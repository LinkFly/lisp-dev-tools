FFI::%ALIGN-DATA
(((:LAMBDA-LIST) FFI::DATA FFI::ALIGN) ((SI:LOCATION DEFMACRO FFI::%ALIGN-DATA) #P"SRC:LSP;FFI.LSP.NEWEST" . 2901))
FFI::%CONVERT-TO-ARG-TYPE
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN FFI::%CONVERT-TO-ARG-TYPE) #P"SRC:LSP;FFI.LSP.NEWEST" . 17025))
FFI::%CONVERT-TO-FFI-TYPE
(((:LAMBDA-LIST) TYPE &OPTIONAL FFI::CONTEXT) ((SI:LOCATION DEFUN FFI::%CONVERT-TO-FFI-TYPE) #P"SRC:LSP;FFI.LSP.NEWEST" . 2501))
FFI::%CONVERT-TO-RETURN-TYPE
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN FFI::%CONVERT-TO-RETURN-TYPE) #P"SRC:LSP;FFI.LSP.NEWEST" . 17285))
FFI::%FOREIGN-DATA-REF
(((:LAMBDA-LIST) FFI::OBJ FFI::NDX TYPE &OPTIONAL (FFI::SIZE 0 FFI::SIZE-P)) ((SI:LOCATION DEFUN FFI::%FOREIGN-DATA-REF) #P"SRC:LSP;FFI.LSP.NEWEST" . 10015))
FFI::%FOREIGN-DATA-SET
(((:LAMBDA-LIST) FFI::OBJ FFI::NDX TYPE FFI::VALUE) ((SI:LOCATION DEFUN FFI::%FOREIGN-DATA-SET) #P"SRC:LSP;FFI.LSP.NEWEST" . 9683))
SI::%FORMATTER
(((:LAMBDA-LIST) SI::CONTROL-STRING) ((SI:LOCATION DEFUN SI::%FORMATTER) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 18280))
C::%MAKE-VAR
(((:LAMBDA-LIST) &KEY #:NAME (#:REF 0) #:REF-CCB #:REF-CLB #:READ-NODES #:SET-NODES #:KIND (#:FUNCTION C::*CURRENT-FUNCTION*) #:FUNCTIONS-SETTING #:FUNCTIONS-READING (#:LOC 'FFI:OBJECT) (#:TYPE T) (#:INDEX -1) #:IGNORABLE) ((SI:LOCATION DEFUN C::%MAKE-VAR) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 1460))
SI::%PRINT-PPRINT-DISPATCH-ENTRY
(((:LAMBDA-LIST) SI::ENTRY STREAM SI::DEPTH) ((SI:LOCATION DEFUN SI::%PRINT-PPRINT-DISPATCH-ENTRY) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 38206))
SI::%PRINT-PPRINT-DISPATCH-TABLE
(((:LAMBDA-LIST) SI::TABLE STREAM SI::DEPTH) ((SI:LOCATION DEFUN SI::%PRINT-PPRINT-DISPATCH-TABLE) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 39020))
SI::%SET-FORMAT-DIRECTIVE-EXPANDER
(((:LAMBDA-LIST) CHAR SI::FN) ((SI:LOCATION DEFUN SI::%SET-FORMAT-DIRECTIVE-EXPANDER) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 25935))
SI::%SET-FORMAT-DIRECTIVE-INTERPRETER
(((:LAMBDA-LIST) CHAR SI::FN) ((SI:LOCATION DEFUN SI::%SET-FORMAT-DIRECTIVE-INTERPRETER) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 26082))
*
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&REST NUMBERS)

Returns the product of the args.  With no args, returns 1.
") ((:LAMBDA-LIST) &REST SI::NUMBERS) ((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The value of the last top-level form.
") ((SI:LOCATION DEFINE-COMPILER-MACRO *) #P"SRC:CMP;CMPNUM.LSP.NEWEST" . 1625))
C::*ACTIVE-HANDLERS*
(((SI:LOCATION DEFVAR C::*ACTIVE-HANDLERS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 1187))
C::*ACTIVE-PROTECTION*
(((SI:LOCATION DEFVAR C::*ACTIVE-PROTECTION*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 1219))
C::*ALLOW-C-LOCAL-DECLARATION*
(((SI:LOCATION DEFVAR C::*ALLOW-C-LOCAL-DECLARATION*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 4025))
SI::*ALLOW-RECURSIVE-DEBUG*
(((SI:LOCATION DEFVAR SI::*ALLOW-RECURSIVE-DEBUG*) #P"SRC:LSP;TOP.LSP.NEWEST" . 17552))
C::*AR*
(((SI:LOCATION DEFVAR C::*AR*) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 1356))
C::*AUTOMATIC-CHECK-TYPE-IN-LAMBDA*
(((SI:LOCATION DEFVAR C::*AUTOMATIC-CHECK-TYPE-IN-LAMBDA*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 2598))
C::*AUX-CLOSURE*
(((SI:LOCATION DEFVAR C::*AUX-CLOSURE*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 3473))
SI::*BREAK-ENV*
(((SI:LOCATION DEFVAR SI::*BREAK-ENV*) #P"SRC:LSP;TOP.LSP.NEWEST" . 1111))
SI::*BREAK-HIDDEN-FUNCTIONS*
(((SI:LOCATION DEFVAR SI::*BREAK-HIDDEN-FUNCTIONS*) #P"SRC:LSP;TOP.LSP.NEWEST" . 1547))
SI::*BREAK-HIDDEN-PACKAGES*
(((SI:LOCATION DEFVAR SI::*BREAK-HIDDEN-PACKAGES*) #P"SRC:LSP;TOP.LSP.NEWEST" . 1627))
SI::*BREAK-LEVEL*
(((SI:LOCATION DEFVAR SI::*BREAK-LEVEL*) #P"SRC:LSP;TOP.LSP.NEWEST" . 1053))
SI::*BREAK-MESSAGE*
(((SI:LOCATION DEFVAR SI::*BREAK-MESSAGE*) #P"SRC:LSP;TOP.LSP.NEWEST" . 1371))
SI:*BREAK-READTABLE*
(((SI:LOCATION DEFVAR SI:*BREAK-READTABLE*) #P"SRC:LSP;TOP.LSP.NEWEST" . 1401))
C::*C1-DISPATCH-TABLE*
(((SI:LOCATION DEFPARAMETER C::*C1-DISPATCH-TABLE*) #P"SRC:CMP;CMPTABLES.LSP.NEWEST" . 6835))
C::*C1FORM-LEVEL*
(((SI:LOCATION DEFVAR C::*C1FORM-LEVEL*) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 7291))
C::*C1NIL*
(((SI:LOCATION DEFVAR C::*C1NIL*) #P"SRC:CMP;CMPEVAL.LSP.NEWEST" . 1406))
C::*C1T*
(((SI:LOCATION DEFVAR C::*C1T*) #P"SRC:CMP;CMPEVAL.LSP.NEWEST" . 1508))
C::*C2-DISPATCH-TABLE*
(((SI:LOCATION DEFPARAMETER C::*C2-DISPATCH-TABLE*) #P"SRC:CMP;CMPTABLES.LSP.NEWEST" . 6991))
C::*CALLBACKS*
(((SI:LOCATION DEFVAR C::*CALLBACKS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 2167))
C:*CC*
(((SI:LOCATION DEFVAR C:*CC*) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 800))
C::*CC-FLAGS*
(((SI:LOCATION DEFVAR C::*CC-FLAGS*) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 1430))
C::*CC-FORMAT*
(((SI:LOCATION DEFVAR C::*CC-FORMAT*) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 1790))
C:*CC-OPTIMIZE*
(((SI:LOCATION DEFVAR C:*CC-OPTIMIZE*) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 1563))
C::*CINLINE-DISPATCH-TABLE*
(((SI:LOCATION DEFPARAMETER C::*CINLINE-DISPATCH-TABLE*) #P"SRC:CMP;CMPTABLES.LSP.NEWEST" . 7566))
C::*CLINES-STRING-LIST*
(((SI:LOCATION DEFVAR C::*CLINES-STRING-LIST*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 7303))
CLOS::*CLOS-BOOTED*
(((SI:LOCATION DEFPARAMETER CLOS::*CLOS-BOOTED*) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 604))
C::*CMP-ENV*
(((SI:LOCATION DEFVAR C::*CMP-ENV*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 4685))
C::*CMP-ENV-ROOT*
(((SI:LOCATION DEFVAR C::*CMP-ENV-ROOT*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 5868))
C::*CMPERR-TAG*
(((SI:LOCATION DEFCONSTANT C::*CMPERR-TAG*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 1145))
C::*CMPINCLUDE*
(((SI:LOCATION DEFVAR C::*CMPINCLUDE*) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 761))
SI::*COMMAND-BREAK-ENABLE*
(((SI:LOCATION DEFVAR SI::*COMMAND-BREAK-ENABLE*) #P"SRC:LSP;CMDLINE.LSP.NEWEST" . 687))
C::*COMPILE-FILE-POSITION*
(((SI:LOCATION DEFVAR C::*COMPILE-FILE-POSITION*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 1084))
*COMPILE-PRINT*
(((SI:LOCATION DEFVAR *COMPILE-PRINT*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 1400))
C::*COMPILE-TIME-TOO*
(((SI:LOCATION DEFVAR C::*COMPILE-TIME-TOO*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 7533))
C:*COMPILE-TO-LINKING-CALL*
(((SI:LOCATION DEFVAR C:*COMPILE-TO-LINKING-CALL*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 2255))
C::*COMPILE-TOPLEVEL*
(((SI:LOCATION DEFVAR C::*COMPILE-TOPLEVEL*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 7198))
*COMPILE-VERBOSE*
(((SI:LOCATION DEFVAR *COMPILE-VERBOSE*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 1552))
C:*COMPILER-BREAK-ENABLE*
(((SI:LOCATION DEFVAR C:*COMPILER-BREAK-ENABLE*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 1949))
C::*COMPILER-CONDITIONS*
(((SI:LOCATION DEFVAR C::*COMPILER-CONDITIONS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 1283))
SI:*COMPILER-CONSTANTS*
(((SI:LOCATION DEFVAR SI:*COMPILER-CONSTANTS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 8444))
C::*COMPILER-DECLARED-GLOBALS*
(((SI:LOCATION DEFVAR C::*COMPILER-DECLARED-GLOBALS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 2291))
C::*COMPILER-IN-USE*
(((SI:LOCATION DEFVAR C::*COMPILER-IN-USE*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 1986))
C::*COMPILER-INPUT*
(((SI:LOCATION DEFVAR C::*COMPILER-INPUT*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 2018))
C::*COMPILER-OUTPUT1*
(((SI:LOCATION DEFVAR C::*COMPILER-OUTPUT1*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 2044))
C::*COMPILER-OUTPUT2*
(((SI:LOCATION DEFVAR C::*COMPILER-OUTPUT2*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 2072))
C::*COMPILER-PHASE*
(((SI:LOCATION DEFVAR C::*COMPILER-PHASE*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 7115))
C::*COMPILER-TEMPS*
(((SI:LOCATION DEFVAR C::*COMPILER-TEMPS*) #P"SRC:CMP;CMPEVAL.LSP.NEWEST" . 5476))
SI::*CONDITION-RESTARTS*
(((SI:LOCATION DEFVAR SI::*CONDITION-RESTARTS*) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 1161))
C::*CURRENT-C2FORM*
(((SI:LOCATION DEFVAR C::*CURRENT-C2FORM*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 1054))
C::*CURRENT-FORM*
(((SI:LOCATION DEFVAR C::*CURRENT-FORM*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 952))
C::*CURRENT-FUNCTION*
(((SI:LOCATION DEFVAR C::*CURRENT-FUNCTION*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 4652))
C::*CURRENT-TOPLEVEL-FORM*
(((SI:LOCATION DEFVAR C::*CURRENT-TOPLEVEL-FORM*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 998))
C::*DEBUG*
(((SI:LOCATION DEFVAR C::*DEBUG*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 2501))
C::*DEBUG-COMPILER*
(((SI:LOCATION DEFVAR C::*DEBUG-COMPILER*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 6353))
*DEBUG-IO*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The stream used by the ECL debugger.  The initial value is a synonym stream to
*TERMINAL-IO*.
"))
SI::*DEBUG-STATUS*
(((SI:LOCATION DEFVAR SI::*DEBUG-STATUS*) #P"SRC:LSP;TOP.LSP.NEWEST" . 17590))
SI::*DEBUG-TPL-COMMANDS*
(((SI:LOCATION DEFVAR SI::*DEBUG-TPL-COMMANDS*) #P"SRC:LSP;TOP.LSP.NEWEST" . 23940))
*DEBUGGER-HOOK*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
This is either NIL or a function of two arguments, a condition and the value
of *DEBUGGER-HOOK*. This function can either handle the condition or return
which causes the standard debugger to execute. The system passes the value
of this variable to the function because it binds *DEBUGGER-HOOK* to NIL
around the invocation.
"))
SI::*DEFAULT-DEBUGGER-MAXIMUM-DEPTH*
(((SI:LOCATION DEFVAR SI::*DEFAULT-DEBUGGER-MAXIMUM-DEPTH*) #P"SRC:LSP;TOP.LSP.NEWEST" . 46799))
SI::*DEFAULT-FORMAT-ERROR-CONTROL-STRING*
(((SI:LOCATION DEFVAR SI::*DEFAULT-FORMAT-ERROR-CONTROL-STRING*) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 10316))
SI::*DEFAULT-FORMAT-ERROR-OFFSET*
(((SI:LOCATION DEFVAR SI::*DEFAULT-FORMAT-ERROR-OFFSET*) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 10368))
CLOS::*DEFAULT-METHOD-CACHE-SIZE*
(((SI:LOCATION DEFCONSTANT CLOS::*DEFAULT-METHOD-CACHE-SIZE*) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 638) ((DOCUMENTATION . VARIABLE) . "Size of hash tables for methods"))
*DEFAULT-PATHNAME-DEFAULTS*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The default pathname used by some pathname-handling functions such as ENOUGH-
NAMESTRING.
"))
C::*DELETE-FILES*
(((SI:LOCATION DEFVAR C::*DELETE-FILES*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 6383))
C::*DESTINATION*
(((SI:LOCATION DEFVAR C::*DESTINATION*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 6237))
SI::*DIGITS*
(((SI:LOCATION DEFVAR SI::*DIGITS*) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 4469))
C::*DO-TYPE-PROPAGATION*
(((SI:LOCATION DEFVAR C::*DO-TYPE-PROPAGATION*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 7000))
SI::*DRIBBLE-IO*
(((SI:LOCATION DEFVAR SI::*DRIBBLE-IO*) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 8527))
SI::*DRIBBLE-NAMESTRING*
(((SI:LOCATION DEFVAR SI::*DRIBBLE-NAMESTRING*) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 8553))
SI::*DRIBBLE-SAVED-TERMINAL-IO*
(((SI:LOCATION DEFVAR SI::*DRIBBLE-SAVED-TERMINAL-IO*) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 8587))
SI::*DRIBBLE-STREAM*
(((SI:LOCATION DEFVAR SI::*DRIBBLE-STREAM*) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 8496))
CLOS::*EARLY-METHODS*
(((SI:LOCATION DEFVAR CLOS::*EARLY-METHODS*) #P"SRC:CLOS;METHOD.LSP.NEWEST" . 712))
C::*ECL-INCLUDE-DIRECTORY*
(((SI:LOCATION DEFVAR C::*ECL-INCLUDE-DIRECTORY*) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 2738))
C::*ECL-LIBRARY-DIRECTORY*
(((SI:LOCATION DEFVAR C::*ECL-LIBRARY-DIRECTORY*) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 2881))
SI::*ELEMENTARY-TYPES*
(((SI:LOCATION DEFPARAMETER SI::*ELEMENTARY-TYPES*) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 25220))
C::*EMITTED-LOCAL-FUNS*
(((SI:LOCATION DEFVAR C::*EMITTED-LOCAL-FUNS*) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 2847))
C::*ENV*
(((SI:LOCATION DEFVAR C::*ENV*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 3303))
C::*ENV-LVL*
(((SI:LOCATION DEFVAR C::*ENV-LVL*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 3416))
C::*ENV-VAR-NAME-CACHE*
(((SI:LOCATION DEFPARAMETER C::*ENV-VAR-NAME-CACHE*) #P"SRC:CMP;CMPMAC.LSP.NEWEST" . 2059))
SI::*EOF*
(((SI:LOCATION DEFVAR SI::*EOF*) #P"SRC:LSP;TOP.LSP.NEWEST" . 1314))
*ERROR-OUTPUT*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The output stream to which error messages are output.  The initial value is an
synonym stream to *TERMINAL-IO*.
"))
SI::*ESTIMATE-CODE-SIZE-PUNT*
(((SI:LOCATION DEFVAR SI::*ESTIMATE-CODE-SIZE-PUNT*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 34176))
C::*EXIT*
(((SI:LOCATION DEFVAR C::*EXIT*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 4613))
SI::*EXPANDER-NEXT-ARG-MACRO*
(((SI:LOCATION DEFVAR SI::*EXPANDER-NEXT-ARG-MACRO*) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 14185))
*FEATURES*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
List of symbols that name features of the current version of ECL.  These
features are used in connection with the read macros #+ and #-.  When the
reader encounters
	#+ feature-spec form
it reads FORM in the usual manner if FEATURE-SPEC is satisfied.  Otherwise,
the reader just skips FORM.
	#- feature-spec form
is equivalent to
	#- (not feature-spec) form
A feature-spec may be a symbol, in which case the spec is satisfied iff the
symbol is an element of *FEATURES*.  Or else, a feature-spec must be one of
the following forms.
	(and {feature-spec}*)
		Satisfied iff all FEATURE-SPECs are satisfied
	(or {feature-spec}*)
		Satisfied iff at least one of FEATURE-SPECs is satisfied
	(not feature-spec)
		Satisfied iff FEATURE-SPEC is not satisfied
"))
FFI::*FFI-TYPES*
(((SI:LOCATION DEFVAR FFI::*FFI-TYPES*) #P"SRC:LSP;FFI.LSP.NEWEST" . 2169))
C::*FILES-TO-BE-DELETED*
(((SI:LOCATION DEFVAR C::*FILES-TO-BE-DELETED*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 6433))
C::*FIRST-ERROR*
(((SI:LOCATION DEFVAR C::*FIRST-ERROR*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 1120))
SI::*FORMAT-DIRECTIVE-EXPANDERS*
(((SI:LOCATION DEFVAR SI::*FORMAT-DIRECTIVE-EXPANDERS*) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 10120))
SI::*FORMAT-DIRECTIVE-INTERPRETERS*
(((SI:LOCATION DEFVAR SI::*FORMAT-DIRECTIVE-INTERPRETERS*) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 10223))
SI::*FRS-BASE*
(((SI:LOCATION DEFVAR SI::*FRS-BASE*) #P"SRC:LSP;TOP.LSP.NEWEST" . 1211))
SI::*FRS-TOP*
(((SI:LOCATION DEFVAR SI::*FRS-TOP*) #P"SRC:LSP;TOP.LSP.NEWEST" . 1233))
C::*GAZONK-COUNTER*
(((SI:LOCATION DEFVAR C::*GAZONK-COUNTER*) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 24141))
C::*GLOBAL-CFUNS-ARRAY*
(((SI:LOCATION DEFVAR C::*GLOBAL-CFUNS-ARRAY*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 8860))
C::*GLOBAL-ENTRIES*
(((SI:LOCATION DEFVAR C::*GLOBAL-ENTRIES*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 9752))
C::*GLOBAL-FUNS*
(((SI:LOCATION DEFVAR C::*GLOBAL-FUNS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 8815))
C::*GLOBAL-MACROS*
(((SI:LOCATION DEFVAR C::*GLOBAL-MACROS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 9781))
C::*GLOBAL-VAR-OBJECTS*
(((SI:LOCATION DEFVAR C::*GLOBAL-VAR-OBJECTS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 8685))
C::*GLOBAL-VARS*
(((SI:LOCATION DEFVAR C::*GLOBAL-VARS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 8758))
SI::*HANDLER-CLUSTERS*
(((SI:LOCATION DEFVAR SI::*HANDLER-CLUSTERS*) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 11306))
SI:*HELP-MESSAGE*
(((SI:LOCATION DEFVAR SI:*HELP-MESSAGE*) #P"SRC:LSP;CMDLINE.LSP.NEWEST" . 839) ((DOCUMENTATION . VARIABLE) . "Prints a help message about command line arguments of ECL"))
SI::*HIGHEST-TYPE-TAG*
(((SI:LOCATION DEFPARAMETER SI::*HIGHEST-TYPE-TAG*) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 25021))
SI:*IGNORE-EOF-ON-TERMINAL-IO*
(((DOCUMENTATION . VARIABLE) . "Variable in SI package:
ECL specific.
If the value of this variable is non-NIL, ECL ignores the EOF-character
(usually ^D) on the terminal.  The initial value is NIL.
"))
SI::*IHS-BASE*
(((SI:LOCATION DEFVAR SI::*IHS-BASE*) #P"SRC:LSP;TOP.LSP.NEWEST" . 1135))
SI::*IHS-CURRENT*
(((SI:LOCATION DEFVAR SI::*IHS-CURRENT*) #P"SRC:LSP;TOP.LSP.NEWEST" . 1186))
SI::*IHS-TOP*
(((SI:LOCATION DEFVAR SI::*IHS-TOP*) #P"SRC:LSP;TOP.LSP.NEWEST" . 1157))
C::*IHS-USED-P*
(((SI:LOCATION DEFVAR C::*IHS-USED-P*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 3562))
SI::*ILLEGAL-INSIDE-JUSTIFICATION*
(((SI:LOCATION DEFPARAMETER SI::*ILLEGAL-INSIDE-JUSTIFICATION*) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 79248))
C::*IN-ALL-SYMBOLS-FUNCTIONS*
(((SI:LOCATION DEFVAR C::*IN-ALL-SYMBOLS-FUNCTIONS*) #P"SRC:CMP;SYSFUN.LSP.NEWEST" . 35883))
SI:*INDENT-FORMATTED-OUTPUT*
(((DOCUMENTATION . VARIABLE) . "Variable in SI package:
ECL specific.
The FORMAT directive ~~% indents the next line, if the value of this variable
is non-NIL.  If NIL, ~~% simply does Newline.
"))
C::*INFO*
(((SI:LOCATION DEFVAR C::*INFO*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 651))
SI::*INITIAL-PPRINT-DISPATCH*
(((SI:LOCATION DEFVAR SI::*INITIAL-PPRINT-DISPATCH*) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 37716))
C::*INLINE-BLOCKS*
(((SI:LOCATION DEFVAR C::*INLINE-BLOCKS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 688))
SI::*INSIDE-TRACE*
(((SI:LOCATION DEFVAR SI::*INSIDE-TRACE*) #P"SRC:LSP;TRACE.LSP.NEWEST" . 2339))
SI::*INSPECT-HISTORY*
(((SI:LOCATION DEFVAR SI::*INSPECT-HISTORY*) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 612))
SI::*INSPECT-LEVEL*
(((SI:LOCATION DEFVAR SI::*INSPECT-LEVEL*) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 584))
SI::*INSPECT-MODE*
(((SI:LOCATION DEFVAR SI::*INSPECT-MODE*) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 643))
SI::*INTERRUPT-ENABLE*
(((DOCUMENTATION . VARIABLE) . "Variable in SI package:
ECL specific.
If the value of SI::*INTERRUPT-ENABLE* is non-NIL, ECL signals an error on the
terminal interrupt (this is the default case).  If it is NIL, ECL ignores the
interrupt and assigns T to SI::*INTERRUPT-ENABLE*.
"))
SI::*INTERRUPT-LONELY-THREADS-P*
(((SI:LOCATION DEFVAR SI::*INTERRUPT-LONELY-THREADS-P*) #P"SRC:LSP;TOP.LSP.NEWEST" . 18468))
SI::*INTERVALS-MASK*
(((SI:LOCATION DEFPARAMETER SI::*INTERVALS-MASK*) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 25183))
SI:*INVOKE-DEBUGGER-HOOK*
(((DOCUMENTATION . VARIABLE) . "Variable in SI package:
ECL specific.
This is either NIL or a designator for a function of two arguments,
to be run when the debugger is about to be entered.  The function is
run with *INVOKE-DEBUGGER-HOOK* bound to NIL to minimize recursive
errors, and receives as arguments the condition that triggered
debugger entry and the previous value of *INVOKE-DEBUGGER-HOOK*

This mechanism is an extension similar to the standard *DEBUGGER-HOOK*.
In contrast to *DEBUGGER-HOOK*, it is observed by INVOKE-DEBUGGER even when
called by BREAK.
"))
SI::*LAST-ERROR*
(((SI:LOCATION DEFVAR SI::*LAST-ERROR*) #P"SRC:LSP;TOP.LSP.NEWEST" . 1344))
C::*LAST-LABEL*
(((SI:LOCATION DEFVAR C::*LAST-LABEL*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 4590))
C::*LCL*
(((SI:LOCATION DEFVAR C::*LCL*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 2965))
C::*LD*
(((SI:LOCATION DEFVAR C::*LD*) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 1191))
C::*LD-BUNDLE-FLAGS*
(((SI:LOCATION DEFVAR C::*LD-BUNDLE-FLAGS*) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 2281))
C::*LD-FLAGS*
(((SI:LOCATION DEFVAR C::*LD-FLAGS*) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 2045))
C::*LD-FORMAT*
(((SI:LOCATION DEFVAR C::*LD-FORMAT*) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 1649))
C::*LD-RPATH*
(((SI:LOCATION DEFVAR C::*LD-RPATH*) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 3019))
C::*LD-SHARED-FLAGS*
(((SI:LOCATION DEFVAR C::*LD-SHARED-FLAGS*) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 2147))
C::*LEVEL*
(((SI:LOCATION DEFVAR C::*LEVEL*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 3132))
C::*LEX*
(((SI:LOCATION DEFVAR C::*LEX*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 3189))
C::*LEX-ENV-VAR-NAME-CACHE*
(((SI:LOCATION DEFPARAMETER C::*LEX-ENV-VAR-NAME-CACHE*) #P"SRC:CMP;CMPMAC.LSP.NEWEST" . 2120))
C::*LINKING-CALLS*
(((SI:LOCATION DEFVAR C::*LINKING-CALLS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 8911))
SI:*LISP-INIT-FILE-LIST*
(((SI:LOCATION DEFVAR SI:*LISP-INIT-FILE-LIST*) #P"SRC:LSP;CMDLINE.LSP.NEWEST" . 724) ((DOCUMENTATION . VARIABLE) . "List of files automatically loaded when ECL is invoked."))
SI::*LISP-INITIALIZED*
(((SI:LOCATION DEFVAR SI::*LISP-INITIALIZED*) #P"SRC:LSP;TOP.LSP.NEWEST" . 15098))
C::*LOAD-OBJECTS*
(((SI:LOCATION DEFVAR C::*LOAD-OBJECTS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 7860))
C::*LOAD-TIME-VALUES*
(((SI:LOCATION DEFVAR C::*LOAD-TIME-VALUES*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 7935))
*LOAD-VERBOSE*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The default value for the :VERBOSE parameter of LOAD.
It initial value is T.
"))
C::*LOCAL-FUNS*
(((SI:LOCATION DEFVAR C::*LOCAL-FUNS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 9005))
SI::*LOGICAL-BLOCK-POPPER*
(((SI:LOCATION DEFVAR SI::*LOGICAL-BLOCK-POPPER*) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 14011))
SI::*LOOP-AFTER-BODY*
(((SI:LOCATION DEFVAR SI::*LOOP-AFTER-BODY*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 26379))
SI::*LOOP-AFTER-EPILOGUE*
(((SI:LOCATION DEFVAR SI::*LOOP-AFTER-EPILOGUE*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 27109))
SI::*LOOP-ANSI-UNIVERSE*
(((SI:LOCATION DEFPARAMETER SI::*LOOP-ANSI-UNIVERSE*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 88111))
SI::*LOOP-BEFORE-LOOP*
(((SI:LOCATION DEFVAR SI::*LOOP-BEFORE-LOOP*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 26329))
SI::*LOOP-BIND-STACK*
(((SI:LOCATION DEFVAR SI::*LOOP-BIND-STACK*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 25873))
SI::*LOOP-BODY*
(((SI:LOCATION DEFVAR SI::*LOOP-BODY*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 26358))
SI::*LOOP-COLLECTION-CRUFT*
(((SI:LOCATION DEFVAR SI::*LOOP-COLLECTION-CRUFT*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 28166))
SI::*LOOP-DECLARATIONS*
(((SI:LOCATION DEFVAR SI::*LOOP-DECLARATIONS*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 25109))
SI::*LOOP-DESETQ-CROCKS*
(((SI:LOCATION DEFVAR SI::*LOOP-DESETQ-CROCKS*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 25238))
SI::*LOOP-DESETQ-TEMPORARY*
(((SI:LOCATION DEFVAR SI::*LOOP-DESETQ-TEMPORARY*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 22018))
SI::*LOOP-DESTRUCTURING-HOOKS*
(((SI:LOCATION DEFVAR SI::*LOOP-DESTRUCTURING-HOOKS*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 21382) ((DOCUMENTATION . VARIABLE) . "If not NIL, this must be a list of two things:
a LET-like macro, and a SETQ-like macro, which perform LOOP-style destructuring."))
SI::*LOOP-DUPLICATE-CODE*
(((SI:LOCATION DEFVAR SI::*LOOP-DUPLICATE-CODE*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 29483))
SI::*LOOP-EMITTED-BODY*
(((SI:LOCATION DEFVAR SI::*LOOP-EMITTED-BODY*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 26731))
SI::*LOOP-EPILOGUE*
(((SI:LOCATION DEFVAR SI::*LOOP-EPILOGUE*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 26855))
SI::*LOOP-FINAL-VALUE-CULPRIT*
(((SI:LOCATION DEFVAR SI::*LOOP-FINAL-VALUE-CULPRIT*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 27307))
SI::*LOOP-INSIDE-CONDITIONAL*
(((SI:LOCATION DEFVAR SI::*LOOP-INSIDE-CONDITIONAL*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 27435))
SI::*LOOP-ITERATION-FLAG-VARIABLE*
(((SI:LOCATION DEFVAR SI::*LOOP-ITERATION-FLAG-VARIABLE*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 29519))
SI::*LOOP-ITERATION-VARIABLES*
(((SI:LOCATION DEFVAR SI::*LOOP-ITERATION-VARIABLES*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 26198))
SI::*LOOP-MACRO-ENVIRONMENT*
(((SI:LOCATION DEFVAR SI::*LOOP-MACRO-ENVIRONMENT*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 24767))
SI::*LOOP-MINIMAX-TYPE-INFINITIES-ALIST*
(((SI:LOCATION DEFVAR SI::*LOOP-MINIMAX-TYPE-INFINITIES-ALIST*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 13699))
SI::*LOOP-NAMED-VARIABLES*
(((SI:LOCATION DEFVAR SI::*LOOP-NAMED-VARIABLES*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 24893))
SI::*LOOP-NAMES*
(((SI:LOCATION DEFVAR SI::*LOOP-NAMES*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 24690))
SI::*LOOP-NEVER-STEPPED-VARIABLE*
(((SI:LOCATION DEFVAR SI::*LOOP-NEVER-STEPPED-VARIABLE*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 28019))
SI::*LOOP-NODECLARE*
(((SI:LOCATION DEFVAR SI::*LOOP-NODECLARE*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 26078))
SI::*LOOP-ORIGINAL-SOURCE-CODE*
(((SI:LOCATION DEFVAR SI::*LOOP-ORIGINAL-SOURCE-CODE*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 24418))
SI::*LOOP-PROLOGUE*
(((SI:LOCATION DEFVAR SI::*LOOP-PROLOGUE*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 26305))
SI::*LOOP-REAL-DATA-TYPE*
(((SI:LOCATION DEFVAR SI::*LOOP-REAL-DATA-TYPE*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 6092))
SI::*LOOP-SOURCE-CODE*
(((SI:LOCATION DEFVAR SI::*LOOP-SOURCE-CODE*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 24277))
SI::*LOOP-SOURCE-CONTEXT*
(((SI:LOCATION DEFVAR SI::*LOOP-SOURCE-CONTEXT*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 24596))
SI::*LOOP-UNIVERSE*
(((SI:LOCATION DEFVAR SI::*LOOP-UNIVERSE*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 20287))
SI::*LOOP-VARIABLES*
(((SI:LOCATION DEFVAR SI::*LOOP-VARIABLES*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 25002))
SI::*LOOP-WHEN-IT-VARIABLE*
(((SI:LOCATION DEFVAR SI::*LOOP-WHEN-IT-VARIABLE*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 27672))
SI::*LOOP-WRAPPERS*
(((SI:LOCATION DEFVAR SI::*LOOP-WRAPPERS*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 25692))
*MACROEXPAND-HOOK*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The value of this variable must be a three-argument function object.
Each time a macro form is expanded, ECL calls that function with
	1. the macro expansion function (see MACRO-FUNCTION)
	2. the macro form to expand
	3. an environment (NIL in most case)
as three arguments, and uses the returned value as the expanded form.
The initial value of this variable is the function FUNCALL.
"))
SI:*MAKE-CONSTANT
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (SYMBOL VALUE)

ECL specific.
Declares that the global variable named by SYMBOL is a constant with VALUE as
its constant value.
") ((:LAMBDA-LIST) SYMBOL SI::VALUE))
C::*MAKE-FORMS*
(((SI:LOCATION DEFVAR C::*MAKE-FORMS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 9109))
SI:*MAKE-SPECIAL
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (SYMBOL)

ECL specific.
Declares the variable named by NAME as a special variable.
") ((:LAMBDA-LIST) SYMBOL))
C::*MAX-ENV*
(((SI:LOCATION DEFVAR C::*MAX-ENV*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 3360))
C::*MAX-LEX*
(((SI:LOCATION DEFVAR C::*MAX-LEX*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 3257))
C::*MAX-TEMP*
(((SI:LOCATION DEFVAR C::*MAX-TEMP*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 3074))
SI::*MEMBER-TYPES*
(((SI:LOCATION DEFPARAMETER SI::*MEMBER-TYPES*) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 25106))
CLOS::*METHOD-COMBINATIONS*
(((SI:LOCATION DEFVAR CLOS::*METHOD-COMBINATIONS*) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 7743))
CLOS::*METHOD-SIZE*
(((SI:LOCATION DEFVAR CLOS::*METHOD-SIZE*) #P"SRC:CLOS;METHOD.LSP.NEWEST" . 547))
SI::*MODULE-FILES*
(((SI:LOCATION DEFVAR SI::*MODULE-FILES*) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/build/bare.lsp" . 4262))
SI:*MODULE-PROVIDER-FUNCTIONS*
(((SI:LOCATION DEFVAR SI:*MODULE-PROVIDER-FUNCTIONS*) #P"SRC:LSP;MODULE.LSP.NEWEST" . 793) ((DOCUMENTATION . VARIABLE) . "See function documentation for REQUIRE"))
SI::*MODULE-SYMBOLS*
(((SI:LOCATION DEFVAR SI::*MODULE-SYMBOLS*) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/build/bare.lsp" . 4231))
*MODULES*
(((SI:LOCATION DEFVAR *MODULES*) #P"SRC:LSP;MODULE.LSP.NEWEST" . 661) ((DOCUMENTATION . VARIABLE) . "This is a list of module names that have been loaded into Lisp so far.
It is used by PROVIDE and REQUIRE."))
C::*NEXT-CFUN*
(((SI:LOCATION DEFVAR C::*NEXT-CFUN*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 3715))
C::*NEXT-CMACRO*
(((SI:LOCATION DEFVAR C::*NEXT-CMACRO*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 3642))
CLOS:*NEXT-METHODS*
(((SI:LOCATION DEFVAR CLOS:*NEXT-METHODS*) #P"SRC:CLOS;METHOD.LSP.NEWEST" . 849))
C::*NOT-COMPILE-TIME*
(((SI:LOCATION DEFVAR C::*NOT-COMPILE-TIME*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 7566))
SI::*OLD-PRINT-LENGTH*
(((SI:LOCATION DEFVAR SI::*OLD-PRINT-LENGTH*) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 703))
SI::*OLD-PRINT-LEVEL*
(((SI:LOCATION DEFVAR SI::*OLD-PRINT-LEVEL*) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 671))
SI::*ONLY-SIMPLE-ARGS*
(((SI:LOCATION DEFVAR SI::*ONLY-SIMPLE-ARGS*) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 14475))
C::*OPTIMIZATION-QUALITY-SWITCHES*
(((SI:LOCATION DEFPARAMETER C::*OPTIMIZATION-QUALITY-SWITCHES*) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 673))
SI::*ORIG-ARGS-AVAILABLE*
(((SI:LOCATION DEFVAR SI::*ORIG-ARGS-AVAILABLE*) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 14797))
SI::*OUTPUT-LAYOUT-MODE*
(((SI:LOCATION DEFVAR SI::*OUTPUT-LAYOUT-MODE*) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 10559))
SI::*OUTSIDE-ARGS*
(((SI:LOCATION DEFVAR SI::*OUTSIDE-ARGS*) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 72027))
C::*P0-DISPATCH-TABLE*
(((SI:LOCATION DEFPARAMETER C::*P0-DISPATCH-TABLE*) #P"SRC:CMP;CMPTABLES.LSP.NEWEST" . 7462))
C::*P1-DISPATCH-TABLE*
(((SI:LOCATION DEFPARAMETER C::*P1-DISPATCH-TABLE*) #P"SRC:CMP;CMPTABLES.LSP.NEWEST" . 7321))
*PACKAGE*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The current package.  The initial value is the USER package.
"))
C::*PENDING-ACTIONS*
(((SI:LOCATION DEFVAR C::*PENDING-ACTIONS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 1252))
C::*PERMANENT-DATA*
(((SI:LOCATION DEFVAR C::*PERMANENT-DATA*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 7608))
C::*PERMANENT-OBJECTS*
(((SI:LOCATION DEFVAR C::*PERMANENT-OBJECTS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 7718))
C::*PRINC-STRING-LIMIT*
(((SI:LOCATION DEFVAR C::*PRINC-STRING-LIMIT*) #P"SRC:CMP;CMPFUN.LSP.NEWEST" . 589))
*PRINT-ARRAY*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
Specifies whether ECL should print elements when it prints arrays other than
strings.  ECL uses the following abbreviation notations.
	#<bit-vector n>		for bit-vectors
	#<vector n>		for vectors other than strings and bit-vectors
	#<array n>		for arrays other than vectors
where N is a number that identifies the array.
"))
*PRINT-BASE*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The radix used to print integers and ratios.  The value must be an integer
from 2 to 36, inclusive.  The initial value is 10.
"))
*PRINT-CASE*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
Specifies how to print ordinary symbols.  Possible values are:
	:UPCASE		in upper case
	:DOWNCASE	in lower case
	:CAPITALIZE	the first character in upper case, the rest in lower
The initial value is :UPCASE.
"))
*PRINT-CIRCLE*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
Specifies whether the ECL printer should take care of circular lists.
"))
*PRINT-ESCAPE*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
Specifies whether the ECL printer should output objects in the way that they
can be reread later if possible.
"))
*PRINT-GENSYM*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
Specifies whether the ECL printer should prefix uninterned symbols with \"#:\".
"))
*PRINT-LENGTH*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
Specifies how many elements the ECL printer should print when it prints a
list.  ECL printer prints all elements if the value of this variable is NIL.
"))
*PRINT-LEVEL*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
Specifies how many levels of depth the ECL printer should print when it prints
a list.  ECL printer prints all levels if the value of this variable is NIL.
"))
*PRINT-PRETTY*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
Specifies whether the ECL printer should pretty-print.  See PPRINT for more
information about pretty-printing.
"))
*PRINT-RADIX*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
Specifies whether the ECL printer should print the radix when it prints
integers and ratios.
"))
C::*PROCLAIM-FIXED-ARGS*
(((SI:LOCATION DEFVAR C::*PROCLAIM-FIXED-ARGS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 8537))
*QUERY-IO*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The query I/O stream. The initial value is a synonym stream to *TERMINAL-IO*.
"))
SI:*QUIT-TAG*
(((SI:LOCATION DEFVAR SI:*QUIT-TAG*) #P"SRC:LSP;TOP.LSP.NEWEST" . 992))
SI::*QUIT-TAGS*
(((SI:LOCATION DEFVAR SI::*QUIT-TAGS*) #P"SRC:LSP;TOP.LSP.NEWEST" . 1028))
*RANDOM-STATE*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The default random-state object used by RANDOM.
"))
C::*RANLIB*
(((SI:LOCATION DEFVAR C::*RANLIB*) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 1270))
*READ-BASE*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The radix used to read numbers.  The initial value is 10.
"))
*READ-DEFAULT-FLOAT-FORMAT*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The default float format the ECL reader uses when reading floats.  Must be one
of the symbols SHORT-FLOAT, SINGLE-FLOAT, DOUBLE-FLOAT, and LONG-FLOAT.
"))
*READ-SUPPRESS*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
When the value of this variable is non-NIL, the ECL reader parses input
characters without most of the ordinary processings such as interning.  Used
to skip over forms.
"))
*READTABLE*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The current readtable.
"))
C::*REG-AMOUNT*
(((SI:LOCATION DEFVAR C::*REG-AMOUNT*) #P"SRC:CMP;CMPTAG.LSP.NEWEST" . 1177))
SI::*REQUIRING*
(((SI:LOCATION DEFVAR SI::*REQUIRING*) #P"SRC:LSP;MODULE.LSP.NEWEST" . 1109))
C::*RESERVATION-CMACRO*
(((SI:LOCATION DEFVAR C::*RESERVATION-CMACRO*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 9511))
C::*RESERVATIONS*
(((SI:LOCATION DEFVAR C::*RESERVATIONS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 9473))
SI::*RESTART-CLUSTERS*
(((SI:LOCATION DEFVAR SI::*RESTART-CLUSTERS*) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 1130))
C::*SAFETY*
(((SI:LOCATION DEFVAR C::*SAFETY*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 2444))
SI::*SAVE-TYPES-DATABASE*
(((SI:LOCATION DEFPARAMETER SI::*SAVE-TYPES-DATABASE*) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 24980))
C::*SELF-DESTRUCTING-FASL*
(((SI:LOCATION DEFVAR C::*SELF-DESTRUCTING-FASL*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 9811))
C::*SET-LOC-DISPATCH-TABLE*
(((SI:LOCATION DEFPARAMETER C::*SET-LOC-DISPATCH-TABLE*) #P"SRC:CMP;CMPTABLES.LSP.NEWEST" . 7069))
C::*SETJMPS*
(((SI:LOCATION DEFVAR C::*SETJMPS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 7167))
SI::*SIMPLE-ARGS*
(((SI:LOCATION DEFVAR SI::*SIMPLE-ARGS*) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 14949))
C::*SPACE*
(((SI:LOCATION DEFVAR C::*SPACE*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 2482))
SI::*SPECIAL-CODE-SIZES*
(((SI:LOCATION DEFVAR SI::*SPECIAL-CODE-SIZES*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 33736))
C::*SPEED*
(((SI:LOCATION DEFVAR C::*SPEED*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 2463))
*STANDARD-INPUT*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The default input stream used by the ECL reader.  The initial value is a
synonym stream to *TERMINAL-IO*.
"))
*STANDARD-OUTPUT*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The default output stream used by the ECL printer.  The initial value is a
synonym stream to *TERMINAL-IO*.
"))
C::*STATIC-CONSTANTS*
(((SI:LOCATION DEFVAR C::*STATIC-CONSTANTS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 8285))
SI:*STEP-ACTION*
(((SI:LOCATION DEFVAR SI:*STEP-ACTION*) #P"SRC:LSP;TRACE.LSP.NEWEST" . 7332))
SI::*STEP-FORM*
(((SI:LOCATION DEFVAR SI::*STEP-FORM*) #P"SRC:LSP;TRACE.LSP.NEWEST" . 7359))
SI::*STEP-FUNCTIONS*
(((SI:LOCATION DEFVAR SI::*STEP-FUNCTIONS*) #P"SRC:LSP;TRACE.LSP.NEWEST" . 7419))
SI:*STEP-LEVEL*
(((SI:LOCATION DEFVAR SI:*STEP-LEVEL*) #P"SRC:LSP;TOP.LSP.NEWEST" . 1495))
SI::*STEP-TAG*
(((SI:LOCATION DEFVAR SI::*STEP-TAG*) #P"SRC:LSP;TRACE.LSP.NEWEST" . 7384))
SI::*SUBTYPEP-CACHE*
(((SI:LOCATION DEFVAR SI::*SUBTYPEP-CACHE*) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 954))
C:*SUPPRESS-COMPILER-MESSAGES*
(((SI:LOCATION DEFVAR C:*SUPPRESS-COMPILER-MESSAGES*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 1700))
C:*SUPPRESS-COMPILER-NOTES*
(((SI:LOCATION DEFVAR C:*SUPPRESS-COMPILER-NOTES*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 1840))
C:*SUPPRESS-COMPILER-WARNINGS*
(((SI:LOCATION DEFVAR C:*SUPPRESS-COMPILER-WARNINGS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 1894))
C::*T1-DISPATCH-TABLE*
(((SI:LOCATION DEFPARAMETER C::*T1-DISPATCH-TABLE*) #P"SRC:CMP;CMPTABLES.LSP.NEWEST" . 6913))
C::*T2-DISPATCH-TABLE*
(((SI:LOCATION DEFPARAMETER C::*T2-DISPATCH-TABLE*) #P"SRC:CMP;CMPTABLES.LSP.NEWEST" . 7243))
C::*TAGBODY-DEPTH*
(((SI:LOCATION DEFVAR C::*TAGBODY-DEPTH*) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 9431))
C::*TAIL-RECURSION-INFO*
(((SI:LOCATION DEFVAR C::*TAIL-RECURSION-INFO*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 3991))
C::*TEMP*
(((SI:LOCATION DEFVAR C::*TEMP*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 3012))
C::*TEMPORARY-OBJECTS*
(((SI:LOCATION DEFVAR C::*TEMPORARY-OBJECTS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 7789))
*TERMINAL-IO*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The terminal I/O stream.
"))
C::*TEXT-FOR-CLOSURE*
(((SI:LOCATION DEFVAR C::*TEXT-FOR-CLOSURE*) #P"SRC:CMP;CMPCALL.LSP.NEWEST" . 8008))
C::*TEXT-FOR-LEXICAL-LEVEL*
(((SI:LOCATION DEFVAR C::*TEXT-FOR-LEXICAL-LEVEL*) #P"SRC:CMP;CMPCALL.LSP.NEWEST" . 7898))
C::*TOP-LEVEL-FORMS*
(((SI:LOCATION DEFVAR C::*TOP-LEVEL-FORMS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 9049))
C::*TOPLEVEL-FORMS-TO-PRINT*
(((SI:LOCATION DEFVAR C::*TOPLEVEL-FORMS-TO-PRINT*) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 801))
SI::*TPL-COMMANDS*
(((SI:LOCATION DEFVAR SI::*TPL-COMMANDS*) #P"SRC:LSP;TOP.LSP.NEWEST" . 6441))
SI::*TPL-CONTINUABLE*
(((SI:LOCATION DEFVAR SI::*TPL-CONTINUABLE*) #P"SRC:LSP;TOP.LSP.NEWEST" . 1254))
SI::*TPL-LAST-COMPILE*
(((SI:LOCATION DEFVAR SI::*TPL-LAST-COMPILE*) #P"SRC:LSP;TOP.LSP.NEWEST" . 43777))
SI::*TPL-LAST-LOAD*
(((SI:LOCATION DEFVAR SI::*TPL-LAST-LOAD*) #P"SRC:LSP;TOP.LSP.NEWEST" . 43595))
SI::*TPL-LEVEL*
(((SI:LOCATION DEFVAR SI::*TPL-LEVEL*) #P"SRC:LSP;TOP.LSP.NEWEST" . 1433))
SI:*TPL-PROMPT-HOOK*
(((SI:LOCATION DEFVAR SI:*TPL-PROMPT-HOOK*) #P"SRC:LSP;TOP.LSP.NEWEST" . 1283))
SI::*TRACE-LEVEL*
(((SI:LOCATION DEFVAR SI::*TRACE-LEVEL*) #P"SRC:LSP;TRACE.LSP.NEWEST" . 517))
SI::*TRACE-LIST*
(((SI:LOCATION DEFVAR SI::*TRACE-LIST*) #P"SRC:LSP;TRACE.LSP.NEWEST" . 543))
SI::*TRACE-MAX-INDENT*
(((SI:LOCATION DEFVAR SI::*TRACE-MAX-INDENT*) #P"SRC:LSP;TRACE.LSP.NEWEST" . 569))
*TRACE-OUTPUT*
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The stream used for trace output.  The initial value is a synonym stream to
*TERMINAL-IO*.
"))
C::*TYPE-AND-CACHE*
(((SI:LOCATION DEFPARAMETER C::*TYPE-AND-CACHE*) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 2319))
C::*TYPE-OR-CACHE*
(((SI:LOCATION DEFPARAMETER C::*TYPE-OR-CACHE*) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 9004))
C::*TYPE-PROPAGATION-MESSAGES*
(((SI:LOCATION DEFPARAMETER C::*TYPE-PROPAGATION-MESSAGES*) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 616))
C::*UNDEFINED-VARS*
(((SI:LOCATION DEFVAR C::*UNDEFINED-VARS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 10098))
C::*UNWIND-EXIT*
(((SI:LOCATION DEFVAR C::*UNWIND-EXIT*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 4629))
SI::*UP-UP-AND-OUT-ALLOWED*
(((SI:LOCATION DEFVAR SI::*UP-UP-AND-OUT-ALLOWED*) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 13791))
SI::*UPGRADED-ARRAY-ELEMENT-TYPE-CACHE*
(((SI:LOCATION DEFVAR SI::*UPGRADED-ARRAY-ELEMENT-TYPE-CACHE*) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 1018))
FFI:*USE-DFFI*
(((SI:LOCATION DEFVAR FFI:*USE-DFFI*) #P"SRC:LSP;FFI.LSP.NEWEST" . 2218))
C::*USE-STATIC-CONSTANTS-P*
(((SI:LOCATION DEFVAR C::*USE-STATIC-CONSTANTS-P*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 8117))
C:*USER-CC-FLAGS*
(((SI:LOCATION DEFVAR C:*USER-CC-FLAGS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 6699))
C:*USER-LD-FLAGS*
(((SI:LOCATION DEFVAR C:*USER-LD-FLAGS*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 6468))
C::*VALUES-TYPE-AND-CACHE*
(((SI:LOCATION DEFPARAMETER C::*VALUES-TYPE-AND-CACHE*) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 7469))
C::*VALUES-TYPE-OR-CACHE*
(((SI:LOCATION DEFPARAMETER C::*VALUES-TYPE-OR-CACHE*) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 5780))
C::*VALUES-TYPE-PRIMARY-TYPE-CACHE*
(((SI:LOCATION DEFPARAMETER C::*VALUES-TYPE-PRIMARY-TYPE-CACHE*) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 3955))
C::*VALUES-TYPE-TO-N-TYPES-CACHE*
(((SI:LOCATION DEFPARAMETER C::*VALUES-TYPE-TO-N-TYPES-CACHE*) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 4588))
C::*VOLATILE*
(((SI:LOCATION DEFVAR C::*VOLATILE*) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 7146))
C::*WT-LOC-DISPATCH-TABLE*
(((SI:LOCATION DEFPARAMETER C::*WT-LOC-DISPATCH-TABLE*) #P"SRC:CMP;CMPTABLES.LSP.NEWEST" . 7157))
C::*WT-STRING-SIZE*
(((SI:LOCATION DEFVAR C::*WT-STRING-SIZE*) #P"SRC:CMP;CMPC-WT.LSP.NEWEST" . 3083))
+
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&REST NUMBERS)

Returns the sum of the args.  With no args, returns 0.
") ((:LAMBDA-LIST) &REST SI::NUMBERS) ((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The last top-level form.
") ((SI:LOCATION DEFINE-COMPILER-MACRO +) #P"SRC:CMP;CMPNUM.LSP.NEWEST" . 1712))
++
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The last-but-one top-level form.
"))
+++
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The last-but-two top-level form.
"))
C::+ALL-C1-FORMS+
(((SI:LOCATION DEFCONSTANT C::+ALL-C1-FORMS+) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 818))
SI::+ALL-CONDITIONS+
(((SI:LOCATION DEFCONSTANT SI::+ALL-CONDITIONS+) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 14901))
C::+ALL-INTEGER-REP-TYPES+
(((SI:LOCATION DEFCONSTANT C::+ALL-INTEGER-REP-TYPES+) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 628))
C::+ALL-NUMBER-REP-TYPES+
(((SI:LOCATION DEFCONSTANT C::+ALL-NUMBER-REP-TYPES+) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 890))
C::+ARRAY-DIMENSION-ACCESSOR+
(((SI:LOCATION DEFCONSTANT C::+ARRAY-DIMENSION-ACCESSOR+) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 9746))
SI::+BUILT-IN-TYPES+
(((SI:LOCATION DEFCONSTANT SI::+BUILT-IN-TYPES+) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 40890))
CLOS::+BUILTIN-CLASSES+
(((SI:LOCATION DEFCONSTANT CLOS::+BUILTIN-CLASSES+) #P"SRC:CLOS;BUILTIN.LSP.NEWEST" . 1536))
C::+C1-DISPATCH-ALIST+
(((SI:LOCATION DEFCONSTANT C::+C1-DISPATCH-ALIST+) #P"SRC:CMP;CMPTABLES.LSP.NEWEST" . 509))
C::+C1-FORM-HASH+
(((SI:LOCATION DEFCONSTANT C::+C1-FORM-HASH+) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 3006))
C::+C2-DISPATCH-ALIST+
(((SI:LOCATION DEFCONSTANT C::+C2-DISPATCH-ALIST+) #P"SRC:CMP;CMPTABLES.LSP.NEWEST" . 4179))
CLOS::+CLASS-SLOTS+
(((SI:LOCATION DEFPARAMETER CLOS::+CLASS-SLOTS+) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 2047))
SI::+CLOS-MODULE-FILES+
(((SI:LOCATION DEFVAR SI::+CLOS-MODULE-FILES+) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/build/clos/load.lsp" . 61))
SI::+CMP-MODULE-FILES+
(((SI:LOCATION DEFCONSTANT SI::+CMP-MODULE-FILES+) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/build/cmp/load.lsp" . 60))
C::+COERCION-TABLE+
(((SI:LOCATION DEFPARAMETER C::+COERCION-TABLE+) #P"SRC:CMP;CMPOPT.LSP.NEWEST" . 6357))
GRAY::+CONFLICTING-SYMBOLS+
(((SI:LOCATION DEFCONSTANT GRAY::+CONFLICTING-SYMBOLS+) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 21398))
SI:+DEFAULT-COMMAND-ARG-RULES+
(((SI:LOCATION DEFCONSTANT SI:+DEFAULT-COMMAND-ARG-RULES+) #P"SRC:LSP;CMDLINE.LSP.NEWEST" . 1765))
C::+ECL-LOCAL-STACK-FRAME-VARIABLE+
(((SI:LOCATION DEFCONSTANT C::+ECL-LOCAL-STACK-FRAME-VARIABLE+) #P"SRC:CMP;CMPSTACK.LSP.NEWEST" . 822))
C::+ECL-LOCAL-STACK-VARIABLE+
(((SI:LOCATION DEFCONSTANT C::+ECL-LOCAL-STACK-VARIABLE+) #P"SRC:CMP;CMPSTACK.LSP.NEWEST" . 880))
C::+ECL-STACK-FRAME-VARIABLE+
(((SI:LOCATION DEFCONSTANT C::+ECL-STACK-FRAME-VARIABLE+) #P"SRC:CMP;CMPSTACK.LSP.NEWEST" . 761))
C::+ERROR-FORMAT+
(((SI:LOCATION DEFCONSTANT C::+ERROR-FORMAT+) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 610))
C::+EXECUTABLE-FILE-FORMAT+
(((SI:LOCATION DEFVAR C::+EXECUTABLE-FILE-FORMAT+) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 2699))
C::+FATAL-FORMAT+
(((SI:LOCATION DEFCONSTANT C::+FATAL-FORMAT+) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 610))
C::+FOREIGN-ELT-TYPE-CODES+
(((SI:LOCATION DEFCONSTANT C::+FOREIGN-ELT-TYPE-CODES+) #P"SRC:CMP;CMPCBK.LSP.NEWEST" . 1644))
C::+INIT-ENV-FORM+
(((SI:LOCATION DEFCONSTANT C::+INIT-ENV-FORM+) #P"SRC:CMP;CMPGLOBALS.LSP.NEWEST" . 10301))
CLOS::+INITFORM-UNSUPPLIED+
(((SI:LOCATION DEFCONSTANT CLOS::+INITFORM-UNSUPPLIED+) #P"SRC:CLOS;SLOT.LSP.NEWEST" . 470))
C::+INLINE-FORMS+
(((SI:LOCATION DEFPARAMETER C::+INLINE-FORMS+) #P"SRC:CMP;SYSFUN.LSP.NEWEST" . 2705))
SI::+KNOWN-TYPEP-PREDICATES+
(((SI:LOCATION DEFCONSTANT SI::+KNOWN-TYPEP-PREDICATES+) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 10743))
C::+LAST-OPTIMIZATION-BIT+
(((SI:LOCATION DEFPARAMETER C::+LAST-OPTIMIZATION-BIT+) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 4555))
C::+LISP-PROGRAM-HEADER+
(((SI:LOCATION DEFCONSTANT C::+LISP-PROGRAM-HEADER+) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 7114))
C::+LISP-PROGRAM-INIT+
(((SI:LOCATION DEFCONSTANT C::+LISP-PROGRAM-INIT+) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 7767))
C::+LISP-PROGRAM-MAIN+
(((SI:LOCATION DEFCONSTANT C::+LISP-PROGRAM-MAIN+) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 8455))
FFI::+LOADED-LIBRARIES+
(((SI:LOCATION DEFVAR FFI::+LOADED-LIBRARIES+) #P"SRC:LSP;FFI.LSP.NEWEST" . 21686))
SI::+MAGIC-FORMS+
(((SI:LOCATION DEFCONSTANT SI::+MAGIC-FORMS+) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 52175))
C::+NOTE-FORMAT+
(((SI:LOCATION DEFCONSTANT C::+NOTE-FORMAT+) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 610))
FFI:+NULL-CSTRING-POINTER+
(((SI:LOCATION DEFVAR FFI:+NULL-CSTRING-POINTER+) #P"SRC:LSP;FFI.LSP.NEWEST" . 11116))
C::+OBJECT-FILE-EXTENSION+
(((SI:LOCATION DEFVAR C::+OBJECT-FILE-EXTENSION+) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 2662))
C::+OPTIMIZABLE-CONSTANTS+
(((SI:LOCATION DEFPARAMETER C::+OPTIMIZABLE-CONSTANTS+) #P"SRC:CMP;CMPCT.LSP.NEWEST" . 527))
C::+OPTIMIZATION-QUALITY-ORDERS+
(((SI:LOCATION DEFCONSTANT C::+OPTIMIZATION-QUALITY-ORDERS+) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 557))
C::+P1-DISPATCH-ALIST+
(((SI:LOCATION DEFCONSTANT C::+P1-DISPATCH-ALIST+) #P"SRC:CMP;CMPTABLES.LSP.NEWEST" . 5726))
C::+PROCLAMATIONS+
(((SI:LOCATION DEFPARAMETER C::+PROCLAMATIONS+) #P"SRC:CMP;PROCLAMATIONS.LSP.NEWEST" . 5756))
C::+REPRESENTATION-TYPE-HASH+
(((SI:LOCATION DEFPARAMETER C::+REPRESENTATION-TYPE-HASH+) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 4978))
C::+REPRESENTATION-TYPES+
(((SI:LOCATION DEFCONSTANT C::+REPRESENTATION-TYPES+) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 994))
C::+SET-LOC-DISPATCH-ALIST+
(((SI:LOCATION DEFCONSTANT C::+SET-LOC-DISPATCH-ALIST+) #P"SRC:CMP;CMPTABLES.LSP.NEWEST" . 3040))
C::+SHARED-LIBRARY-EXTENSION+
(((SI:LOCATION DEFVAR C::+SHARED-LIBRARY-EXTENSION+) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 2455))
C::+SHARED-LIBRARY-FORMAT+
(((SI:LOCATION DEFVAR C::+SHARED-LIBRARY-FORMAT+) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 2496))
C::+SHARED-LIBRARY-PREFIX+
(((SI:LOCATION DEFVAR C::+SHARED-LIBRARY-PREFIX+) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 2415))
CLOS::+SLOT-DEFINITION-SLOTS+
(((SI:LOCATION DEFCONSTANT CLOS::+SLOT-DEFINITION-SLOTS+) #P"SRC:CLOS;SLOT.LSP.NEWEST" . 1225))
CLOS::+STANDARD-CLASS-SLOTS+
(((SI:LOCATION DEFPARAMETER CLOS::+STANDARD-CLASS-SLOTS+) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 3190))
CLOS::+STANDARD-GENERIC-FUNCTION-SLOTS+
(((SI:LOCATION DEFPARAMETER CLOS::+STANDARD-GENERIC-FUNCTION-SLOTS+) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 3541))
CLOS::+STANDARD-METHOD-SLOTS+
(((SI:LOCATION DEFPARAMETER CLOS::+STANDARD-METHOD-SLOTS+) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 4762))
C::+STATIC-LIBRARY-EXTENSION+
(((SI:LOCATION DEFVAR C::+STATIC-LIBRARY-EXTENSION+) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 2579))
C::+STATIC-LIBRARY-FORMAT+
(((SI:LOCATION DEFVAR C::+STATIC-LIBRARY-FORMAT+) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 2619))
C::+STATIC-LIBRARY-PREFIX+
(((SI:LOCATION DEFVAR C::+STATIC-LIBRARY-PREFIX+) #P"BUILD:CMP;CMPDEFS.LSP.NEWEST" . 2540))
C::+T1-DISPATCH-ALIST+
(((SI:LOCATION DEFCONSTANT C::+T1-DISPATCH-ALIST+) #P"SRC:CMP;CMPTABLES.LSP.NEWEST" . 2741))
C::+T2-DISPATCH-ALIST+
(((SI:LOCATION DEFCONSTANT C::+T2-DISPATCH-ALIST+) #P"SRC:CMP;CMPTABLES.LSP.NEWEST" . 5497))
CLOS::+THE-CLASS+
(((SI:LOCATION DEFCONSTANT CLOS::+THE-CLASS+) #P"SRC:CLOS;BOOT.LSP.NEWEST" . 5698))
CLOS::+THE-FUNCALLABLE-STANDARD-CLASS+
(((SI:LOCATION DEFCONSTANT CLOS::+THE-FUNCALLABLE-STANDARD-CLASS+) #P"SRC:CLOS;BOOT.LSP.NEWEST" . 5875))
CLOS::+THE-STANDARD-CLASS+
(((SI:LOCATION DEFCONSTANT CLOS::+THE-STANDARD-CLASS+) #P"SRC:CLOS;BOOT.LSP.NEWEST" . 5807))
CLOS::+THE-STD-CLASS+
(((SI:LOCATION DEFCONSTANT CLOS::+THE-STD-CLASS+) #P"SRC:CLOS;BOOT.LSP.NEWEST" . 5749))
SI::+TRACING-BLOCK+
(((SI:LOCATION DEFCONSTANT SI::+TRACING-BLOCK+) #P"SRC:LSP;TRACE.LSP.NEWEST" . 600))
SI::+UPGRADED-ARRAY-ELEMENT-TYPES+
(((SI:LOCATION DEFCONSTANT SI::+UPGRADED-ARRAY-ELEMENT-TYPES+) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 12300))
CLOS::+VALID-DOCUMENTATION-TYPES+
(((SI:LOCATION DEFCONSTANT CLOS::+VALID-DOCUMENTATION-TYPES+) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 11558))
C::+WARN-FORMAT+
(((SI:LOCATION DEFCONSTANT C::+WARN-FORMAT+) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 610))
C::+WT-LOC-DISPATCH-ALIST+
(((SI:LOCATION DEFCONSTANT C::+WT-LOC-DISPATCH-ALIST+) #P"SRC:CMP;CMPTABLES.LSP.NEWEST" . 3289))
-
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER &REST MORE-NUMBERS)

Returns the first arg subtracted by the rest of args.  With one arg, returns
- NUMBER.
") ((:LAMBDA-LIST) NUMBER &REST SI::MORE-NUMBERS) ((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The top-level form ECL is currently evaluating.
") ((SI:LOCATION DEFINE-COMPILER-MACRO -) #P"SRC:CMP;CMPNUM.LSP.NEWEST" . 1886))
/
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER &REST MORE-NUMBERS)

Returns the first arg divided by the rest of args.  With one arg, returns
1/NUMBER.
") ((:LAMBDA-LIST) NUMBER &REST SI::MORE-NUMBERS) ((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The list of all values of the last top-level form.
") ((SI:LOCATION DEFINE-COMPILER-MACRO /) #P"SRC:CMP;CMPNUM.LSP.NEWEST" . 1799))
//
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The list of all values of the last-but-one top-level form.
"))
///
(((DOCUMENTATION . VARIABLE) . "Variable in COMMON-LISP package:
The list of all values of the last-but-two top-level form.
"))
/=
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER &REST MORE-NUMBERS)

Returns T if no two of the args are numerically equal; NIL otherwise.
") ((:LAMBDA-LIST) NUMBER &REST SI::MORE-NUMBERS))
1+
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER)

Returns NUMBER plus one.
") ((:LAMBDA-LIST) NUMBER))
1-
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER)

Returns NUMBER minus one.
") ((:LAMBDA-LIST) NUMBER))
<
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER &REST MORE-NUMBERS)

Returns T if the args are in increasing order; NIL otherwise.
") ((:LAMBDA-LIST) NUMBER &REST SI::MORE-NUMBERS))
<=
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER &REST MORE-NUMBERS)

Returns T if the args are in non-decreasing order; NIL otherwise.
") ((:LAMBDA-LIST) NUMBER &REST SI::MORE-NUMBERS))
=
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER &REST MORE-NUMBERS)

Returns T if all args are numerically equal; NIL otherwise.
") ((:LAMBDA-LIST) NUMBER &REST SI::MORE-NUMBERS))
>
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER &REST MORE-NUMBERS)

Returns T if the args are in decreasing order; NIL otherwise.
") ((:LAMBDA-LIST) NUMBER &REST SI::MORE-NUMBERS))
>=
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER &REST MORE-NUMBERS)

Returns T if the args are in non-increasing order; NIL otherwise.
") ((:LAMBDA-LIST) NUMBER &REST SI::MORE-NUMBERS))
ABORT
(((:LAMBDA-LIST) &OPTIONAL SI::C) ((SI:LOCATION DEFUN ABORT) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 24056))
SI::ABORT-FAILURE
(((SI:LOCATION DEFCLASS SI::ABORT-FAILURE) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
ABS
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER)

Returns the absolute value of NUMBER.
") ((:LAMBDA-LIST) NUMBER))
SI::ACCUMULATE-CASES
(((:LAMBDA-LIST) SI::MACRO-NAME SI::CASES SI::LIST-IS-ATOM-P) ((SI:LOCATION DEFUN SI::ACCUMULATE-CASES) #P"SRC:LSP;ASSERT.LSP.NEWEST" . 3394))
ACONS
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (KEY DATUM ALIST)

Equivalent to (CONS (CONS KEY DATUM) ALIST).
") ((:LAMBDA-LIST) SI::KEY SI::DATUM SI::ALIST))
ACOS
(((DOCUMENTATION . FUNCTION) . "Args: (number)
Returns the arc cosine of NUMBER.") ((:LAMBDA-LIST) SI::X) ((SI:LOCATION DEFUN ACOS) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 5896))
ACOSH
(((DOCUMENTATION . FUNCTION) . "Args: (number)
Returns the hyperbolic arc cosine of NUMBER.") ((:LAMBDA-LIST) SI::X) ((SI:LOCATION DEFUN ACOSH) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 7520))
CLOS::ADD-DEFAULT-INITARGS
(((:LAMBDA-LIST) CLASS CLOS::INITARGS) ((SI:LOCATION DEFUN CLOS::ADD-DEFAULT-INITARGS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 4713))
C::ADD-DEFAULT-OPTIMIZATIONS
(((:LAMBDA-LIST) C::ENV) ((SI:LOCATION DEFUN C::ADD-DEFAULT-OPTIMIZATIONS) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 3848))
CLOS:ADD-DEPENDENT
(((SI:LOCATION DEFMETHOD CLOS:ADD-DEPENDENT (CLOS::C CLASS) CLOS::DEP) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 10003) ((:LAMBDA-LIST) CLOS::C CLOS::D) ((SI:LOCATION DEFUN CLOS:ADD-DEPENDENT) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 8127))
CLOS:ADD-DIRECT-SUBCLASS
(((SI:LOCATION DEFMETHOD CLOS:ADD-DIRECT-SUBCLASS (CLOS::PARENT CLASS) CLOS::CHILD) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 8020))
SI::ADD-FILL-STYLE-NEWLINES
(((:LAMBDA-LIST) LIST STRING SI::OFFSET) ((SI:LOCATION DEFUN SI::ADD-FILL-STYLE-NEWLINES) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 88315))
SI::ADD-FILL-STYLE-NEWLINES-AUX
(((:LAMBDA-LIST) SI::LITERAL STRING SI::OFFSET) ((SI:LOCATION DEFUN SI::ADD-FILL-STYLE-NEWLINES-AUX) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 88771))
C::ADD-FORM-TO-NODE-LIST
(((:LAMBDA-LIST) C::FORM LIST) ((SI:LOCATION DEFUN C::ADD-FORM-TO-NODE-LIST) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 7494))
C::ADD-FUNCTION-DECLARATION
(((:LAMBDA-LIST) C::FNAME C::ARG-TYPES C::RETURN-TYPES &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::ADD-FUNCTION-DECLARATION) #P"SRC:CMP;CMPENV-FUN.LSP.NEWEST" . 2410))
C::ADD-KEYWORDS
(((:LAMBDA-LIST) C::KEYWORDS) ((SI:LOCATION DEFUN C::ADD-KEYWORDS) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 6692))
C::ADD-LOAD-FORM
(((:LAMBDA-LIST) FFI:OBJECT C::LOCATION) ((SI:LOCATION DEFUN C::ADD-LOAD-FORM) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 4592))
C::ADD-LOAD-TIME-VALUES
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::ADD-LOAD-TIME-VALUES) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 18382))
SI::ADD-LOOP-PATH
(((:LAMBDA-LIST) SI::NAMES FUNCTION SI::UNIVERSE &KEY SI::PREPOSITION-GROUPS SI::INCLUSIVE-PERMITTED SI::USER-DATA) ((SI:LOCATION DEFUN SI::ADD-LOOP-PATH) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 68577))
C::ADD-LOOP-REGISTERS
(((:LAMBDA-LIST) TAGBODY) ((SI:LOCATION DEFUN C::ADD-LOOP-REGISTERS) #P"SRC:CMP;CMPTAG.LSP.NEWEST" . 1277))
ADD-METHOD
(((:LAMBDA-LIST) CLOS::GF METHOD) ((SI:LOCATION DEFUN ADD-METHOD) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 5215))
CLOS::ADD-METHOD-KEYWORDS
(((:LAMBDA-LIST) METHOD) ((SI:LOCATION DEFUN CLOS::ADD-METHOD-KEYWORDS) #P"SRC:CLOS;METHOD.LSP.NEWEST" . 10114))
C::ADD-OBJECT
(((:LAMBDA-LIST) FFI:OBJECT &KEY (C::DUPLICATE NIL) (C::PERMANENT (OR (SYMBOLP FFI:OBJECT) C::*PERMANENT-DATA*))) ((SI:LOCATION DEFUN C::ADD-OBJECT) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 5141))
C::ADD-ONE-DECLARATION
(((:LAMBDA-LIST) C::ENV C::DECL) ((SI:LOCATION DEFUN C::ADD-ONE-DECLARATION) #P"SRC:CMP;CMPENV-DECLARE.LSP.NEWEST" . 4800))
C::ADD-REFERRED-VARIABLES-TO-FUNCTION
(((:LAMBDA-LIST) C::FUN C::VAR-LIST) ((SI:LOCATION DEFUN C::ADD-REFERRED-VARIABLES-TO-FUNCTION) #P"SRC:CMP;CMPLAM.LSP.NEWEST" . 2072))
C::ADD-STATIC-CONSTANT
(((:LAMBDA-LIST) FFI:OBJECT) ((SI:LOCATION DEFUN C::ADD-STATIC-CONSTANT) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 10671))
C::ADD-SYMBOL
(((:LAMBDA-LIST) SYMBOL) ((SI:LOCATION DEFUN C::ADD-SYMBOL) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 6613))
C::ADD-TO-READ-NODES
(((:LAMBDA-LIST) C::VAR C::FORM) ((SI:LOCATION DEFUN C::ADD-TO-READ-NODES) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 3352))
C::ADD-TO-SET-NODES
(((:LAMBDA-LIST) C::VAR C::FORM) ((SI:LOCATION DEFUN C::ADD-TO-SET-NODES) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 3777))
C::ADD-TO-SET-NODES-OF-VAR-LIST
(((:LAMBDA-LIST) C::VAR-LIST C::FORM) ((SI:LOCATION DEFUN C::ADD-TO-SET-NODES-OF-VAR-LIST) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 4236))
ADJOIN
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ITEM LIST &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT)

Returns cons of ITEM and LIST unless ITEM is already an element of LIST.
Otherwise, returns LIST.
") ((:LAMBDA-LIST) SI::ITEM LIST &KEY (SI::KEY '#'IDENTITY) (SI::TEST '#'EQL) SI::TEST-NOT))
ADJUST-ARRAY
(((DOCUMENTATION . FUNCTION) . "Args: (array dimensions
       &key (element-type (array-element-type array))
            initial-element (initial-contents nil) (fill-pointer nil)
            (displaced-to nil) (displaced-index-offset 0))
Adjusts the dimensions of ARRAY to the given DIMENSIONS.  ARRAY must be an
adjustable array.") ((:LAMBDA-LIST) ARRAY SI::NEW-DIMENSIONS &REST SI::R &KEY (SI::ELEMENT-TYPE (ARRAY-ELEMENT-TYPE ARRAY)) SI::INITIAL-ELEMENT SI::INITIAL-CONTENTS FILL-POINTER SI::DISPLACED-TO SI::DISPLACED-INDEX-OFFSET) ((SI:LOCATION DEFUN ADJUST-ARRAY) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 14788))
ADJUSTABLE-ARRAY-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ARRAY)

Returns T if ARRAY is adjustable; NIL otherwise.
") ((:LAMBDA-LIST) ARRAY))
C::ALIEN-DECLARATION-P
(((:LAMBDA-LIST) C::NAME &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::ALIEN-DECLARATION-P) #P"SRC:CMP;CMPENV-DECLARE.LSP.NEWEST" . 1433))
SI:ALL-ENCODINGS
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI:ALL-ENCODINGS) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 11496))
CLOS::ALL-KEYWORDS
(((:LAMBDA-LIST) CLOS::L) ((SI:LOCATION DEFUN CLOS::ALL-KEYWORDS) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 4379))
FFI:ALLOCATE-FOREIGN-OBJECT
(((:LAMBDA-LIST) TYPE &OPTIONAL (FFI::SIZE 0 FFI::SIZE-FLAG)) ((SI:LOCATION DEFUN FFI:ALLOCATE-FOREIGN-OBJECT) #P"SRC:LSP;FFI.LSP.NEWEST" . 4781))
FFI:ALLOCATE-FOREIGN-STRING
(((:LAMBDA-LIST) FFI::SIZE &KEY FFI::UNSIGNED) ((SI:LOCATION DEFUN FFI:ALLOCATE-FOREIGN-STRING) #P"SRC:LSP;FFI.LSP.NEWEST" . 15017))
SI::ALLOCATE-GFUN
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (NAME ARITY HASH-TABLE)

ECL/CLOS specific.
Allocates a gfun object in which NAME is the generic function name, ARITY
is the number of arguments and HASH-TABLE is the hashtable for cashing
methods.
") ((:LAMBDA-LIST) SI::NAME SI::ARITY HASH-TABLE))
ALLOCATE-INSTANCE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CLASS LENGTH)

ECL/CLOS specific.
Allocates an istance of CLASS with LENGTH slots.
") ((:LAMBDA-LIST) CLASS LENGTH) ((SI:LOCATION DEFMETHOD ALLOCATE-INSTANCE (CLASS CLASS) &REST CLOS::INITARGS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 3583))
ALPHA-CHAR-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR)

Returns T if CHAR is alphabetic; NIL otherwise.
") ((:LAMBDA-LIST) CHAR))
ALPHANUMERICP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR)

Returns T if CHAR is either numeric or alphabetic; NIL otherwise.
") ((:LAMBDA-LIST) CHAR))
AND
(((DOCUMENTATION . FUNCTION) . "Macro in COMMON-LISP package:
Syntax: (and {form}*)

Evaluates FORMs in order.  If any FORM evaluates to NIL, returns
immediately with the value NIL.  Otherwise, returns all values of the
last FORM.
") ((:LAMBDA-LIST) . "(and {form}*)"))
C::AND!
(((:LAMBDA-LIST) &BODY C::BODY) ((SI:LOCATION DEFMACRO C::AND!) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 10990))
C::AND-FORM-TYPE
(((:LAMBDA-LIST) TYPE C::FORM C::ORIGINAL-FORM &OPTIONAL (C::MODE :SAFE) (C::FORMAT-STRING "") &REST C::FORMAT-ARGS) ((SI:LOCATION DEFUN C::AND-FORM-TYPE) #P"SRC:CMP;CMPTYPE.LSP.NEWEST" . 681))
APPEND
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&REST LISTS)

Constructs and returns a new list by concatenating the args.
") ((:LAMBDA-LIST) &REST SI::LISTS))
APPLY
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FUNCTION ARG &REST MORE-ARGS)

Calls FUNCTION with all ARGs except the last and all elements of the last ARG
as the arguments to FUNCTION.  Returns all values that FUNCTION returns.
") ((:LAMBDA-LIST) FUNCTION SI::ARG &REST SI::MORE-ARGS))
C::APPLY-INLINE-INFO
(((:LAMBDA-LIST) C::II C::INLINED-LOCS) ((SI:LOCATION DEFUN C::APPLY-INLINE-INFO) #P"SRC:CMP;CMPC-INLINER.LSP.NEWEST" . 2003))
C::APPLY-INLINER
(((:LAMBDA-LIST) C::FNAME C::RETURN-TYPE C::INLINED-ARGS) ((SI:LOCATION DEFUN C::APPLY-INLINER) #P"SRC:CMP;CMPC-INLINER.LSP.NEWEST" . 927))
SI::APPLYHOOK
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (FUNCTION LIST EVALHOOKFN APPLYHOOKFN &OPTIONAL (ENV NIL))

Calls FUNCTION with all elements of LIST as the arguments and with *EVALHOOK*
and *APPLYHOOK* bound to EVALHOOKFN and APPLYHOOKFN respectively.  Returns all
values that FUNCTION returns.
") ((:LAMBDA-LIST) FUNCTION LIST SI::EVALHOOKFN SI::APPLYHOOKFN &OPTIONAL (SI::ENV NIL)))
APROPOS
(((DOCUMENTATION . FUNCTION) . "Args: (string &optional (package nil))
Prints those symbols whose print-names contain STRING as substring.  If
PACKAGE is non-NIL, then only the specified PACKAGE is searched.") ((:LAMBDA-LIST) STRING &OPTIONAL PACKAGE) ((SI:LOCATION DEFUN APROPOS) #P"SRC:LSP;PACKLIB.LSP.NEWEST" . 5672))
APROPOS-LIST
(((DOCUMENTATION . FUNCTION) . "Args: (string &optional (package nil))
Returns a list of all symbols whose print-names contain STRING as substring.
If PACKAGE is non-NIL, then only the specified PACKAGE is searched.") ((:LAMBDA-LIST) STRING &OPTIONAL PACKAGE) ((SI:LOCATION DEFUN APROPOS-LIST) #P"SRC:LSP;PACKLIB.LSP.NEWEST" . 6002))
AREF
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ARRAY &REST INDEXES)

Returns the element of ARRAY specified by INDEXES.
") ((:LAMBDA-LIST) ARRAY &REST SI::INDEXES) ((SI:LOCATION DEFINE-COMPILER-MACRO AREF) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 5160))
SI:ARGC
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: NIL

ECL specific.
Returns the number of arguments given in the command line that invoked ECL.
") ((:LAMBDA-LIST)))
C::ARGS-CAUSE-SIDE-EFFECT
(((:LAMBDA-LIST) C::FORMS) ((SI:LOCATION DEFUN C::ARGS-CAUSE-SIDE-EFFECT) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 6713))
SI:ARGV
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (N)

ECL specific.
Returns the N-th argument given in the command line that invoked ECL.
") ((:LAMBDA-LIST) SI::N))
ARITHMETIC-ERROR
(((SI:LOCATION DEFCLASS ARITHMETIC-ERROR) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
C::ARITHMETIC-PROPAGATOR
(((:LAMBDA-LIST) C::OP1-TYPE C::OTHERS C::INTEGER-RESULT) ((SI:LOCATION DEFUN C::ARITHMETIC-PROPAGATOR) #P"SRC:CMP;CMPNUM.LSP.NEWEST" . 3659))
ARRAY
(((DOCUMENTATION . TYPE) . "
An array is a compound object whose elements are referenced by indexing.  One-
dimensional arrays are called vectors.  Other arrays are notated as
	#?a( ... )	or	#?A( ... )
where '?' is actually the rank of the array.
Arrays may be displaced to another array, may have a fill-pointer, or may be
adjustable.  Other arrays are called simple-arrays.  Only simple-arrays can be
input in the above format."))
ARRAY-DIMENSION
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ARRAY N)

Returns the length of the N-th dimension of ARRAY.
") ((:LAMBDA-LIST) ARRAY SI::N))
C::ARRAY-DIMENSION-ACCESSOR
(((:LAMBDA-LIST) ARRAY C::N) ((SI:LOCATION DEFUN C::ARRAY-DIMENSION-ACCESSOR) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 9889))
C::ARRAY-DIMENSION-FAST
(((:LAMBDA-LIST) ARRAY C::N) ((SI:LOCATION DEFMACRO C::ARRAY-DIMENSION-FAST) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 10268))
ARRAY-DIMENSION-LIMIT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The upper bound of the length of an array dimension.
"))
ARRAY-DIMENSIONS
(((DOCUMENTATION . FUNCTION) . "Args: (array)
Returns a list whose N-th element is the length of the N-th dimension of ARRAY.") ((:LAMBDA-LIST) ARRAY) ((SI:LOCATION DEFUN ARRAY-DIMENSIONS) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 4138))
ARRAY-ELEMENT-TYPE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ARRAY)

Returns the element type ARRAY.
") ((:LAMBDA-LIST) ARRAY))
ARRAY-HAS-FILL-POINTER-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ARRAY)

Returns T if ARRAY has a fill-pointer; NIL otherwise.
") ((:LAMBDA-LIST) ARRAY))
ARRAY-IN-BOUNDS-P
(((DOCUMENTATION . FUNCTION) . "Args: (array &rest indexes)
Returns T if INDEXes are valid indexes of ARRAY; NIL otherwise.  The number of
INDEXes must be equal to the rank of ARRAY.") ((:LAMBDA-LIST) ARRAY &REST SI::INDICES &AUX (SI::R (ARRAY-RANK ARRAY))) ((SI:LOCATION DEFUN ARRAY-IN-BOUNDS-P) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 4428))
ARRAY-RANK
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ARRAY)

Returns the rank of ARRAY.
") ((:LAMBDA-LIST) ARRAY))
ARRAY-RANK-LIMIT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The upper bound of the rank of an array.
"))
ARRAY-ROW-MAJOR-INDEX
(((SI:LOCATION DEFINE-COMPILER-MACRO ARRAY-ROW-MAJOR-INDEX) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 6308) ((DOCUMENTATION . FUNCTION) . "Args: (array &rest indexes)
Returns the non-negative integer that represents the location of the element
of ARRAY specified by INDEXes, assuming all elements of ARRAY are aligned in
row-major order.") ((:LAMBDA-LIST) ARRAY &REST SI::INDICES) ((SI:LOCATION DEFUN ARRAY-ROW-MAJOR-INDEX) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 5951))
ARRAY-TOTAL-SIZE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ARRAY)

Returns the total number of elements of ARRAY.
") ((:LAMBDA-LIST) ARRAY))
ARRAY-TOTAL-SIZE-LIMIT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The upper bound of the total number of elements of an array.
"))
SI::ARRAY-TYPE-<=
(((:LAMBDA-LIST) SI::T1 SI::T2) ((SI:LOCATION DEFUN SI::ARRAY-TYPE-<=) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 34800))
SI::ARRAY-TYPE-P
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN SI::ARRAY-TYPE-P) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 35229))
ARRAYP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is an array; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
SI:ASET
(((SI:LOCATION DEFINE-COMPILER-MACRO SI:ASET) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 5606))
ASH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (INTEGER COUNT)

Returns the integer obtained by shifting the bits that represent INTEGER as
specified by COUNT.  Shifts left in COUNT bits if COUNT is positive.  Shifts
right in -COUNT bits if COUNT is negative.
") ((:LAMBDA-LIST) INTEGER COUNT))
ASIN
(((DOCUMENTATION . FUNCTION) . "Args: (number)
Returns the arc sine of NUMBER.") ((:LAMBDA-LIST) SI::X) ((SI:LOCATION DEFUN ASIN) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 5288))
ASINH
(((DOCUMENTATION . FUNCTION) . "Args: (number)
Returns the hyperbolic arc sine of NUMBER.") ((:LAMBDA-LIST) SI::X) ((SI:LOCATION DEFUN ASINH) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 7115))
ASSERT
(((DOCUMENTATION . FUNCTION) . "Args: (assert form [({place}*) [string {arg}*]])
Evaluates FORM and signals a continuable error if the value is NIL.  Before
continuing, receives new values of PLACEs from user.  Repeats this process
until FORM returns a non-NIL value.  Returns NIL.  STRING is the format string
for the error message and ARGs are arguments to the format string.") ((:LAMBDA-LIST) SI::TEST-FORM &OPTIONAL SI::PLACES &REST SI::ARGUMENTS) ((SI:LOCATION DEFMACRO ASSERT) #P"SRC:LSP;ASSERT.LSP.NEWEST" . 2588))
SI:ASSERT-FAILURE
(((:LAMBDA-LIST) SI::TEST-FORM &OPTIONAL SI::PLACE-NAMES VALUES &REST SI::ARGUMENTS) ((SI:LOCATION DEFUN SI:ASSERT-FAILURE) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 25333))
SI::ASSERT-PROMPT
(((:LAMBDA-LIST) SI::NAME SI::VALUE) ((SI:LOCATION DEFUN SI::ASSERT-PROMPT) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 24888))
SI::ASSERT-REPORT
(((:LAMBDA-LIST) SI::NAMES STREAM) ((SI:LOCATION DEFUN SI::ASSERT-REPORT) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 24663))
C::ASSERT-TYPE-IF-KNOWN
(((:LAMBDA-LIST) &WHOLE C::WHOLE C::VALUE TYPE &ENVIRONMENT C::ENV) ((SI:LOCATION DEFMACRO C::ASSERT-TYPE-IF-KNOWN) #P"SRC:CMP;CMPTYPE.LSP.NEWEST" . 6699))
C::ASSERT-VAR-NOT-IGNORED
(((:LAMBDA-LIST) C::VAR) ((SI:LOCATION DEFUN C::ASSERT-VAR-NOT-IGNORED) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 2936))
C::ASSERT-VAR-REF-VALUE
(((:LAMBDA-LIST) C::VAR) ((SI:LOCATION DEFUN C::ASSERT-VAR-REF-VALUE) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 2602))
ASSOC
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ITEM ALIST &KEY (TEST '#'EQL) TEST-NOT (KEY '#'IDENTITY))

Returns the first pair in ALIST whose car is equal (in the sense of TEST) to
ITEM.  Returns NIL if no such pair exists.
The function KEY is applied to extract the key for comparison.
") ((:LAMBDA-LIST) SI::ITEM SI::ALIST &KEY (SI::TEST '#'EQL) SI::TEST-NOT (SI::KEY '#'IDENTITY)) ((SI:LOCATION DEFINE-COMPILER-MACRO ASSOC) #P"SRC:CMP;CMPOPT-SEQUENCE.LSP.NEWEST" . 10418))
ASSOC-IF
(((DOCUMENTATION . FUNCTION) . "Returns the first pair in ALIST whose car satisfies TEST.  Returns NIL if no
such pair exists.") ((:LAMBDA-LIST) SI::TEST SI::ALIST &KEY SI::KEY) ((SI:LOCATION DEFUN ASSOC-IF) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 4744))
ASSOC-IF-NOT
(((DOCUMENTATION . FUNCTION) . "Returns the first pair in ALIST whose car does not satisfy TEST.  Returns NIL
if no such pair exists.") ((:LAMBDA-LIST) SI::TEST SI::ALIST &KEY SI::KEY) ((SI:LOCATION DEFUN ASSOC-IF-NOT) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 4929))
CLOS::ASSOCIATE-METHODS-TO-GFUN
(((:LAMBDA-LIST) CLOS::GFUN &REST CLOS::METHODS) ((SI:LOCATION DEFUN CLOS::ASSOCIATE-METHODS-TO-GFUN) #P"SRC:CLOS;GENERIC.LSP.NEWEST" . 6897))
SI::ASSURE-SPACE-IN-BUFFER
(((:LAMBDA-LIST) STREAM SI::WANT) ((SI:LOCATION DEFUN SI::ASSURE-SPACE-IN-BUFFER) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 17408))
ATAN
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X &OPTIONAL (Y 1))

Returns the arc tangent of X/Y.
") ((:LAMBDA-LIST) SI::X &OPTIONAL (SI::Y 1)))
ATANH
(((DOCUMENTATION . FUNCTION) . "Args: (number)
Returns the hyperbolic arc tangent of NUMBER.") ((:LAMBDA-LIST) SI::X) ((SI:LOCATION DEFUN ATANH) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 8165))
ATOM
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is not a cons; NIL otherwise.
") ((:LAMBDA-LIST) SI::X) ((DOCUMENTATION . TYPE) . "An ATOM is an object that is not a CONS."))
C::AUGMENT-POLICY
(((:LAMBDA-LIST) C::QUALITY C::LEVEL C::ON-OFF C::FLAG) ((SI:LOCATION DEFUN C::AUGMENT-POLICY) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 4555))
SI::AUTOLOAD
(((:LAMBDA-LIST) PATHNAME &REST SI::FUNCTION-NAMES) ((SI:LOCATION DEFUN SI::AUTOLOAD) #P"SRC:LSP;AUTOLOAD.LSP.NEWEST" . 684))
C::BABOON
(((:LAMBDA-LIST) &KEY (C::FORMAT-CONTROL "A bug was found in the compiler") C::FORMAT-ARGUMENTS) ((SI:LOCATION DEFUN C::BABOON) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 10598))
C::BABOON-IMPROPER-*EXIT*
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::BABOON-IMPROPER-*EXIT*) #P"SRC:CMP;CMPEXIT.LSP.NEWEST" . 4698))
C::BABOON-UNWIND-EXIT
(((:LAMBDA-LIST) C::UE) ((SI:LOCATION DEFUN C::BABOON-UNWIND-EXIT) #P"SRC:CMP;CMPEXIT.LSP.NEWEST" . 4877))
BASE-STRING
(((DOCUMENTATION . TYPE) . "A string which is made of BASE-CHAR."))
C::BDS-BIND
(((:LAMBDA-LIST) C::LOC C::VAR) ((SI:LOCATION DEFUN C::BDS-BIND) #P"SRC:CMP;CMPBIND.LSP.NEWEST" . 2867))
SI:BDS-VAL
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (N)

ECL specific.
Returns the value of the N-th entity in the bind stack.
") ((:LAMBDA-LIST) SI::N))
SI:BDS-VAR
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (N)

ECL specific.
Returns the symbol of the N-th entity in the bind stack.
") ((:LAMBDA-LIST) SI::N))
BIGNUM
(((DOCUMENTATION . TYPE) . "
A bignum is an integer that is not a fixnum."))
C::BIND
(((:LAMBDA-LIST) C::LOC C::VAR) ((SI:LOCATION DEFUN C::BIND) #P"SRC:CMP;CMPBIND.LSP.NEWEST" . 727))
C::BIND-INIT
(((:LAMBDA-LIST) C::FORM C::VAR) ((SI:LOCATION DEFUN C::BIND-INIT) #P"SRC:CMP;CMPBIND.LSP.NEWEST" . 2181))
BIT
(((DOCUMENTATION . FUNCTION) . "Args: (bit-array &rest indexes)
Returns the bit of BIT-ARRAY specified by INDEXes.") ((:LAMBDA-LIST) SI::BIT-ARRAY &REST SI::INDICES) ((SI:LOCATION DEFUN BIT) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 6311) ((DOCUMENTATION . TYPE) . "A BIT is either integer 0 or 1."))
BIT-AND
(((DOCUMENTATION . FUNCTION) . "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise AND of BIT-ARRAY1 and BIT-ARRAY2.  Puts the results
into a new bit-array if RESULT is NIL, into BIT-ARRAY1 if RESULT is T, or into
RESULT if RESULT is a bit-array.") ((:LAMBDA-LIST) SI::BIT-ARRAY1 SI::BIT-ARRAY2 &OPTIONAL SI::RESULT-BIT-ARRAY) ((SI:LOCATION DEFUN BIT-AND) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 6928))
BIT-ANDC1
(((DOCUMENTATION . FUNCTION) . "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise AND of {the element-wise NOT of BIT-ARRAY1} and BIT-
ARRAY2.  Puts the results into a new bit-array if RESULT is NIL, into BIT-
ARRAY1 if RESULT is T, or into RESULT if RESULT is a bit-array.") ((:LAMBDA-LIST) SI::BIT-ARRAY1 SI::BIT-ARRAY2 &OPTIONAL SI::RESULT-BIT-ARRAY) ((SI:LOCATION DEFUN BIT-ANDC1) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 9313))
BIT-ANDC2
(((DOCUMENTATION . FUNCTION) . "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise AND of BIT-ARRAY1 and {the element-wise NOT of BIT-
ARRAY2}.  Puts the results into a new bit-array if RESULT is NIL, into BIT-
ARRAY1 if RESULT is T, or into RESULT if RESULT is a bit-array.") ((:LAMBDA-LIST) SI::BIT-ARRAY1 SI::BIT-ARRAY2 &OPTIONAL SI::RESULT-BIT-ARRAY) ((SI:LOCATION DEFUN BIT-ANDC2) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 9730))
BIT-EQV
(((DOCUMENTATION . FUNCTION) . "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise EQUIVALENCE of BIT-ARRAY1 and BIT-ARRAY2.  Puts the
results into a new bit-array if RESULT is NIL, into BIT-ARRAY1 if RESULT is T,
or into RESULT if RESULT is a bit-array.") ((:LAMBDA-LIST) SI::BIT-ARRAY1 SI::BIT-ARRAY2 &OPTIONAL SI::RESULT-BIT-ARRAY) ((SI:LOCATION DEFUN BIT-EQV) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 8089))
BIT-IOR
(((DOCUMENTATION . FUNCTION) . "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise INCLUSIVE OR of BIT-ARRAY1 and BIT-ARRAY2.  Puts the
results into a new bit-array if RESULT is NIL, into BIT-ARRAY1 if RESULT is T,
or into RESULT if RESULT is a bit-array.") ((:LAMBDA-LIST) SI::BIT-ARRAY1 SI::BIT-ARRAY2 &OPTIONAL SI::RESULT-BIT-ARRAY) ((SI:LOCATION DEFUN BIT-IOR) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 7309))
BIT-NAND
(((DOCUMENTATION . FUNCTION) . "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise NOT of {the element-wise AND of BIT-ARRAY1 and BIT-
ARRAY2}.  Puts the results into a new bit-array if RESULT is NIL, into BIT-
ARRAY1 if RESULT is T, or into RESULT if RESULT is a bit-array.") ((:LAMBDA-LIST) SI::BIT-ARRAY1 SI::BIT-ARRAY2 &OPTIONAL SI::RESULT-BIT-ARRAY) ((SI:LOCATION DEFUN BIT-NAND) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 8478))
BIT-NOR
(((DOCUMENTATION . FUNCTION) . "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise NOT of {the element-wise INCLUSIVE OR of BIT-ARRAY1
and BIT-ARRAY2}.  Puts the results into a new bit-array if RESULT is NIL, into
BIT-ARRAY1 if RESULT is T, or into RESULT if RESULT is a bit-array.") ((:LAMBDA-LIST) SI::BIT-ARRAY1 SI::BIT-ARRAY2 &OPTIONAL SI::RESULT-BIT-ARRAY) ((SI:LOCATION DEFUN BIT-NOR) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 8893))
BIT-NOT
(((DOCUMENTATION . FUNCTION) . "Args: (bit-array &optional (result nil))
Returns the element-wise NOT of BIT-ARRAY.  Puts the results into a new bit-
array if RESULT is NIL, into BIT-ARRAY if RESULT is T, or into RESULT if
RESULT is a bit-array.") ((:LAMBDA-LIST) SI::BIT-ARRAY &OPTIONAL SI::RESULT-BIT-ARRAY) ((SI:LOCATION DEFUN BIT-NOT) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 10991))
BIT-ORC1
(((DOCUMENTATION . FUNCTION) . "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise INCLUSIVE OR of {the element-wise NOT of BIT-ARRAY1}
and BIT-ARRAY2.  Puts the results into a new bit-array if RESULT is NIL, into
BIT-ARRAY1 if RESULT is T, or into RESULT if RESULT is a bit-array.") ((:LAMBDA-LIST) SI::BIT-ARRAY1 SI::BIT-ARRAY2 &OPTIONAL SI::RESULT-BIT-ARRAY) ((SI:LOCATION DEFUN BIT-ORC1) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 10147))
BIT-ORC2
(((DOCUMENTATION . FUNCTION) . "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise INCLUSIVE OR of BIT-ARRAY1 and {the element-wise NOT
of BIT-ARRAY2}.  Puts the results into a new bit-array if RESULT is NIL, into
BIT-ARRAY1 if RESULT is T, or into RESULT if RESULT is a bit-array.") ((:LAMBDA-LIST) SI::BIT-ARRAY1 SI::BIT-ARRAY2 &OPTIONAL SI::RESULT-BIT-ARRAY) ((SI:LOCATION DEFUN BIT-ORC2) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 10569))
BIT-VECTOR
(((DOCUMENTATION . TYPE) . "A bit-vector is a vector of bits.  A bit-vector is notated by '#*' followed
by its elements (0 or 1).  Bit-vectors may be displaced to another array, may
have a fill-pointer, or may be adjustable.  Other bit-vectors are called
simple-bit-vectors.  Only simple-bit-vectors can be input in the above format
using '#*'."))
BIT-VECTOR-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a bit-vector; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
BIT-XOR
(((DOCUMENTATION . FUNCTION) . "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise EXCLUSIVE OR of BIT-ARRAY1 and BIT-ARRAY2.  Puts the
results into a new bit-array if RESULT is NIL, into BIT-ARRAY1 if RESULT is T,
or into RESULT if RESULT is a bit-array.") ((:LAMBDA-LIST) SI::BIT-ARRAY1 SI::BIT-ARRAY2 &OPTIONAL SI::RESULT-BIT-ARRAY) ((SI:LOCATION DEFUN BIT-XOR) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 7699))
C::BLK
(((SI:LOCATION DEFCLASS C::BLK) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 7652))
BLOCK
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (block name {form}*)

Establishes a block named by NAME, evaluates FORMs in order, and returns all
values of the last FORM.  Returns NIL if no FORMs are given.
The scope of the established block is the body (i.e. the FORMs) of the BLOCK
form.  If (return-from name value-form) is evaluated within the scope, the
execution of the BLOCK form terminates immediately and all values of
VALUE-FORM will be returned as the values of the terminated BLOCK form.
") ((:LAMBDA-LIST) . "(block name {form}*)"))
SI::BLOCK-END
(((SI:LOCATION DEFCLASS SI::BLOCK-END) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 13280))
SI::BLOCK-START
(((SI:LOCATION DEFCLASS SI::BLOCK-START) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 12465))
BOOLE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (OP INTEGER1 INTEGER2)

Returns the integer produced by the logical operation specified by OP on the
two integers.  OP must be the value of one of the following constants.
	BOOLE-CLR	BOOLE-C1	BOOLE-XOR	BOOLE-ANDC1
	BOOLE-SET	BOOLE-C2	BOOLE-EQV	BOOLE-ANDC2
	BOOLE-1		BOOLE-AND	BOOLE-NAND	BOOLE-ORC1
	BOOLE-2		BOOLE-IOR	BOOLE-NOR	BOOLE-ORC2
Each logical operation on integers produces an integer represented by the bit
sequence obtained by a bit-wise logical operation on the bit sequences that
represent the integers.  Two's-complement representation is assumed to obtain
the bit sequence that represents an integer.  For example,
	 2:  ...010
	 1:  ...001
	 0:  ...000
	-1:  ...111
	-2:  ...110
where each '...' represents either an infinite sequence of 0's (for non-
negative integers) or an infinite sequence of 1's (for negative integers).
") ((:LAMBDA-LIST) SI::OP SI::INTEGER1 SI::INTEGER2) ((SI:LOCATION DEFINE-COMPILER-MACRO BOOLE) #P"SRC:CMP;CMPFUN.LSP.NEWEST" . 3642))
BOOLE-1
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Makes BOOLE return INTEGER1.
"))
BOOLE-2
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Makes BOOLE return INTEGER2.
"))
BOOLE-AND
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Makes BOOLE return the AND of INTEGER1 and INTEGER2.
"))
BOOLE-ANDC1
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Makes BOOLE return the AND of {the NOT of INTEGER1} and INTEGER2.
"))
BOOLE-ANDC2
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Makes BOOLE return the AND of INTEGER1 and {the NOT of INTEGER2}.
"))
BOOLE-C1
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Makes BOOLE return the NOT of INTEGER1.
"))
BOOLE-C2
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Makes BOOLE return the NOT of INTEGER2.
"))
BOOLE-CLR
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Makes BOOLE return 0.
"))
BOOLE-EQV
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Makes BOOLE return the EQUIVALENCE of INTEGER1 and INTEGER2.
"))
BOOLE-IOR
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Makes BOOLE return the INCLUSIVE OR of INTEGER1 and INTEGER2.
"))
BOOLE-NAND
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Makes BOOLE return the NOT of {the AND of INTEGER1 and INTEGER2}.
"))
BOOLE-NOR
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Makes BOOLE return the NOT of {the INCLUSIVE OR of INTEGER1 and INTEGER2}.
"))
BOOLE-ORC1
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Makes BOOLE return the INCLUSIVE OR of {the NOT of INTEGER1} and INTEGER2.
"))
BOOLE-ORC2
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Makes BOOLE return the INCLUSIVE OR of INTEGER1 and {the NOT of INTEGER2}.
"))
BOOLE-SET
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Makes BOOLE return -1.
"))
BOOLE-XOR
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Makes BOOLE return the EXCLUSIVE OR of INTEGER1 and INTEGER2.
"))
BOOLEAN
(((DOCUMENTATION . TYPE) . "A BOOLEAN is an object which is either NIL or T."))
BOTH-CASE-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR)

Returns T if CHAR is an alphabetic character; NIL otherwise.  Equivalent to
ALPHA-CHAR-P.
") ((:LAMBDA-LIST) CHAR))
BOUNDP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL)

Returns T if the global variable named SYMBOL has a value; NIL otherwise.
") ((:LAMBDA-LIST) SYMBOL))
SI::BOUNDS-<
(((:LAMBDA-LIST) SI::B1 SI::B2) ((SI:LOCATION DEFUN SI::BOUNDS-<) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 37774))
SI::BOUNDS-<=
(((:LAMBDA-LIST) SI::B1 SI::B2) ((SI:LOCATION DEFUN SI::BOUNDS-<=) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 37565))
BREAK
(((DOCUMENTATION . FUNCTION) . "Enters a break loop.  The execution of the program can be resumed by typing
:CONTINUE at the break loop.  Type :HELP to see the break-loop commands list.
If FORMAT-STRING is non-NIL, it is used as the format string to be output to
*ERROR-OUTPUT* before entering the break loop.  ARGs are arguments to the
format string.") ((:LAMBDA-LIST) &OPTIONAL (SI::FORMAT-CONTROL "Break") &REST SI::FORMAT-ARGUMENTS) ((SI:LOCATION DEFUN BREAK) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 13301))
SI::BREAK-COMMANDS
(((SI:LOCATION DEFCONSTANT SI::BREAK-COMMANDS) #P"SRC:LSP;TOP.LSP.NEWEST" . 6479))
SI::BREAK-WHERE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::BREAK-WHERE) #P"SRC:LSP;TOP.LSP.NEWEST" . 39652))
C::BRIEF-NAMESTRING
(((:LAMBDA-LIST) C::PATH) ((SI:LOCATION DEFUN C::BRIEF-NAMESTRING) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 1163))
GRAY::BUG-OR-ERROR
(((:LAMBDA-LIST) STREAM GRAY::FUN) ((SI:LOCATION DEFUN GRAY::BUG-OR-ERROR) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 10534))
C::BUILD-DEBUG-LEXICAL-ENV
(((:LAMBDA-LIST) C::VAR-LOCATIONS &OPTIONAL FIRST) ((SI:LOCATION DEFUN C::BUILD-DEBUG-LEXICAL-ENV) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 21630))
SI::BUILD-FAKE-ASDF
(((:LAMBDA-LIST) SI::NAME &OPTIONAL (SI::FILENAME (STRING SI::NAME))) ((SI:LOCATION DEFUN SI::BUILD-FAKE-ASDF) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/build/bare.lsp" . 5095))
SI::BUILD-FAKE-MODULE
(((:LAMBDA-LIST) SI::NAME SI::LISP-FILES) ((SI:LOCATION DEFUN SI::BUILD-FAKE-MODULE) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/build/bare.lsp" . 4290))
C:BUILD-FASL
(((:LAMBDA-LIST) &REST C::ARGS) ((SI:LOCATION DEFUN C:BUILD-FASL) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 16967))
SI::BUILD-MODULE
(((:LAMBDA-LIST) SI::NAME SI::SOURCES &KEY SI::ADDITIONAL-FILES (SI::BUILTIN NIL) (SI::DIR "build:") ((:PREFIX SI:*INIT-FUNCTION-PREFIX*) "EXT")) ((SI:LOCATION DEFUN SI::BUILD-MODULE) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/build/bare.lsp" . 5573))
C:BUILD-PROGRAM
(((:LAMBDA-LIST) &REST C::ARGS) ((SI:LOCATION DEFUN C:BUILD-PROGRAM) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 17031))
C:BUILD-SHARED-LIBRARY
(((:LAMBDA-LIST) &REST C::ARGS) ((SI:LOCATION DEFUN C:BUILD-SHARED-LIBRARY) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 17185))
C:BUILD-STATIC-LIBRARY
(((:LAMBDA-LIST) &REST C::ARGS) ((SI:LOCATION DEFUN C:BUILD-STATIC-LIBRARY) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 17101))
C::BUILDER
(((:LAMBDA-LIST) C::TARGET C::OUTPUT-NAME &KEY C::LISP-FILES C::LD-FLAGS C::SHARED-DATA-FILE (C::INIT-NAME NIL) (C::PROLOGUE-CODE "") (C::EPILOGUE-CODE (WHEN (EQ C::TARGET :PROGRAM) '(SI:TOP-LEVEL))) &AUX (C:*SUPPRESS-COMPILER-MESSAGES* (OR C:*SUPPRESS-COMPILER-MESSAGES* (NOT *COMPILE-VERBOSE*)))) ((SI:LOCATION DEFUN C::BUILDER) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 11153))
C::BUNDLE-CC
(((:LAMBDA-LIST) C::O-PATHNAME C::INIT-NAME C::OBJECT-FILES) ((SI:LOCATION DEFUN C::BUNDLE-CC) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 6283))
BUTLAST
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (LIST &OPTIONAL (N 1))

Returns a copy of LIST with the last N elements removed.
") ((:LAMBDA-LIST) LIST &OPTIONAL (SI::N 1)))
SI::BY
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: NIL

ECL specific.
Exits from ECL.  Equivalent to BYE.
") ((:LAMBDA-LIST)))
SI::BYE
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: NIL

ECL specific.
Exits from ECL.  Equivalent to BY.
") ((:LAMBDA-LIST)))
BYTE
(((DOCUMENTATION . FUNCTION) . "Args: (size position)
Returns a byte specifier of integers.  The value specifies the SIZE-bits byte
starting the least-significant-bit but POSITION bits of integers.  In ECL, a
byte specifier is represented by a dotted pair (SIZE . POSITION).") ((:LAMBDA-LIST) SI::SIZE POSITION) ((SI:LOCATION DEFUN BYTE) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 9750))
BYTE-POSITION
(((DOCUMENTATION . FUNCTION) . "Args: (byte)
Returns the position part (in ECL, the cdr part) of the byte specifier BYTE.") ((:LAMBDA-LIST) SI::BYTESPEC) ((SI:LOCATION DEFUN BYTE-POSITION) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 10188))
BYTE-SIZE
(((DOCUMENTATION . FUNCTION) . "Args: (byte)
Returns the size part (in ECL, the car part) of the byte specifier BYTE.") ((:LAMBDA-LIST) SI::BYTESPEC) ((SI:LOCATION DEFUN BYTE-SIZE) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 10051))
SI::C-DECLAIM
(((:LAMBDA-LIST) &REST C::DECLARATIONS) ((SI:LOCATION DEFMACRO SI::C-DECLAIM) #P"SRC:CMP;CMPENV-DECLAIM.LSP.NEWEST" . 2271))
FFI:C-INLINE
(((:LAMBDA-LIST) FFI::ARGS FFI::ARG-TYPES FFI::RET-TYPE &BODY FFI::OTHERS) ((SI:LOCATION DEFMACRO FFI:C-INLINE) #P"SRC:LSP;FFI.LSP.NEWEST" . 24452))
C::C-NUMBER-REP-TYPE-P
(((:LAMBDA-LIST) C::REP-TYPE) ((SI:LOCATION DEFUN C::C-NUMBER-REP-TYPE-P) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 5516))
C::C-NUMBER-TYPE-P
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN C::C-NUMBER-TYPE-P) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 5599))
C::C1-DEFCALLBACK
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1-DEFCALLBACK) #P"SRC:CMP;CMPCBK.LSP.NEWEST" . 558))
C::C1AND
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1AND) #P"SRC:CMP;CMPIF.LSP.NEWEST" . 1758))
C::C1APPLY
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1APPLY) #P"SRC:CMP;CMPFUN.LSP.NEWEST" . 2371))
C::C1APPLY-FROM-STACK-FRAME
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1APPLY-FROM-STACK-FRAME) #P"SRC:CMP;CMPSTACK.LSP.NEWEST" . 2566))
C::C1ARGS*
(((:LAMBDA-LIST) C::FORMS) ((SI:LOCATION DEFUN C::C1ARGS*) #P"SRC:CMP;CMPEVAL.LSP.NEWEST" . 5348))
C::C1BLOCK
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1BLOCK) #P"SRC:CMP;CMPBLOCK.LSP.NEWEST" . 1069))
C::C1BODY
(((:LAMBDA-LIST) C::BODY C::DOC-P) ((SI:LOCATION DEFUN C::C1BODY) #P"SRC:CMP;CMPENV-DECLARE.LSP.NEWEST" . 2329))
C::C1C-INLINE
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1C-INLINE) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 15030))
C::C1CALL-GLOBAL
(((:LAMBDA-LIST) C::FNAME C::ARGS) ((SI:LOCATION DEFUN C::C1CALL-GLOBAL) #P"SRC:CMP;CMPEVAL.LSP.NEWEST" . 3041))
C::C1CALL-LOCAL
(((:LAMBDA-LIST) C::FNAME C::ARGS) ((SI:LOCATION DEFUN C::C1CALL-LOCAL) #P"SRC:CMP;CMPEVAL.LSP.NEWEST" . 2090))
C::C1CALL-SYMBOL
(((:LAMBDA-LIST) C::FNAME C::ARGS &AUX C::FD) ((SI:LOCATION DEFUN C::C1CALL-SYMBOL) #P"SRC:CMP;CMPEVAL.LSP.NEWEST" . 1599))
C::C1CATCH
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1CATCH) #P"SRC:CMP;CMPCATCH.LSP.NEWEST" . 580))
C::C1CLINES
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1CLINES) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 13737))
C::C1COMPILE-FUNCTION
(((:LAMBDA-LIST) C::LAMBDA-LIST-AND-BODY &KEY (C::FUN (C::MAKE-FUN)) (C::NAME (C::FUN-NAME C::FUN)) (C::CB/LB 'C::CB)) ((SI:LOCATION DEFUN C::C1COMPILE-FUNCTION) #P"SRC:CMP;CMPLAM.LSP.NEWEST" . 2253))
C::C1COMPILER-LET
(((:LAMBDA-LIST) C::ARGS &AUX (C::SYMBOLS NIL) (VALUES NIL)) ((SI:LOCATION DEFUN C::C1COMPILER-LET) #P"SRC:CMP;CMPSPECIAL.LSP.NEWEST" . 1109))
C::C1COMPILER-TYPECASE
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1COMPILER-TYPECASE) #P"SRC:CMP;CMPOPT-TYPE.LSP.NEWEST" . 817))
C::C1COMPILER-TYPECASES
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1COMPILER-TYPECASES) #P"SRC:CMP;CMPOPT-TYPE.LSP.NEWEST" . 1043))
C::C1CONSTANT-VALUE
(((:LAMBDA-LIST) C::VAL &KEY C::ALWAYS C::ONLY-SMALL-VALUES) ((SI:LOCATION DEFUN C::C1CONSTANT-VALUE) #P"SRC:CMP;CMPCT.LSP.NEWEST" . 571))
C::C1DECL-BODY
(((:LAMBDA-LIST) C::DECLS C::BODY) ((SI:LOCATION DEFUN C::C1DECL-BODY) #P"SRC:CMP;CMPFLET.LSP.NEWEST" . 7220))
C::C1DECLARE
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1DECLARE) #P"SRC:CMP;CMPSPECIAL.LSP.NEWEST" . 683))
C::C1DECLARE-SPECIALS
(((:LAMBDA-LIST) C::GLOBALS) ((SI:LOCATION DEFUN C::C1DECLARE-SPECIALS) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 10333))
C::C1EVAL-WHEN
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1EVAL-WHEN) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 9130))
C::C1EXPR
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::C1EXPR) #P"SRC:CMP;CMPEVAL.LSP.NEWEST" . 570))
C::C1FLET
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1FLET) #P"SRC:CMP;CMPFLET.LSP.NEWEST" . 628))
C::C1FORM
(((SI:LOCATION DEFCLASS C::C1FORM) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 9763))
C::C1FORM-ADD-INFO
(((:LAMBDA-LIST) C::FORM C::DEPENDENTS) ((SI:LOCATION DEFUN C::C1FORM-ADD-INFO) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 5901))
C::C1FORM-ADD-INFO-LOOP
(((:LAMBDA-LIST) C::FORM C::DEPENDENTS) ((SI:LOCATION DEFUN C::C1FORM-ADD-INFO-LOOP) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 5126))
C::C1FORM-ARG
(((:LAMBDA-LIST) NTH C::FORM) ((SI:LOCATION DEFMACRO C::C1FORM-ARG) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 6641))
C::C1FORM-MOVABLE-P
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::C1FORM-MOVABLE-P) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 8151))
C::C1FORM-PRIMARY-TYPE
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::C1FORM-PRIMARY-TYPE) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 6889))
C::C1FORM-PURE-P
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::C1FORM-PURE-P) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 8727))
C::C1FORM-REPLACE-WITH
(((:LAMBDA-LIST) C::DEST C::NEW-FIELDS) ((SI:LOCATION DEFUN C::C1FORM-REPLACE-WITH) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 10437))
C::C1FORM-SINGLE-VALUED-P
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::C1FORM-SINGLE-VALUED-P) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 9606))
C::C1FORM-UNMODIFIED-P
(((:LAMBDA-LIST) C::FORM C::REST-FORM) ((SI:LOCATION DEFUN C::C1FORM-UNMODIFIED-P) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 8811))
C::C1FORM-VALUES-NUMBER
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::C1FORM-VALUES-NUMBER) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 9439))
C::C1FORM-VOLATILE*
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::C1FORM-VOLATILE*) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 6811))
C::C1FSET
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1FSET) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 28464))
C::C1FUNCALL
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1FUNCALL) #P"SRC:CMP;CMPCALL.LSP.NEWEST" . 1057))
C::C1FUNCTION
(((:LAMBDA-LIST) C::ARGS &AUX C::FD) ((SI:LOCATION DEFUN C::C1FUNCTION) #P"SRC:CMP;CMPSPECIAL.LSP.NEWEST" . 2027))
C::C1GO
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1GO) #P"SRC:CMP;CMPTAG.LSP.NEWEST" . 6540))
C::C1IF
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1IF) #P"SRC:CMP;CMPIF.LSP.NEWEST" . 557))
C::C1INNERMOST-STACK-FRAME
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1INNERMOST-STACK-FRAME) #P"SRC:CMP;CMPSTACK.LSP.NEWEST" . 1665))
C::C1LABELS
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1LABELS) #P"SRC:CMP;CMPFLET.LSP.NEWEST" . 574))
C::C1LABELS/FLET
(((:LAMBDA-LIST) C::ORIGIN C::ARGS) ((SI:LOCATION DEFUN C::C1LABELS/FLET) #P"SRC:CMP;CMPFLET.LSP.NEWEST" . 678))
C::C1LAMBDA-BODY
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::C1LAMBDA-BODY) #P"SRC:CMP;CMPLAM.LSP.NEWEST" . 1540))
C::C1LAMBDA-DOC
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::C1LAMBDA-DOC) #P"SRC:CMP;CMPLAM.LSP.NEWEST" . 1482))
C::C1LAMBDA-EXPR
(((:LAMBDA-LIST) C::LAMBDA-EXPR &OPTIONAL (C::BLOCK-NAME NIL) &AUX C::DOC C::BODY C::SS C::IS C::TS C::OTHER-DECLS C::NEW-VARIABLES (C::TYPE-CHECKS 'NIL) (C::*PERMANENT-DATA* T) (C::OLD-ENV C::*CMP-ENV*) (C::*CMP-ENV* (C::CMP-ENV-COPY))) ((SI:LOCATION DEFUN C::C1LAMBDA-EXPR) #P"SRC:CMP;CMPLAM.LSP.NEWEST" . 5015))
C::C1LAMBDA-LIST
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::C1LAMBDA-LIST) #P"SRC:CMP;CMPLAM.LSP.NEWEST" . 1599))
C::C1LET
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1LET) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 554))
C::C1LET*
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1LET*) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 1389))
C::C1LET-CAN-MOVE-VARIABLE-VALUE-P
(((:LAMBDA-LIST) C::VAR C::FORM C::REST-VARS C::REST-FORMS) ((SI:LOCATION DEFUN C::C1LET-CAN-MOVE-VARIABLE-VALUE-P) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 7592))
C::C1LET-CONSTANT-VALUE-P
(((:LAMBDA-LIST) C::VAR C::FORM C::REST-VARS C::REST-FORMS) ((SI:LOCATION DEFUN C::C1LET-CONSTANT-VALUE-P) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 6007))
C::C1LET-CONSTANT-VARIABLE-P
(((:LAMBDA-LIST) C::VAR C::FORM C::REST-VARS C::REST-FORMS) ((SI:LOCATION DEFUN C::C1LET-CONSTANT-VARIABLE-P) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 6443))
C::C1LET-OPTIMIZE-READ-ONLY-VARS
(((:LAMBDA-LIST) C::ALL-VARS C::ALL-FORMS C::BODY) ((SI:LOCATION DEFUN C::C1LET-OPTIMIZE-READ-ONLY-VARS) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 4211))
C::C1LET-UNUSED-VARIABLE-P
(((:LAMBDA-LIST) C::VAR C::FORM) ((SI:LOCATION DEFUN C::C1LET-UNUSED-VARIABLE-P) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 5554))
C::C1LET/LET*
(((:LAMBDA-LIST) C::LET/LET* C::BINDINGS C::BODY) ((SI:LOCATION DEFUN C::C1LET/LET*) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 1671))
C::C1LOAD-TIME-VALUE
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1LOAD-TIME-VALUE) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 19102))
C::C1LOCALLY
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1LOCALLY) #P"SRC:CMP;CMPFLET.LSP.NEWEST" . 7454))
C::C1MACROLET
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1MACROLET) #P"SRC:CMP;CMPFLET.LSP.NEWEST" . 7761))
C::C1MAKE-GLOBAL-VARIABLE
(((:LAMBDA-LIST) C::NAME &KEY (TYPE T) (C::KIND 'C::GLOBAL) (WARN NIL)) ((SI:LOCATION DEFUN C::C1MAKE-GLOBAL-VARIABLE) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 9910))
C::C1MAKE-VAR
(((:LAMBDA-LIST) C::NAME C::SPECIALS C::IGNORES C::TYPES) ((SI:LOCATION DEFUN C::C1MAKE-VAR) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 5592))
C::C1MULTIPLE-VALUE-BIND
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1MULTIPLE-VALUE-BIND) #P"SRC:CMP;CMPMULTI.LSP.NEWEST" . 8352))
C::C1MULTIPLE-VALUE-CALL
(((:LAMBDA-LIST) C::ARGS &AUX C::FORMS) ((SI:LOCATION DEFUN C::C1MULTIPLE-VALUE-CALL) #P"SRC:CMP;CMPMULTI.LSP.NEWEST" . 664))
C::C1MULTIPLE-VALUE-PROG1
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1MULTIPLE-VALUE-PROG1) #P"SRC:CMP;CMPMULTI.LSP.NEWEST" . 664))
C::C1MULTIPLE-VALUE-SETQ
(((:LAMBDA-LIST) C::ARGS &AUX (C::VARS NIL) (C::TEMP-VARS NIL) (C::LATE-BINDINGS NIL)) ((SI:LOCATION DEFUN C::C1MULTIPLE-VALUE-SETQ) #P"SRC:CMP;CMPMULTI.LSP.NEWEST" . 4277))
C::C1NIL
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::C1NIL) #P"SRC:CMP;CMPEVAL.LSP.NEWEST" . 1483))
C::C1NOT
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1NOT) #P"SRC:CMP;CMPIF.LSP.NEWEST" . 1279))
C::C1OR
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1OR) #P"SRC:CMP;CMPIF.LSP.NEWEST" . 2168))
C::C1PRINC
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1PRINC) #P"SRC:CMP;CMPFUN.LSP.NEWEST" . 623))
C::C1PROGN
(((:LAMBDA-LIST) C::FORMS) ((SI:LOCATION DEFUN C::C1PROGN) #P"SRC:CMP;CMPEVAL.LSP.NEWEST" . 4498))
C::C1PROGV
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1PROGV) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 11942))
C::C1PSETQ
(((:LAMBDA-LIST) C::OLD-ARGS &AUX (C::ARGS NIL) (C::USE-PSETF NIL)) ((SI:LOCATION DEFUN C::C1PSETQ) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 12678))
C::C1QUOTE
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1QUOTE) #P"SRC:CMP;CMPSPECIAL.LSP.NEWEST" . 579))
C::C1RETURN-FROM
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1RETURN-FROM) #P"SRC:CMP;CMPBLOCK.LSP.NEWEST" . 2769))
C::C1RPLACD
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1RPLACD) #P"SRC:CMP;CMPFUN.LSP.NEWEST" . 2991))
C::C1SETQ
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1SETQ) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 10613))
C::C1SETQ1
(((:LAMBDA-LIST) C::NAME C::FORM) ((SI:LOCATION DEFUN C::C1SETQ1) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 11095))
C::C1STACK-POP
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1STACK-POP) #P"SRC:CMP;CMPSTACK.LSP.NEWEST" . 2386))
C::C1STACK-PUSH
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1STACK-PUSH) #P"SRC:CMP;CMPSTACK.LSP.NEWEST" . 1806))
C::C1STACK-PUSH-VALUES
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1STACK-PUSH-VALUES) #P"SRC:CMP;CMPSTACK.LSP.NEWEST" . 1966))
C::C1STRUCTURE-REF
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1STRUCTURE-REF) #P"SRC:CMP;CMPSTRUCTURES.LSP.NEWEST" . 2190))
C::C1STRUCTURE-SET
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1STRUCTURE-SET) #P"SRC:CMP;CMPSTRUCTURES.LSP.NEWEST" . 3418))
C::C1SYMBOL-MACROLET
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1SYMBOL-MACROLET) #P"SRC:CMP;CMPFLET.LSP.NEWEST" . 7932))
C::C1T
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::C1T) #P"SRC:CMP;CMPEVAL.LSP.NEWEST" . 1578))
C::C1TAGBODY
(((:LAMBDA-LIST) C::ORIG-BODY &AUX (C::*CMP-ENV* (C::CMP-ENV-COPY)) (C::TAG-VAR (C::MAKE-VAR :NAME 'TAGBODY :KIND NIL)) (C::TAG-INDEX 0) (C::BODY NIL)) ((SI:LOCATION DEFUN C::C1TAGBODY) #P"SRC:CMP;CMPTAG.LSP.NEWEST" . 2458))
C::C1TERPRI
(((:LAMBDA-LIST) C::ARGS &AUX STREAM) ((SI:LOCATION DEFUN C::C1TERPRI) #P"SRC:CMP;CMPFUN.LSP.NEWEST" . 1946))
C::C1THE
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1THE) #P"SRC:CMP;CMPSPECIAL.LSP.NEWEST" . 788))
C::C1THROW
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1THROW) #P"SRC:CMP;CMPCATCH.LSP.NEWEST" . 3323))
C::C1UNWIND-PROTECT
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1UNWIND-PROTECT) #P"SRC:CMP;CMPCATCH.LSP.NEWEST" . 1584))
C::C1VALUES
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C1VALUES) #P"SRC:CMP;CMPMULTI.LSP.NEWEST" . 1953))
C::C1VAR
(((:LAMBDA-LIST) C::NAME) ((SI:LOCATION DEFUN C::C1VAR) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 6797))
C::C1VREF
(((:LAMBDA-LIST) C::NAME) ((SI:LOCATION DEFUN C::C1VREF) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 7420))
C::C1WITH-BACKEND
(((:LAMBDA-LIST) C::FORMS) ((SI:LOCATION DEFUN C::C1WITH-BACKEND) #P"SRC:CMP;CMPEVAL.LSP.NEWEST" . 4302))
C::C1WITH-STACK
(((:LAMBDA-LIST) C::FORMS) ((SI:LOCATION DEFUN C::C1WITH-STACK) #P"SRC:CMP;CMPSTACK.LSP.NEWEST" . 935))
C::C2BLOCK
(((:LAMBDA-LIST) C::BLK C::BODY) ((SI:LOCATION DEFUN C::C2BLOCK) #P"SRC:CMP;CMPBLOCK.LSP.NEWEST" . 1853))
C::C2C-INLINE
(((:LAMBDA-LIST) C::ARGUMENTS &REST REST) ((SI:LOCATION DEFUN C::C2C-INLINE) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 20277))
C::C2CALL-GLOBAL
(((:LAMBDA-LIST) C::FNAME C::ARGS &OPTIONAL (C::RETURN-TYPE T)) ((SI:LOCATION DEFUN C::C2CALL-GLOBAL) #P"SRC:CMP;CMPCALL.LSP.NEWEST" . 3206))
C::C2CALL-LOCAL
(((:LAMBDA-LIST) C::FUN C::ARGS &OPTIONAL C::NARG) ((SI:LOCATION DEFUN C::C2CALL-LOCAL) #P"SRC:CMP;CMPFLET.LSP.NEWEST" . 9190))
C::C2CATCH
(((:LAMBDA-LIST) C::TAG C::BODY) ((SI:LOCATION DEFUN C::C2CATCH) #P"SRC:CMP;CMPCATCH.LSP.NEWEST" . 756))
C::C2COMPILER-LET
(((:LAMBDA-LIST) C::SYMBOLS VALUES C::BODY) ((SI:LOCATION DEFUN C::C2COMPILER-LET) #P"SRC:CMP;CMPSPECIAL.LSP.NEWEST" . 1942))
C::C2EXPR
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::C2EXPR) #P"SRC:CMP;CMPEVAL.LSP.NEWEST" . 3705))
C::C2EXPR*
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::C2EXPR*) #P"SRC:CMP;CMPEVAL.LSP.NEWEST" . 4104))
C::C2FMLA-AND
(((:LAMBDA-LIST) BUTLAST LAST) ((SI:LOCATION DEFUN C::C2FMLA-AND) #P"SRC:CMP;CMPIF.LSP.NEWEST" . 4670))
C::C2FMLA-NOT
(((:LAMBDA-LIST) C::ARG) ((SI:LOCATION DEFUN C::C2FMLA-NOT) #P"SRC:CMP;CMPIF.LSP.NEWEST" . 3825))
C::C2FMLA-OR
(((:LAMBDA-LIST) BUTLAST LAST) ((SI:LOCATION DEFUN C::C2FMLA-OR) #P"SRC:CMP;CMPIF.LSP.NEWEST" . 4984))
C::C2FSET
(((:LAMBDA-LIST) C::FUN C::FNAME SI:MACRO PPRINT C::C1FORMS) ((SI:LOCATION DEFUN C::C2FSET) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 29617))
C::C2FUNCALL
(((:LAMBDA-LIST) C::FORM C::ARGS) ((SI:LOCATION DEFUN C::C2FUNCALL) #P"SRC:CMP;CMPCALL.LSP.NEWEST" . 2679))
C::C2FUNCTION
(((:LAMBDA-LIST) C::KIND C::FUNOB C::FUN) ((SI:LOCATION DEFUN C::C2FUNCTION) #P"SRC:CMP;CMPSPECIAL.LSP.NEWEST" . 3147))
C::C2GO
(((:LAMBDA-LIST) C::TAG C::NONLOCAL) ((SI:LOCATION DEFUN C::C2GO) #P"SRC:CMP;CMPTAG.LSP.NEWEST" . 7281))
C::C2IF
(((:LAMBDA-LIST) C::FMLA C::FORM1 C::FORM2) ((SI:LOCATION DEFUN C::C2IF) #P"SRC:CMP;CMPIF.LSP.NEWEST" . 2833))
C::C2LAMBDA-EXPR
(((:LAMBDA-LIST) C::LAMBDA-LIST C::BODY C::CFUN C::FNAME C::USE-NARG &OPTIONAL C::CLOSURE-TYPE C::LOCAL-ENTRY-P &AUX (C::REQUIREDS (FIRST C::LAMBDA-LIST)) (C::OPTIONALS (SECOND C::LAMBDA-LIST)) (REST (THIRD C::LAMBDA-LIST)) C::REST-LOC (C::KEYWORDS (FIFTH C::LAMBDA-LIST)) (C::ALLOW-OTHER-KEYS (SIXTH C::LAMBDA-LIST)) (C::NREQ (LENGTH C::REQUIREDS)) (C::NOPT (/ (LENGTH C::OPTIONALS) 3)) (C::NKEY (/ (LENGTH C::KEYWORDS) 4)) (C::VARARGS (OR C::OPTIONALS REST C::KEYWORDS C::ALLOW-OTHER-KEYS)) (C::FNAME-IN-IHS-P (OR (C::POLICY-DEBUG-VARIABLE-BINDINGS) (AND (C::POLICY-DEBUG-IHS-FRAME) C::FNAME))) C::SIMPLE-VARARGS (C::*PERMANENT-DATA* T) (C::*UNWIND-EXIT* C::*UNWIND-EXIT*) (C::*ENV* C::*ENV*) (C::LAST-ARG)) ((SI:LOCATION DEFUN C::C2LAMBDA-EXPR) #P"SRC:CMP;CMPLAM.LSP.NEWEST" . 10869))
C::C2LET*
(((:LAMBDA-LIST) C::VARS C::FORMS C::BODY &AUX (C::*UNWIND-EXIT* C::*UNWIND-EXIT*) (C::*ENV* C::*ENV*) (C::*ENV-LVL* C::*ENV-LVL*) (C::*INLINE-BLOCKS* 0)) ((SI:LOCATION DEFUN C::C2LET*) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 9466))
C::C2LET-REPLACEABLE-VAR-REF-P
(((:LAMBDA-LIST) C::VAR C::FORM C::REST-FORMS) ((SI:LOCATION DEFUN C::C2LET-REPLACEABLE-VAR-REF-P) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 6990))
C::C2LOCALS
(((:LAMBDA-LIST) C::FUNS C::BODY LABELS &AUX C::BLOCK-P (C::*ENV* C::*ENV*) (C::*ENV-LVL* C::*ENV-LVL*) C::ENV-GROWS) ((SI:LOCATION DEFUN C::C2LOCALS) #P"SRC:CMP;CMPFLET.LSP.NEWEST" . 5918))
C::C2LOCATION
(((:LAMBDA-LIST) C::LOC) ((SI:LOCATION DEFUN C::C2LOCATION) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 8480))
C::C2MULTIPLE-VALUE-BIND
(((:LAMBDA-LIST) C::VARS C::INIT-FORM C::BODY) ((SI:LOCATION DEFUN C::C2MULTIPLE-VALUE-BIND) #P"SRC:CMP;CMPMULTI.LSP.NEWEST" . 9277))
C::C2MULTIPLE-VALUE-SETQ
(((:LAMBDA-LIST) C::VARS C::FORM) ((SI:LOCATION DEFUN C::C2MULTIPLE-VALUE-SETQ) #P"SRC:CMP;CMPMULTI.LSP.NEWEST" . 8019))
C::C2PRINC
(((:LAMBDA-LIST) STRING C::STREAM-VAR STREAM) ((SI:LOCATION DEFUN C::C2PRINC) #P"SRC:CMP;CMPFUN.LSP.NEWEST" . 1070))
C::C2PROGN
(((:LAMBDA-LIST) C::FORMS) ((SI:LOCATION DEFUN C::C2PROGN) #P"SRC:CMP;CMPEVAL.LSP.NEWEST" . 4809))
C::C2PROGV
(((:LAMBDA-LIST) C::SYMBOLS VALUES C::BODY) ((SI:LOCATION DEFUN C::C2PROGV) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 12191))
C::C2PSETQ
(((:LAMBDA-LIST) C::VREFS C::FORMS &AUX (C::*LCL* C::*LCL*) (C::SAVES NIL) (C::BLOCKS 0)) ((SI:LOCATION DEFUN C::C2PSETQ) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 13850))
C::C2RETURN-FROM
(((:LAMBDA-LIST) C::BLK TYPE C::VAL C::VAR) ((SI:LOCATION DEFUN C::C2RETURN-FROM) #P"SRC:CMP;CMPBLOCK.LSP.NEWEST" . 3673))
C::C2RPLACD
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::C2RPLACD) #P"SRC:CMP;CMPFUN.LSP.NEWEST" . 3101))
C::C2SETQ
(((:LAMBDA-LIST) C::VREF C::FORM) ((SI:LOCATION DEFUN C::C2SETQ) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 11764))
C::C2STACK-PUSH-VALUES
(((:LAMBDA-LIST) C::FORM C::PUSH-STATEMENT) ((SI:LOCATION DEFUN C::C2STACK-PUSH-VALUES) #P"SRC:CMP;CMPSTACK.LSP.NEWEST" . 2256))
C::C2STRUCTURE-REF
(((:LAMBDA-LIST) C::FORM C::NAME-VV C::INDEX C::UNSAFE) ((SI:LOCATION DEFUN C::C2STRUCTURE-REF) #P"SRC:CMP;CMPSTRUCTURES.LSP.NEWEST" . 2840))
C::C2STRUCTURE-SET
(((:LAMBDA-LIST) C::X C::NAME-VV C::INDEX C::Y &AUX C::LOCS (C::*INLINE-BLOCKS* 0)) ((SI:LOCATION DEFUN C::C2STRUCTURE-SET) #P"SRC:CMP;CMPSTRUCTURES.LSP.NEWEST" . 4513))
C::C2TAGBODY
(((:LAMBDA-LIST) C::TAG-LOC C::BODY) ((SI:LOCATION DEFUN C::C2TAGBODY) #P"SRC:CMP;CMPTAG.LSP.NEWEST" . 4267))
C::C2TAGBODY-BODY
(((:LAMBDA-LIST) C::BODY) ((SI:LOCATION DEFUN C::C2TAGBODY-BODY) #P"SRC:CMP;CMPTAG.LSP.NEWEST" . 5845))
C::C2THROW
(((:LAMBDA-LIST) C::TAG C::VAL &AUX C::LOC) ((SI:LOCATION DEFUN C::C2THROW) #P"SRC:CMP;CMPCATCH.LSP.NEWEST" . 3460))
C::C2TRY-TAIL-RECURSIVE-CALL
(((:LAMBDA-LIST) C::FUN C::ARGS) ((SI:LOCATION DEFUN C::C2TRY-TAIL-RECURSIVE-CALL) #P"SRC:CMP;CMPEXIT.LSP.NEWEST" . 7339))
C::C2UNWIND-PROTECT
(((:LAMBDA-LIST) C::FORM C::BODY) ((SI:LOCATION DEFUN C::C2UNWIND-PROTECT) #P"SRC:CMP;CMPCATCH.LSP.NEWEST" . 1897))
C::C2VALUES
(((:LAMBDA-LIST) C::FORMS) ((SI:LOCATION DEFUN C::C2VALUES) #P"SRC:CMP;CMPMULTI.LSP.NEWEST" . 2023))
C::C2VAR
(((:LAMBDA-LIST) C::VREF) ((SI:LOCATION DEFUN C::C2VAR) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 8439))
C::C2WITH-STACK
(((:LAMBDA-LIST) C::BODY) ((SI:LOCATION DEFUN C::C2WITH-STACK) #P"SRC:CMP;CMPSTACK.LSP.NEWEST" . 1141))
CAAAAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CAR (CAR (CAR (CAR X)))).
") ((:LAMBDA-LIST) SI::X))
CAAADR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CAR (CAR (CAR (CDR X)))).
") ((:LAMBDA-LIST) SI::X))
CAAAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CAR (CAR (CAR X))).
") ((:LAMBDA-LIST) SI::X))
CAADAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CAR (CAR (CDR (CAR X)))).
") ((:LAMBDA-LIST) SI::X))
CAADDR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CAR (CAR (CDR (CDR X)))).
") ((:LAMBDA-LIST) SI::X))
CAADR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CAR (CAR (CDR X))).
") ((:LAMBDA-LIST) SI::X))
CAAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CAR (CAR X)).
") ((:LAMBDA-LIST) SI::X))
CADAAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CAR (CDR (CAR (CAR X)))).
") ((:LAMBDA-LIST) SI::X))
CADADR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CAR (CDR (CAR (CDR X)))).
") ((:LAMBDA-LIST) SI::X))
CADAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CAR (CDR (CAR X))).
") ((:LAMBDA-LIST) SI::X))
CADDAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CAR (CDR (CDR (CAR X)))).
") ((:LAMBDA-LIST) SI::X))
CADDDR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CAR (CDR (CDR (CDR X)))).
") ((:LAMBDA-LIST) SI::X))
CADDR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CAR (CDR (CDR X))).
") ((:LAMBDA-LIST) SI::X))
CADR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CAR (CDR X)).
") ((:LAMBDA-LIST) SI::X))
CALL-ARGUMENTS-LIMIT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The upper bound of the number of arguments to a function.  Ignore this value
since there is no such logical upper bound in ECL.
"))
C::CALL-EXPORTED-FUNCTION-LOC
(((:LAMBDA-LIST) C::FNAME C::ARGS C::FUN-C-NAME C::MINARG C::MAXARG C::IN-CORE) ((SI:LOCATION DEFUN C::CALL-EXPORTED-FUNCTION-LOC) #P"SRC:CMP;CMPCALL.LSP.NEWEST" . 5946))
C::CALL-GLOBAL-LOC
(((:LAMBDA-LIST) C::FNAME C::FUN C::ARGS C::RETURN-TYPE C::EXPECTED-TYPE) ((SI:LOCATION DEFUN C::CALL-GLOBAL-LOC) #P"SRC:CMP;CMPCALL.LSP.NEWEST" . 3965))
C::CALL-LOC
(((:LAMBDA-LIST) C::FNAME C::FUN C::ARGS) ((SI:LOCATION DEFUN C::CALL-LOC) #P"SRC:CMP;CMPCALL.LSP.NEWEST" . 5869))
CALL-METHOD
(((:LAMBDA-LIST) METHOD &OPTIONAL CLOS::REST-METHODS) ((SI:LOCATION DEFMACRO CALL-METHOD) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 3857))
CALL-NEXT-METHOD
(((SI:LOCATION DEFINE-COMPILER-MACRO CALL-NEXT-METHOD) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 4389) ((:LAMBDA-LIST) &REST CLOS::ARGS) ((SI:LOCATION DEFUN CALL-NEXT-METHOD) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 4066))
C::CALL-UNKNOWN-GLOBAL-LOC
(((:LAMBDA-LIST) C::FNAME C::LOC C::ARGS &OPTIONAL C::FUNCTION-P) ((SI:LOCATION DEFUN C::CALL-UNKNOWN-GLOBAL-LOC) #P"SRC:CMP;CMPCALL.LSP.NEWEST" . 6994))
FFI:CALLBACK
(((:LAMBDA-LIST) FFI::NAME) ((SI:LOCATION DEFUN FFI:CALLBACK) #P"SRC:LSP;FFI.LSP.NEWEST" . 24074))
SI::CANONICAL-COMPLEX-TYPE
(((:LAMBDA-LIST) SI::REAL-TYPE) ((SI:LOCATION DEFUN SI::CANONICAL-COMPLEX-TYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 38362))
CLOS::CANONICAL-SLOT-TO-DIRECT-SLOT
(((:LAMBDA-LIST) CLASS CLOS::SLOTD) ((SI:LOCATION DEFUN CLOS::CANONICAL-SLOT-TO-DIRECT-SLOT) #P"SRC:CLOS;SLOT.LSP.NEWEST" . 2738))
SI::CANONICAL-TYPE
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN SI::CANONICAL-TYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 45484))
CAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns the car of X if X is a cons.  Returns NIL if X is NIL.
") ((:LAMBDA-LIST) SI::X))
SI::CARDINAL-ONES
(((SI:LOCATION DEFCONSTANT SI::CARDINAL-ONES) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 35488))
SI::CARDINAL-PERIODS
(((SI:LOCATION DEFCONSTANT SI::CARDINAL-PERIODS) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 35850))
SI::CARDINAL-TEENS
(((SI:LOCATION DEFCONSTANT SI::CARDINAL-TEENS) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 35702))
SI::CARDINAL-TENS
(((SI:LOCATION DEFCONSTANT SI::CARDINAL-TENS) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 35589))
CASE
(((DOCUMENTATION . FUNCTION) . "Macro in COMMON-LISP package:
Syntax: (case keyform {({key | ({key}*)} {form}*)}*)

Evaluates KEYFORM and searches a KEY that is EQL to the value of KEYFORM.  If
found, then evaluates FORMs in order that follow the KEY (or the key list that
contains the KEY) and returns all values of the last FORM.  Returns NIL if no
such key is found.  The symbols T and OTHERWISE may be used at the place of a
key list to specify the default case.
") ((:LAMBDA-LIST) . "(case keyform {({key | ({key}*)} {form}*)}*)") ((SI:LOCATION DEFMACRO CASE) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 10075))
SI::CASE-FAILURE
(((SI:LOCATION DEFCLASS SI::CASE-FAILURE) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
CATCH
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (catch tag-form {form}*)

Sets up a catcher whose catch tag is the value of TAG-FORM.  Then evaluates
FORMs in order and returns all values of the last FORM.  During the evaluation
of FORMs, if a THROW form is evaluated that specifies a catch tag EQ to the
value of the TAG-FORM, then the execution of the CATCH form terminates
immediately and the values specified by the THROW form are returned as the
value of the CATCH form.
") ((:LAMBDA-LIST) . "(catch tag-form {form}*)"))
CCASE
(((DOCUMENTATION . FUNCTION) . "Syntax: (ccase place {({key | ({key}*)} {form}*)}*)
Searches a KEY that is EQL to the value of PLACE.  If found, then evaluates
FORMs in order that follow the KEY (or the key list that contains the KEY) and
returns all values of the last FORM.  If no such KEY is found, signals a
continuable error.  Before continuing, receives a new value of PLACE from
user and searches a KEY again.  Repeats this process until the value of PLACE
becomes EQL to one of the KEYs.") ((:LAMBDA-LIST) SI::KEYPLACE &REST SI::CLAUSES) ((SI:LOCATION DEFMACRO CCASE) #P"SRC:LSP;ASSERT.LSP.NEWEST" . 5070))
SI::CCASE-ERROR
(((:LAMBDA-LIST) SI::KEYFORM SI::KEY VALUES) ((SI:LOCATION DEFUN SI::CCASE-ERROR) #P"SRC:LSP;ASSERT.LSP.NEWEST" . 4431))
CDAAAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CDR (CAR (CAR (CAR X)))).
") ((:LAMBDA-LIST) SI::X))
CDAADR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CDR (CAR (CAR (CDR X)))).
") ((:LAMBDA-LIST) SI::X))
CDAAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CDR (CAR (CAR X))).
") ((:LAMBDA-LIST) SI::X))
CDADAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CDR (CAR (CDR (CAR X)))).
") ((:LAMBDA-LIST) SI::X))
CDADDR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CDR (CAR (CDR (CDR X)))).
") ((:LAMBDA-LIST) SI::X))
CDADR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CDR (CAR (CDR X))).
") ((:LAMBDA-LIST) SI::X))
CDAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CDR (CAR X)).
") ((:LAMBDA-LIST) SI::X))
CDDAAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CDR (CDR (CAR (CAR X)))).
") ((:LAMBDA-LIST) SI::X))
CDDADR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CDR (CDR (CAR (CDR X)))).
") ((:LAMBDA-LIST) SI::X))
CDDAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CDR (CDR (CAR X))).
") ((:LAMBDA-LIST) SI::X))
CDDDAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CDR (CDR (CDR (CAR X)))).
") ((:LAMBDA-LIST) SI::X))
CDDDDR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CDR (CDR (CDR (CDR X)))).
") ((:LAMBDA-LIST) SI::X))
CDDDR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CDR (CDR (CDR X))).
") ((:LAMBDA-LIST) SI::X))
CDDR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CDR (CDR X)).
") ((:LAMBDA-LIST) SI::X))
CDR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns the cdr of X if X is a cons.  Returns NIL if X is NIL.
") ((:LAMBDA-LIST) SI::X))
CEILING
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER &OPTIONAL (DIVISOR 1))

Returns the smallest integer not less than NUMBER/DIVISOR.  Returns the value
of (- NUMBER (* first-value DIVISOR)) as the second value.
") ((:LAMBDA-LIST) NUMBER &OPTIONAL (SI::DIVISOR 1)))
CELL-ERROR
(((SI:LOCATION DEFCLASS CELL-ERROR) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
CERROR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CONTINUE-FORMAT-STRING ERROR-FORMAT-STRING &REST ARGS)

Signals a continuable error.
") ((:LAMBDA-LIST) SI::CONTINUE-FORMAT-STRING SI::ERROR-FORMAT-STRING &REST SI::ARGS))
CHANGE-CLASS
(((SI:LOCATION DEFMETHOD CHANGE-CLASS (CLOS::INSTANCE CLASS) CLOS::NEW-CLASS &REST CLOS::INITARGS) #P"SRC:CLOS;CHANGE.LSP.NEWEST" . 3390) ((SI:LOCATION DEFMETHOD CHANGE-CLASS (CLOS::INSTANCE STANDARD-OBJECT) (CLOS::NEW-CLASS CLOS::STD-CLASS) &REST CLOS::INITARGS) #P"SRC:CLOS;CHANGE.LSP.NEWEST" . 2187) ((SI:LOCATION DEFMETHOD CHANGE-CLASS (CLOS::INSTANCE T) (CLOS::NEW-CLASS SYMBOL) &REST CLOS::INITARGS) #P"SRC:CLOS;BUILTIN.LSP.NEWEST" . 3587))
CHAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING INDEX)

Returns the INDEX-th character in STRING.
") ((:LAMBDA-LIST) STRING SI::INDEX))
FFI:CHAR-ARRAY-TO-POINTER
(((:LAMBDA-LIST) FFI::OBJ) ((SI:LOCATION DEFUN FFI:CHAR-ARRAY-TO-POINTER) #P"SRC:LSP;FFI.LSP.NEWEST" . 13050))
SI::CHAR-BIT
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (CHAR NAME)

Returns T if the specified bit attribute of CHAR is 'on'; NIL otherwise.
In ECL the bit-attributes handled are :control :meta :super and :hyper
") ((:LAMBDA-LIST) CHAR SI::NAME))
SI::CHAR-BITS
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (CHAR)

Returns the bit attributes of CHAR as an integer. In ECL it returns a value
between 0 and 16, since ECL handle 4 bit attributes.
") ((:LAMBDA-LIST) CHAR))
SI::CHAR-BITS-LIMIT
(((DOCUMENTATION . VARIABLE) . "Constant in SI package:
The upper bound of values returned by CHAR-BITS.  16 in ECL.
"))
CHAR-CODE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR)

Returns the character code of CHAR as a fixnum.
") ((:LAMBDA-LIST) CHAR))
CHAR-CODE-LIMIT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The upper bound of values returned by CHAR-CODE.
"))
SI::CHAR-CONTROL-BIT
(((DOCUMENTATION . VARIABLE) . "Constant in SI package:
The bit position indicating a control character.  1 in ECL.
"))
CHAR-DOWNCASE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR)

Returns the lower-case character corresponding to CHAR, if CHAR is upper-case.
Otherwise, returns CHAR.
") ((:LAMBDA-LIST) CHAR))
CHAR-EQUAL
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR &REST MORE-CHARS)

Returns T if all CHARs are the same; NIL otherwise.  Lower-case characters are
regarded the same as the corresponding upper-case characters.
") ((:LAMBDA-LIST) CHAR &REST SI::MORE-CHARS))
SI::CHAR-FONT
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (CHAR)

Returns the font attribute of CHAR.  Returns always 0 in ECL, since ECL
characters have no font attributes.
") ((:LAMBDA-LIST) CHAR))
SI::CHAR-FONT-LIMIT
(((DOCUMENTATION . VARIABLE) . "Constant in SI package:
The upper bound of values returned by CHAR-FONT.  1 in ECL.
"))
CHAR-GREATERP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR &REST MORE-CHARS)

Returns T if the character codes of CHARs are in decreasing order; NIL
otherwise.  For lower-case characters, codes of corresponding upper-case
characters are used.
") ((:LAMBDA-LIST) CHAR &REST SI::MORE-CHARS))
SI::CHAR-HYPER-BIT
(((DOCUMENTATION . VARIABLE) . "Constant in SI package:
The bit position indicating a hyper character.  8 in ECL.
"))
CHAR-INT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR)

Returns the font, bits, and code attributes as an integer.  Equivalent to
CHAR-CODE in ECL.
") ((:LAMBDA-LIST) CHAR))
CHAR-LESSP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR &REST MORE-CHARS)

Returns T if the character codes of CHARs are in increasing order; NIL
otherwise.  For lower-case characters, codes of corresponding upper-case
characters are used.
") ((:LAMBDA-LIST) CHAR &REST SI::MORE-CHARS))
SI::CHAR-META-BIT
(((DOCUMENTATION . VARIABLE) . "Constant in SI package:
The bit position indicating a meta character.  2 in ECL.
"))
CHAR-NAME
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR)

Returns the 'character name' of CHAR as a string; NIL if CHAR has no character
name.  Only #\\Backspace, #\\Tab, #\\Newline (or #\\Linefeed), #\\Page,
#\\Return, and #\\Rubout have character names in ECL.
") ((:LAMBDA-LIST) CHAR))
CHAR-NOT-EQUAL
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR &REST MORE-CHARS)

Returns T if no two of CHARs are the same; NIL otherwise.  Lower-case
characters are regarded the same as the corresponding upper-case characters.
") ((:LAMBDA-LIST) CHAR &REST SI::MORE-CHARS))
CHAR-NOT-GREATERP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR &REST MORE-CHARS)

Returns T if the character codes of CHARs are in non-decreasing order; NIL
otherwise.  For lower-case characters, codes of corresponding upper-case
characters are used.
") ((:LAMBDA-LIST) CHAR &REST SI::MORE-CHARS))
CHAR-NOT-LESSP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR &REST MORE-CHARS)

Returns T if the character codes of CHARs are in non-increasing order; NIL
otherwise.  For lower-case characters, codes of corresponding upper-case
characters are used.
") ((:LAMBDA-LIST) CHAR &REST SI::MORE-CHARS))
SI::CHAR-PRINTING-P
(((:LAMBDA-LIST) CHAR) ((SI:LOCATION DEFUN SI::CHAR-PRINTING-P) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 30050))
SI::CHAR-SUPER-BIT
(((DOCUMENTATION . VARIABLE) . "Constant in SI package:
The bit position indicating a super character.  4 in ECL.
"))
CHAR-UPCASE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR)

Returns the upper-case character of CHAR, if CHAR is lower-case.  Otherwise,
returns CHAR.
") ((:LAMBDA-LIST) CHAR))
CHAR/=
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR &REST MORE-CHARS)

Returns T if no two of CHARs are the same; NIL otherwise.
") ((:LAMBDA-LIST) CHAR &REST SI::MORE-CHARS))
CHAR<
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR &REST MORE-CHARS)

Returns T if the character codes of CHARs are in increasing order; NIL
otherwise.
") ((:LAMBDA-LIST) CHAR &REST SI::MORE-CHARS))
CHAR<=
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR &REST MORE-CHARS)

Returns T if the character codes of CHARs are in non-decreasing order; NIL
otherwise.
") ((:LAMBDA-LIST) CHAR &REST SI::MORE-CHARS))
CHAR=
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR &REST MORE-CHARS)

Returns T if all CHARs are the same; NIL otherwise.
") ((:LAMBDA-LIST) CHAR &REST SI::MORE-CHARS))
CHAR>
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR &REST MORE-CHARS)

Returns T if the character codes of CHARs are in decreasing order; NIL
otherwise.
") ((:LAMBDA-LIST) CHAR &REST SI::MORE-CHARS))
CHAR>=
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR &REST MORE-CHARS)

Returns T if the character codes of CHARs are in non-increasing order; NIL
otherwise.
") ((:LAMBDA-LIST) CHAR &REST SI::MORE-CHARS))
CHARACTER
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Coerces X into a character if possible.  Signals an error if not possible.
") ((:LAMBDA-LIST) SI::X) ((DOCUMENTATION . TYPE) . "
A character represents a character that can be handled by the computer.
Characters have font, bits, and code attributes.  Font and bits attributes
are always 0 in ECL.  Most versions of ECL uses ASCII code:
  000 - 037	#\\^@  #\\^A  #^B ... #\\Z  #\\^[  #\\^\\  #\\^]  #\\^^  #\\^_
		except #\\Tab(011)     #\\Newline(012)     #\\Page(014)
		       #\\Return(015)  #\\Backspace(031)
  040 - 057	#\\Space  #\\!  #\\\"  #\\#  #\\$  #\\%  #\\&  #\\'  #\\(  #\\)  #\\*
		#\\+  #\\,  #\\-  #\\.  #\\/
  060 - 071	#\\0  #\\1  #\\2  #\\3  #\\4  #\\5  #\\6  #\\7  #\\8  #\\9
  072 - 100	#\\:  #\\;  #\\<  #\\=  #\\>  #\\?  #\\@
  101 - 132	#\\A ... #\\Z
  133 - 140	#\\[  #\\\\  #\\]  #\\^  #\\_  #\\`
  141 - 172	#\\a ... #\\z
  173 - 177	#\\{  #\\|  #\\}  #\\~~  #\\Rubout
Some versions of ECL support additional characters to represent Japanese
character set."))
CHARACTERP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a character; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
SI:CHDIR
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (FILESPEC &OPTIONAL (UPDATE-LISP T))

Changes the current working directory of the C library to the one specified by
FILESPEC.  FILESPEC may be a symbol, a string, or a pathname. UPDATE-LISP
determines whether the value of *DEFAULT-PATHNAME-DEFAULTS* is also to be
changed.
") ((:LAMBDA-LIST) SI::FILESPEC &OPTIONAL (SI::UPDATE-LISP T)))
C::CHECK-ARGS-NUMBER
(((:LAMBDA-LIST) C::OPERATOR C::ARGS &OPTIONAL (MIN 0) (MAX MOST-POSITIVE-FIXNUM)) ((SI:LOCATION DEFUN C::CHECK-ARGS-NUMBER) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 8568))
C::CHECK-ARRAYP
(((:LAMBDA-LIST) C::A) ((SI:LOCATION DEFMACRO C::CHECK-ARRAYP) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 8723))
SI::CHECK-DEFAULT-DEBUGGER-RUNAWAY
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::CHECK-DEFAULT-DEBUGGER-RUNAWAY) #P"SRC:LSP;TOP.LSP.NEWEST" . 46845))
CLOS::CHECK-DIRECT-SUPERCLASSES
(((SI:LOCATION DEFMETHOD CLOS::CHECK-DIRECT-SUPERCLASSES CLASS CLOS::SUPPLIED-SUPERCLASSES) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 8277))
C::CHECK-EXPECTED-RANK
(((:LAMBDA-LIST) C::A C::EXPECTED-RANK) ((SI:LOCATION DEFMACRO C::CHECK-EXPECTED-RANK) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 9040))
C::CHECK-GLOBAL
(((:LAMBDA-LIST) C::NAME) ((SI:LOCATION DEFUN C::CHECK-GLOBAL) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 4926))
C::CHECK-INDEX-IN-BOUNDS
(((:LAMBDA-LIST) ARRAY C::INDEX C::LIMIT) ((SI:LOCATION DEFMACRO C::CHECK-INDEX-IN-BOUNDS) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 9260))
CLOS::CHECK-INITARGS
(((:LAMBDA-LIST) CLASS CLOS::INITARGS &OPTIONAL CLOS::METHODS (CLOS::SLOTS (CLOS:CLASS-SLOTS CLASS)) CLOS::CACHED-KEYWORDS) ((SI:LOCATION DEFUN CLOS::CHECK-INITARGS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 29717))
SI::CHECK-OUTPUT-LAYOUT-MODE
(((:LAMBDA-LIST) SI::MODE) ((SI:LOCATION DEFUN SI::CHECK-OUTPUT-LAYOUT-MODE) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 79464))
SI::CHECK-PRINT-LEVEL
(((DOCUMENTATION . FUNCTION) . "Automatically handle *print-level* abbreviation.  If we are too deep, then
   a # is printed to STREAM and BODY is ignored.") ((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::CHECK-PRINT-LEVEL) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 25551))
SI::CHECK-STORES-NUMBER
(((:LAMBDA-LIST) SI::CONTEXT SI::STORES-LIST SI::N) ((SI:LOCATION DEFUN SI::CHECK-STORES-NUMBER) #P"SRC:LSP;SETF.LSP.NEWEST" . 584))
CHECK-TYPE
(((DOCUMENTATION . FUNCTION) . "Args: (check-type place typespec [string-form])
Signals a continuable error, if the value of PLACE is not of the specified
type.  Before continuing, receives a new value of PLACE from the user and
checks the type again.  Repeats this process until the value of PLACE becomes
of the specified type.  STRING-FORM, if given, is evaluated only once and the
value is used to indicate the expected type in the error message.") ((:LAMBDA-LIST) SI::PLACE TYPE &OPTIONAL SI::TYPE-STRING) ((SI:LOCATION DEFMACRO CHECK-TYPE) #P"SRC:LSP;ASSERT.LSP.NEWEST" . 1367))
C::CHECK-VDECL
(((:LAMBDA-LIST) C::VNAMES C::TS C::IS) ((SI:LOCATION DEFUN C::CHECK-VDECL) #P"SRC:CMP;CMPENV-DECLARE.LSP.NEWEST" . 6918))
C::CHECK-VECTOR-IN-BOUNDS
(((:LAMBDA-LIST) VECTOR C::INDEX) ((SI:LOCATION DEFMACRO C::CHECK-VECTOR-IN-BOUNDS) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 9499))
C::CHECK-VECTORP
(((:LAMBDA-LIST) C::V) ((SI:LOCATION DEFMACRO C::CHECK-VECTORP) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 8874))
C::CHECK-VREF
(((:LAMBDA-LIST) C::VAR) ((SI:LOCATION DEFUN C::CHECK-VREF) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 6328))
C::CHK-SYMBOL-MACROLET
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::CHK-SYMBOL-MACROLET) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 5368))
C::CHOOSE-INLINE-INFO
(((:LAMBDA-LIST) C::IA C::IB C::RETURN-TYPE C::RETURN-REP-TYPE) ((SI:LOCATION DEFUN C::CHOOSE-INLINE-INFO) #P"SRC:CMP;CMPC-INLINER.LSP.NEWEST" . 2496))
CIS
(((DOCUMENTATION . FUNCTION) . "Args: (radians)
Returns a complex number whose realpart and imagpart are the values of (COS
RADIANS) and (SIN RADIANS) respectively.") ((:LAMBDA-LIST) SI::X) ((SI:LOCATION DEFUN CIS) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 4792))
CLOS::CLASS-CLASS-SLOTS
(((:LAMBDA-LIST) CLASS) ((SI:LOCATION DEFUN CLOS::CLASS-CLASS-SLOTS) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 7696))
CLOS::CLASS-COMPUTE-SLOTS
(((:LAMBDA-LIST) CLASS CLOS::SLOTS) ((SI:LOCATION DEFUN CLOS::CLASS-COMPUTE-SLOTS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 19730))
CLOS:CLASS-DEFAULT-INITARGS
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS:CLASS-DEFAULT-INITARGS) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS:CLASS-DEFAULT-INITARGS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 3373))
CLOS::CLASS-DEPENDENTS
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS::CLASS-DEPENDENTS) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS::CLASS-DEPENDENTS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 3373))
CLOS:CLASS-DIRECT-DEFAULT-INITARGS
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS:CLASS-DIRECT-DEFAULT-INITARGS) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS:CLASS-DIRECT-DEFAULT-INITARGS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 3373))
CLOS:CLASS-DIRECT-SLOTS
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS:CLASS-DIRECT-SLOTS) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS:CLASS-DIRECT-SLOTS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 3373))
CLOS:CLASS-DIRECT-SUBCLASSES
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS:CLASS-DIRECT-SUBCLASSES) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS:CLASS-DIRECT-SUBCLASSES) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 3373))
CLOS:CLASS-DIRECT-SUPERCLASSES
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS:CLASS-DIRECT-SUPERCLASSES) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS:CLASS-DIRECT-SUPERCLASSES) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 3373))
CLOS:CLASS-FINALIZED-P
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS:CLASS-FINALIZED-P) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS:CLASS-FINALIZED-P) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 3373))
CLOS::CLASS-ID
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS::CLASS-ID) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS::CLASS-ID) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 3373))
CLOS::CLASS-LOCAL-SLOTS
(((:LAMBDA-LIST) CLASS) ((SI:LOCATION DEFUN CLOS::CLASS-LOCAL-SLOTS) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 7583))
CLASS-NAME
(((SI:LOCATION DEFMETHOD CLASS-NAME (CLASS CLASS)) #P"SRC:CLOS;BOOT.LSP.NEWEST" . 10017))
CLOS:CLASS-PRECEDENCE-LIST
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS:CLASS-PRECEDENCE-LIST) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS:CLASS-PRECEDENCE-LIST) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 3373))
CLOS:CLASS-PROTOTYPE
(((SI:LOCATION DEFMETHOD CLOS:CLASS-PROTOTYPE (CLASS CLASS)) #P"SRC:CLOS;BOOT.LSP.NEWEST" . 5969))
CLOS::CLASS-SEALEDP
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS::CLASS-SEALEDP) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS::CLASS-SEALEDP) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 3373))
CLOS::CLASS-SIZE
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS::CLASS-SIZE) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS::CLASS-SIZE) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 3373))
CLOS:CLASS-SLOTS
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS:CLASS-SLOTS) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS:CLASS-SLOTS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 3373))
CLOS::CLASS-VALID-INITARGS
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS::CLASS-VALID-INITARGS) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS::CLASS-VALID-INITARGS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 3373))
CLOS::CLASSP
(((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS::CLASSP) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 6739))
CLEAR-INPUT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&OPTIONAL (STREAM *STANDARD-INPUT*))

Clears the input buffer of STREAM and returns NIL.  Contents of the buffer are
discarded.
") ((:LAMBDA-LIST) &OPTIONAL (STREAM *STANDARD-INPUT*)))
CLEAR-OUTPUT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&OPTIONAL (STREAM *STANDARD-OUTPUT*))

Clears the output buffer of STREAM and returns NIL.  Contents of the buffer
are discarded.
") ((:LAMBDA-LIST) &OPTIONAL (STREAM *STANDARD-OUTPUT*)))
FFI:CLINES
(((DOCUMENTATION . FUNCTION) . "Special Form in FFI package:
Syntax: (clines {string}*)


The ECL compiler embeds STRINGs into the intermediate C language code.  The
interpreter ignores this form.
") ((:LAMBDA-LIST) . "(clines {string}*)") ((SI:LOCATION DEFUN FFI:CLINES) #P"SRC:LSP;FFI.LSP.NEWEST" . 24343))
GRAY:CLOSE
(((SI:LOCATION DEFMETHOD GRAY:CLOSE (STREAM T) &KEY ABORT) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 11847) ((SI:LOCATION DEFMETHOD GRAY:CLOSE (STREAM SI:ANSI-STREAM) &KEY ABORT) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 11761) ((SI:LOCATION DEFMETHOD GRAY:CLOSE (STREAM GRAY:FUNDAMENTAL-STREAM) &KEY ABORT) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 11635) ((:LAMBDA-LIST) STREAM &KEY ABORT) ((SI:LOCATION DEFGENERIC GRAY:CLOSE) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 1792))
CLOSE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STREAM &KEY (ABORT NIL))

Closes STREAM.  Returns NIL if STREAM is closed successfully; non-NIL
otherwise.  A non-NIL value of ABORT indicates an abnormal termination but ECL
ignores it.
") ((:LAMBDA-LIST) STREAM &KEY (ABORT NIL)))
C::CLOSE-INLINE-BLOCKS
(((:LAMBDA-LIST) &OPTIONAL C::NEW-LINE) ((SI:LOCATION DEFUN C::CLOSE-INLINE-BLOCKS) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 6467))
SI::CLOSEST-SEQUENCE-TYPE
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN SI::CLOSEST-SEQUENCE-TYPE) #P"SRC:LSP;SEQ.LSP.NEWEST" . 1602))
CLRHASH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (HASH-TABLE)

Removes all entries of HASH-TABLE and returns HASH-TABLE.
") ((:LAMBDA-LIST) HASH-TABLE))
C::CMP-DELETE-FILE
(((:LAMBDA-LIST) C::FILE) ((SI:LOCATION DEFUN C::CMP-DELETE-FILE) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 3873))
C::CMP-ENV-ADD-DECLARATION
(((:LAMBDA-LIST) TYPE C::ARGUMENTS &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-ADD-DECLARATION) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 2152))
C::CMP-ENV-ADD-OPTIMIZATIONS
(((:LAMBDA-LIST) C::DECL &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-ADD-OPTIMIZATIONS) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 3189))
C::CMP-ENV-ALL-OPTIMIZATIONS
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-ALL-OPTIMIZATIONS) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 4027))
C::CMP-ENV-CLEANUPS
(((:LAMBDA-LIST) C::ENV) ((SI:LOCATION DEFUN C::CMP-ENV-CLEANUPS) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 1056))
C::CMP-ENV-COPY
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-COPY) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 831))
C::CMP-ENV-DECLARE-SPECIAL
(((:LAMBDA-LIST) C::NAME &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-DECLARE-SPECIAL) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 1986))
C::CMP-ENV-EXTEND-DECLARATION
(((:LAMBDA-LIST) TYPE C::ARGUMENTS &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-EXTEND-DECLARATION) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 2308))
C::CMP-ENV-FUNCTIONS
(((:LAMBDA-LIST) &OPTIONAL (C::ENV 'C::*CMP-ENV*)) ((SI:LOCATION DEFMACRO C::CMP-ENV-FUNCTIONS) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 983))
C::CMP-ENV-MARK
(((:LAMBDA-LIST) C::MARK &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-MARK) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 6156))
C::CMP-ENV-NEW-VARIABLES
(((:LAMBDA-LIST) C::NEW-ENV C::OLD-ENV) ((SI:LOCATION DEFUN C::CMP-ENV-NEW-VARIABLES) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 6265))
C::CMP-ENV-OPTIMIZATION
(((:LAMBDA-LIST) C::PROPERTY &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-OPTIMIZATION) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 4271))
C::CMP-ENV-POLICY
(((:LAMBDA-LIST) C::ENV) ((SI:LOCATION DEFUN C::CMP-ENV-POLICY) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 3074))
C::CMP-ENV-REGISTER-BLOCK
(((:LAMBDA-LIST) C::BLK &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-REGISTER-BLOCK) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 3360))
C::CMP-ENV-REGISTER-CLEANUP
(((:LAMBDA-LIST) C::FORM &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-REGISTER-CLEANUP) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 3632))
C::CMP-ENV-REGISTER-FTYPE
(((:LAMBDA-LIST) C::NAME DECLARATION &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-REGISTER-FTYPE) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 3027))
C::CMP-ENV-REGISTER-FUNCTION
(((:LAMBDA-LIST) C::FUN &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-REGISTER-FUNCTION) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 2503))
C::CMP-ENV-REGISTER-GLOBAL-MACRO
(((:LAMBDA-LIST) C::NAME FUNCTION) ((SI:LOCATION DEFUN C::CMP-ENV-REGISTER-GLOBAL-MACRO) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 2646))
C::CMP-ENV-REGISTER-MACRO
(((:LAMBDA-LIST) C::NAME FUNCTION &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-REGISTER-MACRO) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 2881))
C::CMP-ENV-REGISTER-SYMBOL-MACRO
(((:LAMBDA-LIST) C::NAME C::FORM &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-REGISTER-SYMBOL-MACRO) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 3185))
C::CMP-ENV-REGISTER-TAG
(((:LAMBDA-LIST) C::NAME C::TAG &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-REGISTER-TAG) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 3497))
C::CMP-ENV-REGISTER-VAR
(((:LAMBDA-LIST) C::VAR &OPTIONAL (C::ENV C::*CMP-ENV*) (BOUNDP T)) ((SI:LOCATION DEFUN C::CMP-ENV-REGISTER-VAR) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 1753))
C::CMP-ENV-ROOT
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV-ROOT*)) ((SI:LOCATION DEFUN C::CMP-ENV-ROOT) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 581))
C::CMP-ENV-SEARCH-BLOCK
(((:LAMBDA-LIST) C::NAME &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-SEARCH-BLOCK) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 5366))
C::CMP-ENV-SEARCH-DECLARATION
(((:LAMBDA-LIST) C::KIND &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-SEARCH-DECLARATION) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 6462))
C::CMP-ENV-SEARCH-FTYPE
(((:LAMBDA-LIST) C::NAME &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-SEARCH-FTYPE) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 5946))
C::CMP-ENV-SEARCH-FUNCTION
(((:LAMBDA-LIST) C::NAME &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-SEARCH-FUNCTION) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 3771))
C::CMP-ENV-SEARCH-MACRO
(((:LAMBDA-LIST) C::NAME &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-SEARCH-MACRO) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 5805))
C::CMP-ENV-SEARCH-SYMBOL-MACRO
(((:LAMBDA-LIST) C::NAME &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-SEARCH-SYMBOL-MACRO) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 5578))
C::CMP-ENV-SEARCH-TAG
(((:LAMBDA-LIST) C::NAME &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-SEARCH-TAG) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 5474))
C::CMP-ENV-SEARCH-VAR
(((:LAMBDA-LIST) C::NAME &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-ENV-SEARCH-VAR) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 5704))
C::CMP-ENV-SEARCH-VARIABLES
(((:LAMBDA-LIST) TYPE C::NAME C::ENV) ((SI:LOCATION DEFUN C::CMP-ENV-SEARCH-VARIABLES) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 4429))
C::CMP-ENV-VARIABLES
(((:LAMBDA-LIST) &OPTIONAL (C::ENV 'C::*CMP-ENV*)) ((SI:LOCATION DEFMACRO C::CMP-ENV-VARIABLES) #P"SRC:CMP;CMPENV-API.LSP.NEWEST" . 910))
C::CMP-EVAL
(((:LAMBDA-LIST) C::FORM &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-EVAL) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 11230))
C::CMP-EXPAND-MACRO
(((:LAMBDA-LIST) C::FD C::FORM &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::CMP-EXPAND-MACRO) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 11775))
C::CMP-MACRO-FUNCTION
(((:LAMBDA-LIST) C::NAME) ((SI:LOCATION DEFUN C::CMP-MACRO-FUNCTION) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 11679))
C::CMP-PROCESS-LAMBDA-LIST
(((:LAMBDA-LIST) LIST) ((SI:LOCATION DEFUN C::CMP-PROCESS-LAMBDA-LIST) #P"SRC:CMP;CMPLAM.LSP.NEWEST" . 4862))
C::CMPASSERT
(((:LAMBDA-LIST) CONDITION STRING &REST C::ARGS) ((SI:LOCATION DEFMACRO C::CMPASSERT) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 8096))
C::CMPCK
(((:LAMBDA-LIST) CONDITION STRING &REST C::ARGS) ((SI:LOCATION DEFMACRO C::CMPCK) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 8005))
C::CMPDEBUG
(((:LAMBDA-LIST) STRING &REST C::ARGS) ((SI:LOCATION DEFUN C::CMPDEBUG) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 9979))
C::CMPERR
(((:LAMBDA-LIST) STRING &REST C::ARGS) ((SI:LOCATION DEFUN C::CMPERR) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 8195))
C::CMPNOTE
(((:LAMBDA-LIST) STRING &REST C::ARGS) ((SI:LOCATION DEFUN C::CMPNOTE) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 9866))
C::CMPPROGRESS
(((:LAMBDA-LIST) &REST C::ARGS) ((SI:LOCATION DEFUN C::CMPPROGRESS) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 7916))
C::CMPWARN
(((:LAMBDA-LIST) STRING &REST C::ARGS) ((SI:LOCATION DEFUN C::CMPWARN) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 9750))
C::CMPWARN-STYLE
(((:LAMBDA-LIST) STRING &REST C::ARGS) ((SI:LOCATION DEFUN C::CMPWARN-STYLE) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 9622))
CODE-CHAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CODE &OPTIONAL (BITS 0) (FONT 0))

Returns a character with the specified character code, if any.  Returns NIL
if no such character exists.  BITS and FONT specify the bits and font
attributes of the returned character but are both ignored in ECL.
") ((:LAMBDA-LIST) SI::CODE &OPTIONAL (SI::BITS 0) (SI::FONT 0)))
COERCE
(((SI:LOCATION DEFINE-COMPILER-MACRO COERCE) #P"SRC:CMP;CMPOPT.LSP.NEWEST" . 10266) ((DOCUMENTATION . FUNCTION) . "Args: (x type)
Coerces X to an object of the specified type, if possible.  Signals an error
if not possible.") ((:LAMBDA-LIST) SI::OBJECT TYPE &AUX SI::AUX) ((SI:LOCATION DEFUN COERCE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 21991))
C::COERCE-LOCS
(((:LAMBDA-LIST) C::INLINED-ARGS &OPTIONAL C::TYPES C::ARGS-TO-BE-SAVED) ((SI:LOCATION DEFUN C::COERCE-LOCS) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 20476))
CLOS::COERCE-TO-CLASS
(((:LAMBDA-LIST) CLOS::CLASS-OR-SYMBOL &OPTIONAL (CLOS::FAIL NIL)) ((SI:LOCATION DEFUN CLOS::COERCE-TO-CLASS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 18583))
SI::COERCE-TO-CONDITION
(((:LAMBDA-LIST) SI::DATUM SI::ARGUMENTS SI::DEFAULT-TYPE SI::FUNCTION-NAME) ((SI:LOCATION DEFUN SI::COERCE-TO-CONDITION) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 12397))
SI::COERCE-TO-LIST
(((:LAMBDA-LIST) SI::OBJECT) ((SI:LOCATION DEFUN SI::COERCE-TO-LIST) #P"SRC:LSP;SEQ.LSP.NEWEST" . 7753))
SI::COERCE-TO-VECTOR
(((:LAMBDA-LIST) SI::OBJECT SI::ELT-TYPE LENGTH SI::SIMPLE-ARRAY-P) ((SI:LOCATION DEFUN SI::COERCE-TO-VECTOR) #P"SRC:LSP;SEQ.LSP.NEWEST" . 7990))
SI::COLLECT
(((DOCUMENTATION . FUNCTION) . "Collect ({(Name [Initial-Value] [Function])}*) {Form}*
  Collect some values somehow.  Each of the collections specifies a bunch of
  things which collected during the evaluation of the body of the form.  The
  name of the collection is used to define a local macro, a la MACROLET.
  Within the body, this macro will evaluate each of its arguments and collect
  the result, returning the current value after the collection is done.  The
  body is evaluated as a PROGN; to get the final values when you are done, just
  call the collection macro with no arguments.

  Initial-Value is the value that the collection starts out with, which
  defaults to NIL.  Function is the function which does the collection.  It is
  a function which will accept two arguments: the value to be collected and the
  current collection.  The result of the function is made the new value for the
  collection.  As a totally magical special-case, the Function may be Collect,
  which tells us to build a list in forward order; this is the default.  If an
  Initial-Value is supplied for Collect, the stuff will be rplacd'd onto the
  end.  Note that Function may be anything that can appear in the functional
  position, including macros and lambdas.") ((:LAMBDA-LIST) SI::COLLECTIONS &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::COLLECT) #P"SRC:LSP;CMUUTIL.LSP.NEWEST" . 382))
C::COLLECT-DECLARED
(((:LAMBDA-LIST) TYPE C::VAR-LIST C::TAIL) ((SI:LOCATION DEFUN C::COLLECT-DECLARED) #P"SRC:CMP;CMPENV-DECLARE.LSP.NEWEST" . 2074))
SI::COLLECT-LIST-EXPANDER
(((:LAMBDA-LIST) SI::N-VALUE SI::N-TAIL SI::FORMS) ((SI:LOCATION DEFUN SI::COLLECT-LIST-EXPANDER) #P"SRC:LSP;CMUUTIL.LSP.NEWEST" . 382))
SI::COLLECT-NORMAL-EXPANDER
(((:LAMBDA-LIST) SI::N-VALUE SI::FUN SI::FORMS) ((SI:LOCATION DEFUN SI::COLLECT-NORMAL-EXPANDER) #P"SRC:LSP;CMUUTIL.LSP.NEWEST" . 382))
CLOS::COMBINE-METHOD-FUNCTIONS
(((:LAMBDA-LIST) METHOD CLOS::REST-METHODS) ((SI:LOCATION DEFUN CLOS::COMBINE-METHOD-FUNCTIONS) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 3620))
SI::COMMAND-ARG-ERROR
(((:LAMBDA-LIST) SI::STR &REST SI::FMT-ARGS) ((SI:LOCATION DEFUN SI::COMMAND-ARG-ERROR) #P"SRC:LSP;CMDLINE.LSP.NEWEST" . 1555))
SI:COMMAND-ARGS
(((DOCUMENTATION . FUNCTION) . "Returns the command line arguments as list") ((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI:COMMAND-ARGS) #P"SRC:LSP;CMDLINE.LSP.NEWEST" . 1430))
SI::COMMON
(((DOCUMENTATION . TYPE) . "
COMMON is the type of all Common Lisp data objects."))
SI::COMMONP
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (X)

Returns T if X is a Common Lisp object; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
CLOS::COMPARE-METHODS
(((:LAMBDA-LIST) CLOS::METHOD-1 CLOS::METHOD-2 CLOS::ARGS-SPECIALIZERS CLOS::F) ((SI:LOCATION DEFUN CLOS::COMPARE-METHODS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 11653))
CLOS::COMPARE-SPECIALIZERS
(((:LAMBDA-LIST) CLOS::SPEC-1 CLOS::SPEC-2 CLOS::ARG-CLASS) ((SI:LOCATION DEFUN CLOS::COMPARE-SPECIALIZERS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 13220))
CLOS::COMPARE-SPECIALIZERS-LISTS
(((:LAMBDA-LIST) CLOS::SPEC-LIST-1 CLOS::SPEC-LIST-2 CLOS::ARGS-SPECIALIZERS) ((SI:LOCATION DEFUN CLOS::COMPARE-SPECIALIZERS-LISTS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 12039))
COMPILE
(((:LAMBDA-LIST) C::NAME &OPTIONAL (C::DEF NIL C::SUPPLIED-P) &AUX C::FORM C::DATA-PATHNAME (C:*SUPPRESS-COMPILER-MESSAGES* (OR C:*SUPPRESS-COMPILER-MESSAGES* (NOT *COMPILE-VERBOSE*))) (C::*COMPILER-IN-USE* C::*COMPILER-IN-USE*) (*STANDARD-OUTPUT* *STANDARD-OUTPUT*) (*ERROR-OUTPUT* *ERROR-OUTPUT*) (*PACKAGE* *PACKAGE*) (*COMPILE-PRINT* NIL) (*PRINT-PRETTY* NIL) (SI:*COMPILER-CONSTANTS* T)) ((SI:LOCATION DEFUN COMPILE) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 24179))
COMPILE-FILE
(((:LAMBDA-LIST) C::INPUT-PATHNAME &REST C::ARGS &KEY ((:VERBOSE *COMPILE-VERBOSE*) *COMPILE-VERBOSE*) ((:PRINT *COMPILE-PRINT*) *COMPILE-PRINT*) (C::SOURCE-TRUENAME NIL) (C::SOURCE-OFFSET 0) (C::C-FILE NIL) (C::H-FILE NIL) (C::DATA-FILE NIL) (C::SHARED-DATA-FILE NIL) (C::SYSTEM-P NIL) (LOAD NIL) (C::EXTERNAL-FORMAT :DEFAULT) C::OUTPUT-FILE &AUX (*STANDARD-OUTPUT* *STANDARD-OUTPUT*) (*ERROR-OUTPUT* *ERROR-OUTPUT*) (C::*COMPILER-IN-USE* C::*COMPILER-IN-USE*) (*PACKAGE* *PACKAGE*) (*PRINT-PRETTY* NIL) (*COMPILE-FILE-PATHNAME* NIL) (*COMPILE-FILE-TRUENAME* NIL) (SI:*SOURCE-LOCATION* (CONS C::SOURCE-TRUENAME 0)) (C:*SUPPRESS-COMPILER-MESSAGES* (OR C:*SUPPRESS-COMPILER-MESSAGES* (NOT *COMPILE-VERBOSE*))) C::INIT-NAME) ((SI:LOCATION DEFUN COMPILE-FILE) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 17364))
COMPILE-FILE-PATHNAME
(((:LAMBDA-LIST) C::NAME &KEY (C::OUTPUT-FILE T) (TYPE NIL C::TYPE-SUPPLIED-P) C::VERBOSE PRINT C::C-FILE C::H-FILE C::DATA-FILE C::SHARED-DATA-FILE C::SYSTEM-P LOAD C::EXTERNAL-FORMAT C::SOURCE-TRUENAME C::SOURCE-OFFSET) ((SI:LOCATION DEFUN COMPILE-FILE-PATHNAME) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 1594))
SI::COMPILE-IF-OLD
(((:LAMBDA-LIST) SI::DESTDIR SI::SOURCES &REST SI::OPTIONS) ((SI:LOCATION DEFUN SI::COMPILE-IF-OLD) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/build/bare.lsp" . 3717))
COMPILED-FUNCTION
(((DOCUMENTATION . TYPE) . "
A compiled function is an object that is created by compiling a function.  A
compiled function is notated in either of the following formats:
	#<compiled-function s>
	#<compiled-closure nil>
where S is actually the symbol that names the function."))
SI:COMPILED-FUNCTION-NAME
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (COMPILED-FUNCTION)

ECL specific.
Returns the function name associated with COMPILED-FUNCTION.
") ((:LAMBDA-LIST) COMPILED-FUNCTION))
COMPILED-FUNCTION-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a compiled function object; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
C::COMPILER-CC
(((:LAMBDA-LIST) C::C-PATHNAME C::O-PATHNAME) ((SI:LOCATION DEFUN C::COMPILER-CC) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 33086))
SI::COMPILER-CLEAR-COMPILER-PROPERTIES
(((:LAMBDA-LIST) SYMBOL) ((SI:LOCATION DEFUN SI::COMPILER-CLEAR-COMPILER-PROPERTIES) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 12196))
C::COMPILER-DEBUG-NOTE
(((SI:LOCATION DEFCLASS C::COMPILER-DEBUG-NOTE) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 3768))
C:COMPILER-ERROR
(((SI:LOCATION DEFCLASS C:COMPILER-ERROR) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 3983))
C:COMPILER-FATAL-ERROR
(((SI:LOCATION DEFCLASS C:COMPILER-FATAL-ERROR) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 4105))
C:COMPILER-INTERNAL-ERROR
(((SI:LOCATION DEFCLASS C:COMPILER-INTERNAL-ERROR) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 4203))
SI:COMPILER-LET
(((DOCUMENTATION . FUNCTION) . "Special Form in SI package:
Syntax: (compiler-let ({var | (var [value])}*) {form}*)

When interpreted, this form works just like a LET form with all VARs declared
special.  When compiled, FORMs are processed with the VARs bound at compile
time, but no bindings occur when the compiled code is executed.
") ((:LAMBDA-LIST) . "(compiler-let ({var | (var [value])}*) {form}*)"))
COMPILER-MACRO-FUNCTION
(((:LAMBDA-LIST) SI::NAME &OPTIONAL SI::ENV) ((SI:LOCATION DEFUN COMPILER-MACRO-FUNCTION) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 4628))
C:COMPILER-MESSAGE
(((SI:LOCATION DEFCLASS C:COMPILER-MESSAGE) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 2899))
C::COMPILER-MESSAGE-REPORT
(((:LAMBDA-LIST) STREAM C::C C::FORMAT-CONTROL &REST C::FORMAT-ARGUMENTS) ((SI:LOCATION DEFUN C::COMPILER-MESSAGE-REPORT) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 1902))
C:COMPILER-NOTE
(((SI:LOCATION DEFCLASS C:COMPILER-NOTE) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 3712))
C::COMPILER-OUTPUT-VALUES
(((:LAMBDA-LIST) C::MAIN-VALUE C::CONDITIONS) ((SI:LOCATION DEFUN C::COMPILER-OUTPUT-VALUES) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 23578))
C::COMPILER-PASS2
(((:LAMBDA-LIST) C::C-PATHNAME C::H-PATHNAME C::DATA-PATHNAME C::SYSTEM-P C::INIT-NAME C::SHARED-DATA &KEY C::INPUT-DESIGNATOR) ((SI:LOCATION DEFUN C::COMPILER-PASS2) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 31123))
C::COMPILER-PUSH-EVENTS
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::COMPILER-PUSH-EVENTS) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 12102))
C::COMPILER-STYLE-WARNING
(((SI:LOCATION DEFCLASS C::COMPILER-STYLE-WARNING) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 4310))
C:COMPILER-UNDEFINED-VARIABLE
(((SI:LOCATION DEFCLASS C:COMPILER-UNDEFINED-VARIABLE) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 4461))
C:COMPILER-WARNING
(((SI:LOCATION DEFCLASS C:COMPILER-WARNING) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 3827))
COMPLEMENT
(((DOCUMENTATION . FUNCTION) . "Args: (f)
Returns a new function which first applies F to its arguments and then negates
the output") ((:LAMBDA-LIST) SI::F) ((SI:LOCATION DEFUN COMPLEMENT) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 37836))
COMPLEX
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (REALPART &OPTIONAL (IMAGPART 0))

Returns a complex number with the given realpart and imagpart.  Returns
REALPART if it is a rational and IMAGPART is 0.
") ((:LAMBDA-LIST) REALPART &OPTIONAL (IMAGPART 0)) ((DOCUMENTATION . TYPE) . "
A complex number represents a complex number in mathematical sense, consisting
of a real part and an imaginary part.  A complex number is notated as
	#c( realpart  imagpart )  or  #C( realpart  imagpart )
where REALPART and IMAGPART are non-complex numbers."))
SI::COMPLEX-ACOS
(((:LAMBDA-LIST) SI::Z) ((SI:LOCATION DEFUN SI::COMPLEX-ACOS) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 6255))
SI::COMPLEX-ACOSH
(((:LAMBDA-LIST) SI::Z) ((SI:LOCATION DEFUN SI::COMPLEX-ACOSH) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 7907))
SI::COMPLEX-ARRAY-P
(((:LAMBDA-LIST) SI::X) ((SI:LOCATION DEFUN SI::COMPLEX-ARRAY-P) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 10600))
SI::COMPLEX-ASIN
(((:LAMBDA-LIST) SI::Z) ((SI:LOCATION DEFUN SI::COMPLEX-ASIN) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 5637))
SI::COMPLEX-ATANH
(((:LAMBDA-LIST) SI::Z) ((SI:LOCATION DEFUN SI::COMPLEX-ATANH) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 8574))
COMPLEXP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a complex number; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
COMPUTE-APPLICABLE-METHODS
(((:LAMBDA-LIST) CLOS::GF CLOS::ARGS) ((SI:LOCATION DEFUN COMPUTE-APPLICABLE-METHODS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 9667))
C::COMPUTE-C1FORM-TYPE
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::COMPUTE-C1FORM-TYPE) #P"SRC:CMP;CMPOPT-TYPE.LSP.NEWEST" . 553))
CLOS:COMPUTE-CLASS-PRECEDENCE-LIST
(((SI:LOCATION DEFMETHOD CLOS:COMPUTE-CLASS-PRECEDENCE-LIST (CLASS CLASS)) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 13746))
CLOS::COMPUTE-CLOS-CLASS-PRECEDENCE-LIST
(((:LAMBDA-LIST) CLOS::NEW-CLASS CLOS::SUPERCLASSES) ((SI:LOCATION DEFUN CLOS::COMPUTE-CLOS-CLASS-PRECEDENCE-LIST) #P"SRC:CLOS;DEFCLASS.LSP.NEWEST" . 7141))
CLOS:COMPUTE-DEFAULT-INITARGS
(((SI:LOCATION DEFMETHOD CLOS:COMPUTE-DEFAULT-INITARGS (CLASS CLASS)) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 17444))
CLOS:COMPUTE-EFFECTIVE-METHOD
(((:LAMBDA-LIST) CLOS::GF METHOD-COMBINATION CLOS::APPLICABLE-METHODS) ((SI:LOCATION DEFUN CLOS:COMPUTE-EFFECTIVE-METHOD) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 11707))
CLOS:COMPUTE-EFFECTIVE-SLOT-DEFINITION
(((SI:LOCATION DEFMETHOD CLOS:COMPUTE-EFFECTIVE-SLOT-DEFINITION (CLASS CLASS) CLOS::NAME CLOS::DIRECT-SLOTS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 15412))
C::COMPUTE-FUN-CLOSURE-TYPE
(((:LAMBDA-LIST) C::FUN) ((SI:LOCATION DEFUN C::COMPUTE-FUN-CLOSURE-TYPE) #P"SRC:CMP;CMPFLET.LSP.NEWEST" . 3333))
CLOS::COMPUTE-G-F-SPEC-LIST
(((:LAMBDA-LIST) CLOS::GF) ((SI:LOCATION DEFUN CLOS::COMPUTE-G-F-SPEC-LIST) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 13786))
C::COMPUTE-INIT-NAME
(((:LAMBDA-LIST) PATHNAME &KEY (C::KIND (C::GUESS-KIND PATHNAME))) ((SI:LOCATION DEFUN C::COMPUTE-INIT-NAME) #P"SRC:CMP;CMPNAME.LSP.NEWEST" . 3742))
CLOS::COMPUTE-INSTANCE-SIZE
(((:LAMBDA-LIST) CLOS::SLOTS) ((SI:LOCATION DEFUN CLOS::COMPUTE-INSTANCE-SIZE) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 3180))
C::COMPUTE-POLICY
(((:LAMBDA-LIST) C::ARGUMENTS C::OLD-BITS) ((SI:LOCATION DEFUN C::COMPUTE-POLICY) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 1907))
SI::COMPUTE-RESTART-COMMANDS
(((:LAMBDA-LIST) CONDITION &KEY SI::DISPLAY) ((SI:LOCATION DEFUN SI::COMPUTE-RESTART-COMMANDS) #P"SRC:LSP;TOP.LSP.NEWEST" . 45510))
COMPUTE-RESTARTS
(((:LAMBDA-LIST) &OPTIONAL CONDITION) ((SI:LOCATION DEFUN COMPUTE-RESTARTS) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 1271))
CLOS:COMPUTE-SLOTS
(((SI:LOCATION DEFMETHOD CLOS:COMPUTE-SLOTS :AROUND (CLASS CLOS::STD-CLASS)) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 22148) ((SI:LOCATION DEFMETHOD CLOS:COMPUTE-SLOTS :AROUND (CLASS CLASS)) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 21022) ((SI:LOCATION DEFMETHOD CLOS:COMPUTE-SLOTS (CLASS CLASS)) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 13884))
SI::COMPUTE-TAB-SIZE
(((:LAMBDA-LIST) SI::TAB SI::SECTION-START SI::COLUMN) ((SI:LOCATION DEFUN SI::COMPUTE-TAB-SIZE) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 14291))
CONCATENATE
(((DOCUMENTATION . FUNCTION) . "Args: (type &rest sequences)
Returns a new sequence of the specified type, consisting of all elements of
SEQUENCEs.") ((:LAMBDA-LIST) SI::RESULT-TYPE &REST SI::SEQUENCES) ((SI:LOCATION DEFUN CONCATENATE) #P"SRC:LSP;SEQ.LSP.NEWEST" . 8735))
COND
(((DOCUMENTATION . FUNCTION) . "Syntax: (cond {(test {form}*)}*)
Evaluates TESTs in order until one evaluates to non-NIL.  Then evaluates FORMs
in order that follow the TEST and returns all values of the last FORM.  If no
forms follow the TEST, then returns the value of the TEST.  Returns NIL, if no
TESTs evaluates to non-NIL.") ((:LAMBDA-LIST) &REST SI::CLAUSES &AUX (SI::FORM NIL)) ((SI:LOCATION DEFMACRO COND) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 6295))
CONDITION
(((SI:LOCATION DEFCLASS CONDITION) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 7214))
CLOS::CONGRUENT-LAMBDA-P
(((:LAMBDA-LIST) CLOS::L1 CLOS::L2) ((SI:LOCATION DEFUN CLOS::CONGRUENT-LAMBDA-P) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 4546))
CONJUGATE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER)

Returns the complex conjugate of NUMBER.  Returns NUMBER if it is not a
complex number.
") ((:LAMBDA-LIST) NUMBER))
CONS
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X Y)

Returns a new cons whose car and cdr are X and Y respectively.
") ((:LAMBDA-LIST) SI::X SI::Y) ((DOCUMENTATION . TYPE) . "
A cons is a compound object consisting of two components car and cdr.") ((SI:LOCATION DEFINE-COMPILER-MACRO CONS) #P"SRC:CMP;CMPOPT-CONS.LSP.NEWEST" . 1797))
C::CONS-CAR
(((:LAMBDA-LIST) C::X) ((SI:LOCATION DEFMACRO C::CONS-CAR) #P"SRC:CMP;CMPOPT-CONS.LSP.NEWEST" . 1472))
C::CONS-CDR
(((:LAMBDA-LIST) C::X) ((SI:LOCATION DEFMACRO C::CONS-CDR) #P"SRC:CMP;CMPOPT-CONS.LSP.NEWEST" . 1605))
SI::CONS-TYPE-SPECIFIER-P
(((:LAMBDA-LIST) SI::SPEC) ((SI:LOCATION DEFUN SI::CONS-TYPE-SPECIFIER-P) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 39169))
CONSP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a cons; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
C::CONSTANT-EXPRESSION-P
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::CONSTANT-EXPRESSION-P) #P"SRC:CMP;CMPOPT-CONSTANT.LSP.NEWEST" . 533))
C::CONSTANT-FUNCTION-EXPRESSION
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::CONSTANT-FUNCTION-EXPRESSION) #P"SRC:CMP;CMPOPT-SEQUENCE.LSP.NEWEST" . 540))
CONSTANTLY
(((DOCUMENTATION . FUNCTION) . "Args: (n)
Builds a new function which accepts any number of arguments but always outputs N.") ((:LAMBDA-LIST) SI::N) ((SI:LOCATION DEFUN CONSTANTLY) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 717))
SI:CONSTANTLY-NIL
(((:LAMBDA-LIST) &REST SI::FOO) ((SI:LOCATION DEFUN SI:CONSTANTLY-NIL) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 650))
SI:CONSTANTLY-T
(((:LAMBDA-LIST) &REST SI::FOO) ((SI:LOCATION DEFUN SI:CONSTANTLY-T) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 587))
CONSTANTP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if ECL is sure that X, when given as a form, always evaluates to a
same value.  Returns NIL otherwise.  Typically used to check whether a symbol
names a constant variable.
") ((:LAMBDA-LIST) SI::X))
CONTINUE
(((:LAMBDA-LIST) &OPTIONAL SI::C) ((SI:LOCATION DEFUN CONTINUE) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 24164))
CONTROL-ERROR
(((SI:LOCATION DEFCLASS CONTROL-ERROR) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
FFI:CONVERT-FROM-CSTRING
(((:LAMBDA-LIST) FFI:OBJECT) ((SI:LOCATION DEFMACRO FFI:CONVERT-FROM-CSTRING) #P"SRC:LSP;FFI.LSP.NEWEST" . 13144))
FFI:CONVERT-FROM-FOREIGN-STRING
(((:LAMBDA-LIST) FFI::FOREIGN-STRING &KEY LENGTH (FFI::NULL-TERMINATED-P T)) ((SI:LOCATION DEFUN FFI:CONVERT-FROM-FOREIGN-STRING) #P"SRC:LSP;FFI.LSP.NEWEST" . 13997))
CLOS::CONVERT-ONE-CLASS
(((:LAMBDA-LIST) CLASS) ((SI:LOCATION DEFUN CLOS::CONVERT-ONE-CLASS) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 982))
FFI:CONVERT-TO-CSTRING
(((:LAMBDA-LIST) FFI:OBJECT) ((SI:LOCATION DEFMACRO FFI:CONVERT-TO-CSTRING) #P"SRC:LSP;FFI.LSP.NEWEST" . 13195))
FFI:CONVERT-TO-FOREIGN-STRING
(((:LAMBDA-LIST) FFI::STRING-DESIGNATOR) ((SI:LOCATION DEFUN FFI:CONVERT-TO-FOREIGN-STRING) #P"SRC:LSP;FFI.LSP.NEWEST" . 14553))
COPY-ALIST
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ALIST)

Returns a new list consisting of copies of all pairs in ALIST.
") ((:LAMBDA-LIST) SI::ALIST))
SI::COPY-ARRAY-CONTENTS
(((:LAMBDA-LIST) SI::DEST SI::ORIG) ((SI:LOCATION DEFUN SI::COPY-ARRAY-CONTENTS) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 13486))
C::COPY-C1FORM
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::COPY-C1FORM) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 6589))
COPY-LIST
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (LIST)

Returns a new list consisting of all elements in LIST.
") ((:LAMBDA-LIST) LIST))
COPY-PPRINT-DISPATCH
(((:LAMBDA-LIST) &OPTIONAL (SI::TABLE *PRINT-PPRINT-DISPATCH*)) ((SI:LOCATION DEFUN COPY-PPRINT-DISPATCH) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 39917))
COPY-READTABLE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&OPTIONAL (READTABLE *READTABLE*) (TO-READTABLE NIL))

Returns a new copy of READTABLE.  If TO-READTABLE is non-NIL, then copies the
contents of READTABLE into TO-READTABLE and returns TO-READTABLE.
") ((:LAMBDA-LIST) &OPTIONAL (READTABLE *READTABLE*) (SI::TO-READTABLE NIL)))
COPY-SEQ
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SEQUENCE)

Returns a new copy of SEQUENCE.
") ((:LAMBDA-LIST) SEQUENCE))
COPY-SYMBOL
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL &OPTIONAL (FLAG NIL))

Returns a new uninterned symbol with the same print name as SYMBOL.  If FLAG
is NIL, the symbol property of the new symbol is empty.  Otherwise, the new
symbol gets a copy of the property list of SYMBOL.
") ((:LAMBDA-LIST) SYMBOL &OPTIONAL (SI::FLAG NIL)))
COPY-TREE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (TREE)

Returns a copy of TREE.  Defined as:
	(defun copy-tree (tree)
	  (if (atom tree)
	      tree
	      (cons (copy-tree (car tree)) (copy-tree (cdr tree)))))
") ((:LAMBDA-LIST) SI::TREE))
C::COPY-TYPE-PROPAGATOR
(((:LAMBDA-LIST) C::ORIG C::DEST-LIST) ((SI:LOCATION DEFUN C::COPY-TYPE-PROPAGATOR) #P"SRC:CMP;CMPTYPE-PROP.LSP.NEWEST" . 3084))
COS
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (RADIANS)

Returns the cosine of RADIANS.
") ((:LAMBDA-LIST) SI::RADIANS))
COSH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER)

Returns the hyperbolic cosine of NUMBER.
") ((:LAMBDA-LIST) NUMBER))
COUNT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ITEM SEQUENCE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT (START 0) (END (LENGTH SEQUENCE)) (FROM-END NIL))

Returns the number of elements in SEQUENCE satisfying TEST with ITEM as the
first argument.
") ((:LAMBDA-LIST) SI::ITEM SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::TEST '#'EQL) SI::TEST-NOT (SI::START 0) (SI::END (LENGTH SEQUENCE)) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN COUNT) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 13356))
COUNT-IF
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (FROM-END NIL))

Returns the number of elements in SEQUENCE satisfying TEST.
") ((:LAMBDA-LIST) SI::TEST SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::START 0) (SI::END (LENGTH SEQUENCE)) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN COUNT-IF) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 14147))
COUNT-IF-NOT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (TEST SEQUENCE (START 0) (END (LENGTH SEQUENCE)) (FROM-END NIL))

Returns the number of elements in SEQUENCE not satisfying TEST.
") ((:LAMBDA-LIST) SI::TEST SEQUENCE (SI::START 0) (SI::END (LENGTH SEQUENCE)) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN COUNT-IF-NOT) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 14350))
CLOS::CREATE-ACCESSORS
(((:LAMBDA-LIST) CLOS::SLOTDS TYPE) ((SI:LOCATION DEFUN CLOS::CREATE-ACCESSORS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 1201))
SI:CREATE-TYPE-NAME
(((:LAMBDA-LIST) SI::NAME) ((SI:LOCATION DEFUN SI:CREATE-TYPE-NAME) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 1261))
C::CTOP-WRITE
(((:LAMBDA-LIST) C::NAME C::H-PATHNAME C::DATA-PATHNAME &KEY C::SHARED-DATA &AUX C::DEF C::TOP-OUTPUT-STRING (C::*VOLATILE* " volatile ")) ((SI:LOCATION DEFUN C::CTOP-WRITE) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 3683))
CTYPECASE
(((DOCUMENTATION . FUNCTION) . "Syntax: (ctypecase place {(type {form}*)}*)
Searches a TYPE to which the value of PLACE belongs.  If found, then evaluates
FORMs that follow the TYPE and returns all values of the last FORM.  If no
such TYPE is found, signals a continuable error.  Before continuing, receives
a new value of PLACE from the user and searches an appropriate TYPE again.
Repeats this process until the value of PLACE becomes of one of the TYPEs.") ((:LAMBDA-LIST) SI::KEYPLACE &REST SI::CLAUSES &AUX (SI::KEY (GENSYM))) ((SI:LOCATION DEFMACRO CTYPECASE) #P"SRC:LSP;ASSERT.LSP.NEWEST" . 7952))
SI::CTYPECASE-ERROR
(((:LAMBDA-LIST) SI::KEYPLACE SI::VALUE SI::TYPES) ((SI:LOCATION DEFUN SI::CTYPECASE-ERROR) #P"SRC:LSP;ASSERT.LSP.NEWEST" . 7552))
C::DATA-DUMP
(((:LAMBDA-LIST) STREAM &KEY C::AS-LISP-FILE C::INIT-NAME &AUX C::MUST-CLOSE) ((SI:LOCATION DEFUN C::DATA-DUMP) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 2471))
C::DATA-EMPTY-LOC
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::DATA-EMPTY-LOC) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 4522))
C::DATA-GET-ALL-OBJECTS
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::DATA-GET-ALL-OBJECTS) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 1635))
C::DATA-INIT
(((:LAMBDA-LIST) &OPTIONAL C::FILENAME) ((SI:LOCATION DEFUN C::DATA-INIT) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 1272))
C::DATA-PERMANENT-STORAGE-SIZE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::DATA-PERMANENT-STORAGE-SIZE) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 1037))
C::DATA-SIZE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::DATA-SIZE) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 1179))
C::DATA-TEMPORARY-STORAGE-SIZE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::DATA-TEMPORARY-STORAGE-SIZE) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 1108))
SI::DAYLIGHT-SAVING-TIME-P
(((DOCUMENTATION . FUNCTION) . "Returns T if Daylight Saving Time applies to the local time zone at
Universal Time UT, which defaults to the current time.") ((:LAMBDA-LIST) SI::UNIVERSAL-TIME SI::YEAR) ((SI:LOCATION DEFUN SI::DAYLIGHT-SAVING-TIME-P) #P"SRC:LSP;MISLIB.LSP.NEWEST" . 7415))
DECF
(((DOCUMENTATION . FUNCTION) . "Syntax: (decf place [form])
Decrements the value of PLACE by the value of FORM.  FORM defaults to 1.") ((:LAMBDA-LIST) &ENVIRONMENT SI::ENV SI::%REFERENCE &OPTIONAL (SI::DELTA 1)) ((SI:LOCATION DEFMACRO DECF) #P"SRC:LSP;SETF.LSP.NEWEST" . 23676))
SI::DECIMAL-STRING
(((:LAMBDA-LIST) SI::N) ((SI:LOCATION DEFUN SI::DECIMAL-STRING) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 41795))
DECLAIM
(((:LAMBDA-LIST) &REST C::DECLARATIONS) ((SI:LOCATION DEFMACRO DECLAIM) #P"SRC:CMP;CMPENV-DECLAIM.LSP.NEWEST" . 1908))
CLOS::DECLARATION-SPECIALIZERS
(((:LAMBDA-LIST) CLOS::ARGLIST CLOS::DECLARATIONS) ((SI:LOCATION DEFUN CLOS::DECLARATION-SPECIALIZERS) #P"SRC:CLOS;METHOD.LSP.NEWEST" . 9552))
DECLARE
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (declare {decl-spec}*)

Gives declarations.  Possible DECL-SPECs are:
  (SPECIAL {var}*)
  (TYPE type {var}*)
  (type {var}*) where 'type' is one of the following symbols
	array		fixnum		package		simple-string
	atom		float		pathname	simple-vector
	bignum		function	random-state	single-float
	bit		hash-table	ratio		standard-char
	bit-vector	integer		rational	stream
	character	keyword		readtable	string
	common		list		sequence	string-char
	compiled-function  long-float	short-float	symbol
	complex		nil		signed-byte	t
	cons		null		simple-array	unsigned-byte
	double-float	number		simple-bit-vector  vector
  (OBJECT {var}*)
  (FTYPE type {function-name}*)
  (FUNCTION function-name ({arg-type}*) {return-type}*)
  (INLINE {function-name}*)
  (NOTINLINE {function-name}*)
  (IGNORE {var}*)
  (OPTIMIZE {({SPEED | SPACE | SAFETY | COMPILATION-SPEED} {0 | 1 | 2 | 3})}*)
  (DECLARATION {non-standard-decl-name}*)
  (:READ-ONLY {variable-name}*).
") ((:LAMBDA-LIST) . "(declare {decl-spec}*)"))
C::DECLARE-INLINE
(((:LAMBDA-LIST) C::FNAME-LIST &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::DECLARE-INLINE) #P"SRC:CMP;CMPENV-FUN.LSP.NEWEST" . 4580))
C::DECLARE-NOTINLINE
(((:LAMBDA-LIST) C::FNAME-LIST &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::DECLARE-NOTINLINE) #P"SRC:CMP;CMPENV-FUN.LSP.NEWEST" . 4942))
DECODE-FLOAT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FLOAT)

Returns the significand F, the exponent E, and the sign S of FLOAT.  These
values satisfy
	1/B <= F < 1
and			 E
	FLOAT = S * F * B
where B is the radix used to represent FLOAT.  S and F are floats of the same
float format as FLOAT, and E is an integer.
") ((:LAMBDA-LIST) FLOAT))
SI::DECODE-IHS-ENV
(((:LAMBDA-LIST) SI::*BREAK-ENV*) ((SI:LOCATION DEFUN SI::DECODE-IHS-ENV) #P"SRC:LSP;TOP.LSP.NEWEST" . 31544))
DECODE-UNIVERSAL-TIME
(((DOCUMENTATION . FUNCTION) . "Args: (integer &optional (timezone (si::get-local-time-zone)))
Returns as nine values the day-and-time represented by INTEGER.  See GET-
DECODED-TIME.") ((:LAMBDA-LIST) SI::ORIG-UT &OPTIONAL (SI::TZ NIL SI::TZ-P) &AUX (SI::DSTP NIL)) ((SI:LOCATION DEFUN DECODE-UNIVERSAL-TIME) #P"SRC:LSP;MISLIB.LSP.NEWEST" . 5095))
FFI:DEF-ARRAY-POINTER
(((:LAMBDA-LIST) FFI::NAME FFI::ELEMENT-TYPE) ((SI:LOCATION DEFMACRO FFI:DEF-ARRAY-POINTER) #P"SRC:LSP;FFI.LSP.NEWEST" . 8560))
SI::DEF-COMPLEX-FORMAT-DIRECTIVE
(((:LAMBDA-LIST) CHAR SI::LAMBDA-LIST &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::DEF-COMPLEX-FORMAT-DIRECTIVE) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 21402))
SI::DEF-COMPLEX-FORMAT-INTERPRETER
(((:LAMBDA-LIST) CHAR SI::LAMBDA-LIST &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::DEF-COMPLEX-FORMAT-INTERPRETER) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 21402))
FFI:DEF-CONSTANT
(((DOCUMENTATION . FUNCTION) . "Macro to define a constant and to export it") ((:LAMBDA-LIST) FFI::NAME FFI::VALUE &KEY (EXPORT NIL)) ((SI:LOCATION DEFMACRO FFI:DEF-CONSTANT) #P"SRC:LSP;FFI.LSP.NEWEST" . 1815))
FFI:DEF-ENUM
(((:LAMBDA-LIST) FFI::NAME VALUES-LIST &KEY (FFI::SEPARATOR-STRING "#")) ((SI:LOCATION DEFMACRO FFI:DEF-ENUM) #P"SRC:LSP;FFI.LSP.NEWEST" . 5354))
FFI:DEF-FOREIGN-TYPE
(((:LAMBDA-LIST) FFI::NAME FFI::DEFINITION) ((SI:LOCATION DEFMACRO FFI:DEF-FOREIGN-TYPE) #P"SRC:LSP;FFI.LSP.NEWEST" . 2241))
FFI:DEF-FOREIGN-VAR
(((:LAMBDA-LIST) FFI::NAME TYPE FFI::MODULE) ((SI:LOCATION DEFMACRO FFI:DEF-FOREIGN-VAR) #P"SRC:LSP;FFI.LSP.NEWEST" . 19537))
SI::DEF-FORMAT-DIRECTIVE
(((:LAMBDA-LIST) CHAR SI::LAMBDA-LIST &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::DEF-FORMAT-DIRECTIVE) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 21402))
SI::DEF-FORMAT-INTERPRETER
(((:LAMBDA-LIST) CHAR SI::LAMBDA-LIST &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::DEF-FORMAT-INTERPRETER) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 21402))
FFI:DEF-FUNCTION
(((:LAMBDA-LIST) FFI::NAME FFI::ARGS &KEY FFI::MODULE (FFI::RETURNING :VOID) (FFI::CALL :CDECL)) ((SI:LOCATION DEFMACRO FFI:DEF-FUNCTION) #P"SRC:LSP;FFI.LSP.NEWEST" . 18357))
C::DEF-INLINE
(((:LAMBDA-LIST) C::NAME SAFETY C::ARG-TYPES C::RETURN-REP-TYPE C::EXPANSION &KEY (C::ONE-LINER T) (C::EXACT-RETURN-TYPE NIL) (C::INLINE-OR-WARN NIL) &AUX C::ARG-REP-TYPES) ((SI:LOCATION DEFUN C::DEF-INLINE) #P"SRC:CMP;SYSFUN.LSP.NEWEST" . 956))
FFI:DEF-STRUCT
(((:LAMBDA-LIST) FFI::NAME &REST FFI::SLOTS) ((SI:LOCATION DEFMACRO FFI:DEF-STRUCT) #P"SRC:LSP;FFI.LSP.NEWEST" . 6407))
FFI:DEF-TYPE
(((:LAMBDA-LIST) FFI::NAME FFI::DEFINITION) ((SI:LOCATION DEFMACRO FFI:DEF-TYPE) #P"SRC:LSP;FFI.LSP.NEWEST" . 2406))
C::DEF-TYPE-PROPAGATOR
(((:LAMBDA-LIST) C::FNAME C::LAMBDA-LIST &BODY C::BODY) ((SI:LOCATION DEFMACRO C::DEF-TYPE-PROPAGATOR) #P"SRC:CMP;CMPTYPE-PROP.LSP.NEWEST" . 2745))
FFI:DEF-UNION
(((:LAMBDA-LIST) FFI::NAME &REST FFI::SLOTS) ((SI:LOCATION DEFMACRO FFI:DEF-UNION) #P"SRC:LSP;FFI.LSP.NEWEST" . 10591))
C::DEFAULT-C-INLINER
(((:LAMBDA-LIST) C::FNAME C::RETURN-TYPE C::INLINED-ARGS) ((SI:LOCATION DEFUN C::DEFAULT-C-INLINER) #P"SRC:CMP;CMPC-INLINER.LSP.NEWEST" . 1140))
SI::DEFAULT-DEBUGGER
(((:LAMBDA-LIST) CONDITION) ((SI:LOCATION DEFUN SI::DEFAULT-DEBUGGER) #P"SRC:LSP;TOP.LSP.NEWEST" . 48309))
C::DEFAULT-INIT
(((:LAMBDA-LIST) C::VAR &OPTIONAL WARN) ((SI:LOCATION DEFUN C::DEFAULT-INIT) #P"SRC:CMP;CMPTYPE.LSP.NEWEST" . 1147))
SI::DEFAULT-LINE-LENGTH
(((SI:LOCATION DEFCONSTANT SI::DEFAULT-LINE-LENGTH) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 989))
C::DEFAULT-POLICY
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::DEFAULT-POLICY) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 2875))
SI::DEFAULT-PPRINT-DISPATCH
(((:LAMBDA-LIST) STREAM SI::OBJECT) ((SI:LOCATION DEFUN SI::DEFAULT-PPRINT-DISPATCH) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 40455))
FFI:DEFCALLBACK
(((:LAMBDA-LIST) &REST FFI::ARGS) ((SI:LOCATION DEFMACRO FFI:DEFCALLBACK) #P"SRC:LSP;FFI.LSP.NEWEST" . 23343))
FFI:DEFCBODY
(((DOCUMENTATION . FUNCTION) . "Syntax: (defcbody symbol (&rest arg-types) result-type &body body)") ((:LAMBDA-LIST) FFI::NAME FFI::ARG-TYPES FFI::RESULT-TYPE FFI::C-EXPR) ((SI:LOCATION DEFMACRO FFI:DEFCBODY) #P"SRC:LSP;FFI.LSP.NEWEST" . 25634))
DEFCLASS
(((:LAMBDA-LIST) &WHOLE CLOS::FORM &REST CLOS::ARGS) ((SI:LOCATION DEFMACRO DEFCLASS) #P"SRC:CLOS;DEFCLASS.LSP.NEWEST" . 1654))
DEFCONSTANT
(((DOCUMENTATION . FUNCTION) . "Syntax: (defconstant symbol form [doc])

Declares that the global variable named by SYMBOL is a constant with the value
of FORM as its constant value.  The doc-string DOC, if supplied, is saved as a
VARIABLE doc and can be retrieved by (DOCUMENTATION 'SYMBOL 'VARIABLE).") ((:LAMBDA-LIST) &WHOLE SI::WHOLE SI::VAR SI::FORM &OPTIONAL SI::DOC-STRING) ((SI:LOCATION DEFMACRO DEFCONSTANT) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 3403))
FFI:DEFENTRY
(((DOCUMENTATION . FUNCTION) . "Syntax: (defentry symbol (&rest arg-types*) (result-type function-name))

The compiler defines a Lisp function named by SYMBOL whose body consists of a
calling sequence to the C language function named by FUNCTION-NAME.  The
interpreter ignores this form.  ARG-TYPEs are argument types of the C function
and VALUE-TYPE is the return type of the C function.  Symbols OBJECT, INT,
CHAR, CHAR*, FLOAT, DOUBLE are allowed for these types.") ((:LAMBDA-LIST) FFI::NAME FFI::ARG-TYPES FFI::C-NAME &KEY FFI::NO-INTERRUPTS) ((SI:LOCATION DEFMACRO FFI:DEFENTRY) #P"SRC:LSP;FFI.LSP.NEWEST" . 26246))
DEFGENERIC
(((:LAMBDA-LIST) &WHOLE CLOS::WHOLE &REST CLOS::ARGS) ((SI:LOCATION DEFMACRO DEFGENERIC) #P"SRC:CLOS;GENERIC.LSP.NEWEST" . 566))
C::DEFINE-C-INLINER
(((:LAMBDA-LIST) C::FNAME C::LAMBDA-LIST &BODY C::BODY) ((SI:LOCATION DEFMACRO C::DEFINE-C-INLINER) #P"SRC:CMP;CMPC-INLINER.LSP.NEWEST" . 769))
DEFINE-COMPILER-MACRO
(((:LAMBDA-LIST) &WHOLE SI::WHOLE SI::NAME SI::VL &REST SI::BODY) ((SI:LOCATION DEFMACRO DEFINE-COMPILER-MACRO) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 4122))
CLOS::DEFINE-COMPLEX-METHOD-COMBINATION
(((:LAMBDA-LIST) CLOS::FORM) ((SI:LOCATION DEFUN CLOS::DEFINE-COMPLEX-METHOD-COMBINATION) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 8608))
DEFINE-CONDITION
(((:LAMBDA-LIST) SI::NAME SI::PARENT-LIST SI::SLOT-SPECS &REST SI::OPTIONS) ((SI:LOCATION DEFMACRO DEFINE-CONDITION) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 7242))
SI::DEFINE-INLINE-FUNCTION
(((:LAMBDA-LIST) C::NAME C::VARS &BODY C::BODY) ((SI:LOCATION DEFMACRO SI::DEFINE-INLINE-FUNCTION) #P"SRC:CMP;CMPEVAL.LSP.NEWEST" . 5556))
DEFINE-METHOD-COMBINATION
(((:LAMBDA-LIST) CLOS::NAME &BODY CLOS::BODY) ((SI:LOCATION DEFMACRO DEFINE-METHOD-COMBINATION) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 11025))
DEFINE-MODIFY-MACRO
(((DOCUMENTATION . FUNCTION) . "Syntax: (define-modify-macro symbol lambda-list function-name [doc])
Defines a read-modify-write macro like INCF.  The defined macro will expand
a form (SYMBOL place form1 ... formn) into a form that in effect SETFs the
value of (FUNCTION-NAME place arg1 ... argm) into PLACE, where ARG1 ... ARGm
are parameters in LAMBDA-LIST which are bound to FORM1 ... FORMn.  For
example, INCF could be defined as
	(define-modify-macro incf (&optional (x 1)) +)
The doc-string DOC, if supplied, is saved as a FUNCTION doc and can be
retrieved by (DOCUMENTATION 'SYMBOL 'FUNCTION).") ((:LAMBDA-LIST) SI::NAME SI::LAMBDALIST FUNCTION &OPTIONAL SI::DOCSTRING) ((SI:LOCATION DEFMACRO DEFINE-MODIFY-MACRO) #P"SRC:LSP;SETF.LSP.NEWEST" . 18888))
C::DEFINE-POLICY
(((:LAMBDA-LIST) &WHOLE C::WHOLE C::NAME &REST C::CONDITIONS) ((SI:LOCATION DEFMACRO C::DEFINE-POLICY) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 4555))
DEFINE-SETF-EXPANDER
(((DOCUMENTATION . FUNCTION) . "Syntax: (define-setf-expander symbol defmacro-lambda-list {decl | doc}*
          {form}*)
Defines the SETF-method for generalized-variables (SYMBOL ...).
When a form (setf (SYMBOL arg1 ... argn) value-form) is evaluated, the FORMs
given in the DEFINE-SETF-EXPANDER are evaluated in order with the parameters in
DEFMACRO-LAMBDA-LIST bound to ARG1 ... ARGn.  The last FORM must return five
values
	(var1 ... vark)
	(form1 ... formk)
	(value-var)
	storing-form
	access-form
in order.  These values are collectively called the five gangs of the
generalized variable (SYMBOL arg1 ... argn).  The whole SETF form is then
expanded into
	(let* ((var1 from1) ... (vark formk)
	       (value-var value-form))
	  storing-form)
The doc-string DOC, if supplied, is saved as a SETF doc and can be retrieved
by (DOCUMENTATION 'SYMBOL 'SETF).") ((:LAMBDA-LIST) SI::ACCESS-FN SI::ARGS &REST SI::BODY) ((SI:LOCATION DEFMACRO DEFINE-SETF-EXPANDER) #P"SRC:LSP;SETF.LSP.NEWEST" . 2258))
CLOS::DEFINE-SIMPLE-METHOD-COMBINATION
(((:LAMBDA-LIST) CLOS::NAME &KEY DOCUMENTATION CLOS::IDENTITY-WITH-ONE-ARGUMENT (CLOS::OPERATOR CLOS::NAME)) ((SI:LOCATION DEFUN CLOS::DEFINE-SIMPLE-METHOD-COMBINATION) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 7889))
C::DEFINE-SIMPLE-OPTIMIZER
(((:LAMBDA-LIST) C::NAME C::ARGS &REST C::INLINE-FORM) ((SI:LOCATION DEFMACRO C::DEFINE-SIMPLE-OPTIMIZER) #P"SRC:CMP;CMPOPT-CONS.LSP.NEWEST" . 2330))
SI::DEFINE-STRUCTURE
(((:LAMBDA-LIST) SI::NAME SI::CONC-NAME TYPE SI::NAMED SI::SLOTS SI::SLOT-DESCRIPTIONS SI::COPIER SI::INCLUDE SI::PRINT-FUNCTION PRINT-OBJECT SI::CONSTRUCTORS SI::OFFSET SI::NAME-OFFSET DOCUMENTATION SI::PREDICATE) ((SI:LOCATION DEFUN SI::DEFINE-STRUCTURE) #P"SRC:LSP;DEFSTRUCT.LSP.NEWEST" . 10232))
DEFINE-SYMBOL-MACRO
(((:LAMBDA-LIST) &WHOLE SI::WHOLE SYMBOL SI::EXPANSION) ((SI:LOCATION DEFMACRO DEFINE-SYMBOL-MACRO) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 11365))
FFI:DEFINLINE
(((DOCUMENTATION . FUNCTION) . "Syntax: (definline symbol (&rest arg-types) result-type &body body) ") ((:LAMBDA-LIST) FFI::FUN FFI::ARG-TYPES TYPE FFI::CODE) ((SI:LOCATION DEFMACRO FFI:DEFINLINE) #P"SRC:LSP;FFI.LSP.NEWEST" . 24690))
FFI:DEFLA
(((DOCUMENTATION . FUNCTION) . "Syntax: (defla name lambda-list &body body)") ((:LAMBDA-LIST) &REST FFI::BODY) ((SI:LOCATION DEFMACRO FFI:DEFLA) #P"SRC:LSP;FFI.LSP.NEWEST" . 25386))
DEFMACRO
(((DOCUMENTATION . FUNCTION) . "Macro in COMMON-LISP package:
Syntax: (defmacro name defmacro-lambda-list {decl | doc}* {form}*)
Defines a global macro named by NAME.  The complete syntax of DEFMACRO-LAMBDA-
LIST is:
	( [&whole var] [&environment var] . pvar )
where PVAR may be a symbol,
	( {pvar}* [&optional {var | (pvar [init [pvar]])}*] . var )
or
	( {pvar}*
	  [&optional {var | (pvar [init [pvar]])}*]
	  [{&rest | &body} pvar]
	  [&key {var | ({var | (keyword pvar)} [init [pvar]])}*
	        [&allow-other-keys]]
	  [&aux {var | (pvar [init])}*] )
The doc-string DOC, if supplied, is saved as a FUNCTION doc and can be
retrieved by (documentation 'NAME 'function).  See LIST for the backquote
macro useful for defining macros.
") ((:LAMBDA-LIST) &WHOLE SI::WHOLE SI::NAME SI::VL &BODY SI::BODY &AUX SI::DOC-STRING) ((SI:LOCATION DEFMACRO DEFMACRO) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 1448))
DEFMETHOD
(((:LAMBDA-LIST) &WHOLE CLOS::WHOLE &REST CLOS::ARGS &ENVIRONMENT CLOS::ENV) ((SI:LOCATION DEFMACRO DEFMETHOD) #P"SRC:CLOS;METHOD.LSP.NEWEST" . 973))
DEFPACKAGE
(((DOCUMENTATION . FUNCTION) . "DEFPACKAGE - DEFINED-PACKAGE-NAME {OPTION}*			[Macro]

   This creates a new package, or modifies an existing one, whose name is
   DEFINED-PACKAGE-NAME.  The DEFINED-PACKAGE-NAME may be a string or a 
   symbol; if it is a symbol, only its print name matters, and not what
   package, if any, the symbol happens to be in.  The newly created or 
   modified package is returned as the value of the DEFPACKAGE form.

   Each standard OPTION is a list of keyword (the name of the option)
   and associated arguments.  No part of a DEFPACKAGE form is evaluated.
   Except for the :SIZE and :DOCUMENTATION options, more than one option 
   of the same kind may occur within the same DEFPACKAGE form.

  Valid Options:
	(:documentation		string)
	(:size			integer)
	(:nicknames		{package-name}*)
	(:shadow		{symbol-name}*)
	(:shadowing-import-from	package-name {symbol-name}*)
	(:use			{package-name}*)
	(:import-from		package-name {symbol-name}*)
	(:intern		{symbol-name}*)
	(:export		{symbol-name}*)
	(:export-from		{package-name}*)

  [Note: :EXPORT-FROM is an extension to DEFPACKAGE.
	 If a symbol is interned in the package being created and
	 if a symbol with the same print name appears as an external
	 symbol of one of the packages in the :EXPORT-FROM option,
	 then the symbol is exported from the package being created.

	 :DOCUMENTATION is an extension to DEFPACKAGE.

	 :SIZE is used only in Genera and Allegro.]") ((:LAMBDA-LIST) SI::NAME &REST SI::OPTIONS) ((SI:LOCATION DEFMACRO DEFPACKAGE) #P"SRC:LSP;DEFPACKAGE.LSP.NEWEST" . 2616))
DEFPARAMETER
(((DOCUMENTATION . FUNCTION) . "Syntax: (defparameter name form [doc])
Declares the global variable named by NAME as a special variable and assigns
the value of FORM to the variable.  The doc-string DOC, if supplied, is saved
as a VARIABLE doc and can be retrieved by (documentation 'NAME 'variable).") ((:LAMBDA-LIST) &WHOLE SI::WHOLE SI::VAR SI::FORM &OPTIONAL SI::DOC-STRING) ((SI:LOCATION DEFMACRO DEFPARAMETER) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 2750))
DEFSETF
(((DOCUMENTATION . FUNCTION) . "Syntax: (defsetf symbol update-fun [doc])
	or
	(defsetf symbol lambda-list (store-var) {decl | doc}* {form}*)
Defines an expansion
	(setf (SYMBOL arg1 ... argn) value)
	=> (UPDATE-FUN arg1 ... argn value)
	   or
	   (let* ((temp1 ARG1) ... (tempn ARGn) (temp0 value)) rest)
where REST is the value of the last FORM with parameters in LAMBDA-LIST bound
to the symbols TEMP1 ... TEMPn and with STORE-VAR bound to the symbol TEMP0.
The doc-string DOC, if supplied, is saved as a SETF doc and can be retrieved
by (documentation 'SYMBOL 'setf).") ((:LAMBDA-LIST) SI::ACCESS-FN &REST REST) ((SI:LOCATION DEFMACRO DEFSETF) #P"SRC:LSP;SETF.LSP.NEWEST" . 791))
DEFSTRUCT
(((DOCUMENTATION . FUNCTION) . "Syntax: (defstruct
         {name | (name {:conc-name | (:conc-name prefix-string) |
                        :constructor | (:constructor symbol [lambda-list]) |
                        :copier | (:copier symbol) |
                        :predicate | (:predicate symbol) |
                        (:include symbol) |
                        (:print-function function) |
                        (:print-object function) |
                        (:type {vector | (vector type) | list}) |
                        :named |
                        (:initial-offset number)}*)}
         [doc]
         {slot-name |
          (slot-name [default-value-form] {:type type | :read-only flag}*) }*
         )
Defines a structure named by NAME.  The doc-string DOC, if supplied, is saved
as a STRUCTURE doc and can be retrieved by (documentation 'NAME 'structure).") ((:LAMBDA-LIST) &WHOLE SI::WHOLE SI::NAME&OPTS &REST SI::SLOTS) ((SI:LOCATION DEFMACRO DEFSTRUCT) #P"SRC:LSP;DEFSTRUCT.LSP.NEWEST" . 12284))
DEFTYPE
(((DOCUMENTATION . FUNCTION) . "Syntax: (deftype name lambda-list {decl | doc}* {form}*)
Defines a new type-specifier abbreviation in terms of an 'expansion' function
	(lambda lambda-list1 {DECL}* {FORM}*)
where LAMBDA-LIST1 is identical to LAMBDA-LIST except that all optional
parameters with no default value specified in LAMBDA-LIST defaults to the
symbol '*', but not to NIL.  When the type system of ECL encounters a type
specifier (NAME arg1 ... argn), it calls the expansion function with the
arguments ARG1 ... ARGn, and uses the returned value instead of the original
type specifier.  When the symbol NAME is used as a type specifier, the
expansion function is called with no argument.
The doc-string DOC, if supplied, is saved as a TYPE doc and can be retrieved
by (documentation 'NAME 'type).") ((:LAMBDA-LIST) SI::NAME SI::LAMBDA-LIST &REST SI::BODY) ((SI:LOCATION DEFMACRO DEFTYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 1783))
DEFUN
(((DOCUMENTATION . FUNCTION) . "Macro in COMMON-LISP package:
Syntax: (defun name lambda-list {decl | doc}* {form}*)
Defines a global function named by NAME.
The complete syntax of a lambda-list is:
	({var}*
	 [&optional {var | (var [init [svar]])}*]
	 [&rest var]
	 [&key {var | ({var | (keyword var)} [init [svar]])}*
	       [&allow-other-keys]]
	 [&aux {var | (var [init])}*])
The doc-string DOC, if supplied, is saved as a FUNCTION doc and can be
retrieved by (documentation 'NAME 'function).
") ((:LAMBDA-LIST) &WHOLE SI::WHOLE SI::NAME SI::VL &BODY SI::BODY &AUX SI::DOC-STRING) ((SI:LOCATION DEFMACRO DEFUN) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 756))
C::DEFUN-CACHED
(((:LAMBDA-LIST) C::NAME C::LAMBDA-LIST C::TEST &BODY C::BODY) ((SI:LOCATION DEFMACRO C::DEFUN-CACHED) #P"SRC:CMP;CMPMAC.LSP.NEWEST" . 404))
C::DEFUN-EQUAL-CACHED
(((:LAMBDA-LIST) C::NAME C::LAMBDA-LIST &BODY C::BODY) ((SI:LOCATION DEFMACRO C::DEFUN-EQUAL-CACHED) #P"SRC:CMP;CMPMAC.LSP.NEWEST" . 1832))
DEFVAR
(((DOCUMENTATION . FUNCTION) . "Syntax: (defvar name [form [doc]])
Declares the variable named by NAME as a special variable.  If the variable
does not have a value, then evaluates FORM and assigns the value to the
variable.  FORM defaults to NIL.  The doc-string DOC, if supplied, is saved
as a VARIABLE doc and can be retrieved by (documentation 'NAME 'variable).") ((:LAMBDA-LIST) &WHOLE SI::WHOLE SI::VAR &OPTIONAL (SI::FORM NIL SI::FORM-SP) SI::DOC-STRING) ((SI:LOCATION DEFMACRO DEFVAR) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 1970))
DELETE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ITEM SEQUENCE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Destructive REMOVE.  SEQUENCE may be destroyed.
") ((:LAMBDA-LIST) SI::ITEM SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::TEST '#'EQL) SI::TEST-NOT (SI::START 0) (SI::END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN DELETE) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 11785))
C::DELETE-C1FORMS
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::DELETE-C1FORMS) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 12596))
DELETE-DUPLICATES
(((DOCUMENTATION . FUNCTION) . "Args: (sequence &key key
		     (test '#'eql) test-not
                     (start 0) (end (length sequence)) (from-end nil))
Destructive REMOVE-DUPLICATES.  SEQUENCE may be destroyed.") ((:LAMBDA-LIST) SEQUENCE &KEY SI::TEST SI::TEST-NOT SI::FROM-END (SI::START 0) SI::END SI::KEY) ((SI:LOCATION DEFUN DELETE-DUPLICATES) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 25469))
SI::DELETE-DUPLICATES-LIST
(((:LAMBDA-LIST) SEQUENCE SI::START SI::END SI::FROM-END SI::TEST SI::TEST-NOT SI::KEY) ((SI:LOCATION DEFUN SI::DELETE-DUPLICATES-LIST) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 22270))
DELETE-FILE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC)

Deletes the specified file.  FILESPEC may be a symbol, a string, a pathname,
or a file stream.
") ((:LAMBDA-LIST) SI::FILESPEC))
C::DELETE-FORM-FROM-NODE-LIST
(((:LAMBDA-LIST) C::FORM LIST) ((SI:LOCATION DEFUN C::DELETE-FORM-FROM-NODE-LIST) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 7574))
C::DELETE-FROM-READ-NODES
(((:LAMBDA-LIST) C::VAR C::FORM) ((SI:LOCATION DEFUN C::DELETE-FROM-READ-NODES) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 3161))
DELETE-IF
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Destructive REMOVE-IF.  SEQUENCE may be destroyed
") ((:LAMBDA-LIST) SI::TEST SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::START 0) (SI::END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN DELETE-IF) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 12874))
DELETE-IF-NOT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Destructive REMOVE-IF-NOT.  SEQUENCE may be destroyed
") ((:LAMBDA-LIST) SI::TEST SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::START 0) (SI::END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN DELETE-IF-NOT) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 13100))
SI::DELETE-LIST
(((:LAMBDA-LIST) SI::WHICH SEQUENCE SI::START SI::END COUNT SI::TEST SI::TEST-NOT SI::KEY) ((SI:LOCATION DEFUN SI::DELETE-LIST) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 10738))
DENOMINATOR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (RATIONAL)

Returns the denominator of RATIONAL as a positive integer, if RATIONAL is a
ratio.  Returns RATIONAL if it is an integer.
") ((:LAMBDA-LIST) RATIONAL))
DEPOSIT-FIELD
(((DOCUMENTATION . FUNCTION) . "Args: (integer1 bytespec integer2)
Returns an integer represented by the bit sequence obtained by replacing the
specified bits of INTEGER2 with the specified bits of INTEGER1.") ((:LAMBDA-LIST) SI::NEWBYTE SI::BYTESPEC INTEGER) ((SI:LOCATION DEFUN DEPOSIT-FIELD) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 11359))
FFI:DEREF-ARRAY
(((:LAMBDA-LIST) ARRAY FFI::ARRAY-TYPE POSITION) ((SI:LOCATION DEFUN FFI:DEREF-ARRAY) #P"SRC:LSP;FFI.LSP.NEWEST" . 8655))
FFI:DEREF-POINTER
(((:LAMBDA-LIST) FFI::PTR TYPE) ((SI:LOCATION DEFUN FFI:DEREF-POINTER) #P"SRC:LSP;FFI.LSP.NEWEST" . 11255))
DESCRIBE
(((DOCUMENTATION . FUNCTION) . "Args: (object &optional (stream *standard-output*))
Prints information about OBJECT to STREAM.") ((:LAMBDA-LIST) SI::OBJECT &OPTIONAL (STREAM *STANDARD-OUTPUT*) &AUX (SI::*INSPECT-MODE* NIL) (SI::*INSPECT-LEVEL* 0) (SI::*INSPECT-HISTORY* NIL) (*PRINT-LEVEL* NIL) (*PRINT-LENGTH* NIL) (*STANDARD-OUTPUT* (COND ((STREAMP STREAM) STREAM) ((NULL STREAM) *STANDARD-OUTPUT*) ((EQ STREAM T) *TERMINAL-IO*) (T (ERROR 'TYPE-ERROR :DATUM STREAM :EXPECTED-TYPE '(OR STREAM T NIL)))))) ((SI:LOCATION DEFUN DESCRIBE) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 16074))
DESCRIBE-OBJECT
(((SI:LOCATION DEFMETHOD DESCRIBE-OBJECT (CLOS::OBJ CLASS) (STREAM T)) #P"SRC:CLOS;PRINT.LSP.NEWEST" . 8033) ((SI:LOCATION DEFMETHOD DESCRIBE-OBJECT (CLOS::OBJ T) (STREAM T)) #P"SRC:CLOS;PRINT.LSP.NEWEST" . 7556) ((SI:LOCATION DEFMETHOD DESCRIBE-OBJECT (CLOS::OBJ CLOS::STD-CLASS) (STREAM T)) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 31229) ((SI:LOCATION DEFMETHOD DESCRIBE-OBJECT (CLOS::OBJ STANDARD-OBJECT) (STREAM T)) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 28110))
C::DESTINATION-TYPE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::DESTINATION-TYPE) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 6231))
SI::DESTRUCTURING-SIZE
(((:LAMBDA-LIST) SI::X) ((SI:LOCATION DEFUN SI::DESTRUCTURING-SIZE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 34403))
DIGIT-CHAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (DIGIT &OPTIONAL (N 10) (FONT 0))

Returns a character that represents the DIGIT in radix N.  Returns NIL if no
such character exists.
") ((:LAMBDA-LIST) SI::DIGIT &OPTIONAL (SI::N 10) (SI::FONT 0)))
DIGIT-CHAR-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR &OPTIONAL (N 10))

If CHAR represents a digit in radix N, then returns an integer represented by
that digit.  Otherwise, returns NIL.
") ((:LAMBDA-LIST) CHAR &OPTIONAL (SI::N 10)))
CLOS:DIRECT-SLOT-DEFINITION
(((SI:LOCATION DEFCLASS CLOS:DIRECT-SLOT-DEFINITION) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 1919))
CLOS:DIRECT-SLOT-DEFINITION-CLASS
(((SI:LOCATION DEFMETHOD CLOS:DIRECT-SLOT-DEFINITION-CLASS (CLASS T) &REST CLOS::CANONICALIZED-SLOT) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 5554))
DIRECTORY
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC)

Returns a list of full pathnames of all those files that match FILESPEC.
FILESPEC may be a symbol, a string, a pathname, or a file stream.
") ((:LAMBDA-LIST) SI::FILESPEC))
DIRECTORY-NAMESTRING
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC)

Returns as a string the directory part of the pathname specified by FILESPEC.
FILESPEC may be a symbol, a string, a pathname, or a file stream.
") ((:LAMBDA-LIST) SI::FILESPEC))
DISASSEMBLE
(((:LAMBDA-LIST) C::THING &KEY (C::H-FILE NIL) (C::DATA-FILE NIL) &AUX C::DEF C::DISASSEMBLED-FORM (C::*COMPILER-IN-USE* C::*COMPILER-IN-USE*) (*PRINT-PRETTY* NIL)) ((SI:LOCATION DEFUN DISASSEMBLE) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 28643))
C::DISCARDED
(((:LAMBDA-LIST) C::VAR C::FORM C::BODY &AUX LAST) ((SI:LOCATION DEFUN C::DISCARDED) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 11329))
SI::DISPLACED-ARRAY-P
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (ARRAY)

ECL specific.
Returns T if the ARRAY is displaced to another array; NIL otherwise.
") ((:LAMBDA-LIST) ARRAY))
DIVISION-BY-ZERO
(((SI:LOCATION DEFCLASS DIVISION-BY-ZERO) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
DO
(((DOCUMENTATION . FUNCTION) . "Macro in COMMON-LISP package:
Syntax: (do ({(var [init [step]])}*) (test {result}*)
          {decl}* {tag | statement}*)

Establishes a NIL block, binds each VAR to the value of the corresponding INIT
(which defaults to NIL), and then executes STATEMENTs repeatedly until TEST is
satisfied.  After each iteration, evaluates STEP and assigns the value to the
corresponding VAR.  No assignment occurs for those VARs to which STEP is not
given.  When TEST is satisfied, evaluates RESULTs as a PROGN and returns all
values of the last RESULT.  Performs variable bindings and assignments in
parallel, just as LET and PSETQ do.
") ((:LAMBDA-LIST) . "(do ({(var [init [step]])}*) (test {result}*)
          {decl}* {tag | statement}*)"))
DO*
(((DOCUMENTATION . FUNCTION) . "Macro in COMMON-LISP package:
Syntax: (do* ({(var [init [step]])}*) (test {result}*)
          {decl}* {tag | statement}*)

Similar to DO, but performs variable bindings and assignments in serial, just
as LET* and SETQ do.
") ((:LAMBDA-LIST) . "(do* ({(var [init [step]])}*) (test {result}*)
          {decl}* {tag | statement}*)"))
DO-ALL-SYMBOLS
(((DOCUMENTATION . FUNCTION) . "Syntax: (do-all-symbols (var [result]) {decl}* {tag | statement}*)
Establishes a NIL block and executes STATEMENTs once for each symbol in each
package, with VAR bound to the symbol.  Then evaluates RESULT (which defaults
to NIL) and returns all values.") ((:LAMBDA-LIST) (SI::VAR &OPTIONAL (SI::RESULT-FORM NIL)) &REST SI::BODY) ((SI:LOCATION DEFMACRO DO-ALL-SYMBOLS) #P"SRC:LSP;PACKLIB.LSP.NEWEST" . 4804))
SI::DO-CHECK-TYPE
(((:LAMBDA-LIST) SI::VALUE TYPE SI::TYPE-STRING SI::PLACE) ((SI:LOCATION DEFUN SI::DO-CHECK-TYPE) #P"SRC:LSP;ASSERT.LSP.NEWEST" . 2048))
C::DO-CMPWARN
(((:LAMBDA-LIST) &REST C::ARGS) ((SI:LOCATION DEFUN C::DO-CMPWARN) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 9352))
C::DO-COMPILATION-UNIT
(((:LAMBDA-LIST) C::CLOSURE &KEY C::OVERRIDE) ((SI:LOCATION DEFUN C::DO-COMPILATION-UNIT) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 6100))
SI:DO-DEFTYPE
(((:LAMBDA-LIST) SI::NAME SI::FORM FUNCTION) ((SI:LOCATION DEFUN SI:DO-DEFTYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 1432))
SI::DO-DOCFUN
(((:LAMBDA-LIST) SYMBOL SI::KIND SI::ARGS SI::DOC) ((SI:LOCATION DEFUN SI::DO-DOCFUN) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/src/doc/help.lsp" . 675))
SI::DO-DOCTYPE
(((:LAMBDA-LIST) SYMBOL SI::DOC) ((SI:LOCATION DEFUN SI::DO-DOCTYPE) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/src/doc/help.lsp" . 1755))
SI::DO-DOCVAR
(((:LAMBDA-LIST) SYMBOL SI::KIND SI::DOC) ((SI:LOCATION DEFUN SI::DO-DOCVAR) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/src/doc/help.lsp" . 1498))
DO-EXTERNAL-SYMBOLS
(((DOCUMENTATION . FUNCTION) . "Syntax: (do-external-symbols (var [package [result]])
          {decl}* {tag | statement}*)
Establishes a NIL block and executes STATEMENTs once for each external symbol
in PACKAGE (which defaults to the current package), with VAR bound to the
variable.  Then evaluates RESULT (which defaults to NIL) and returns all
values.") ((:LAMBDA-LIST) (SI::VAR &OPTIONAL (PACKAGE '*PACKAGE*) (SI::RESULT-FORM NIL)) &REST SI::BODY) ((SI:LOCATION DEFMACRO DO-EXTERNAL-SYMBOLS) #P"SRC:LSP;PACKLIB.LSP.NEWEST" . 4301))
C::DO-IN-LIST
(((:LAMBDA-LIST) (C::%ELT C::%SUBLIST LIST &REST C::OUTPUT) &BODY C::BODY) ((SI:LOCATION DEFMACRO C::DO-IN-LIST) #P"SRC:CMP;CMPOPT-SEQUENCE.LSP.NEWEST" . 6159))
C::DO-IN-SEQ
(((:LAMBDA-LIST) (C::%ELT SEQUENCE &KEY (C::START 0) C::END C::OUTPUT) &BODY C::BODY) ((SI:LOCATION DEFMACRO C::DO-IN-SEQ) #P"SRC:CMP;CMPOPT-SEQUENCE.LSP.NEWEST" . 5210))
FFI::DO-LOAD-FOREIGN-LIBRARY
(((:LAMBDA-LIST) FFI::TMP &OPTIONAL FFI::SYSTEM-LIBRARY) ((SI:LOCATION DEFUN FFI::DO-LOAD-FOREIGN-LIBRARY) #P"SRC:LSP;FFI.LSP.NEWEST" . 21719))
C::DO-M-V-SETQ-ANY
(((:LAMBDA-LIST) C::MIN-VALUES C::MAX-VALUES C::VARS C::USE-BIND) ((SI:LOCATION DEFUN C::DO-M-V-SETQ-ANY) #P"SRC:CMP;CMPMULTI.LSP.NEWEST" . 6044))
C::DO-M-V-SETQ-FIXED
(((:LAMBDA-LIST) C::NVALUES C::VARS C::FORM C::USE-BIND &AUX (C::OUTPUT (FIRST C::VARS))) ((SI:LOCATION DEFUN C::DO-M-V-SETQ-FIXED) #P"SRC:CMP;CMPMULTI.LSP.NEWEST" . 5291))
C::DO-MAKE-C1FORM
(((:LAMBDA-LIST) &KEY #:LOCAL-VARS (#:TYPE '(VALUES &REST T)) #:SP-CHANGE #:VOLATILE #:NAME #:PARENTS (#:ENV (C::CMP-ENV-COPY)) (#:ARGS 'NIL) #:SIDE-EFFECTS #:FORM #:TOPLEVEL-FORM #:FILE (#:FILE-POSITION 0)) ((SI:LOCATION DEFUN C::DO-MAKE-C1FORM) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 9763))
SI::DO-PPRINT-LOGICAL-BLOCK
(((:LAMBDA-LIST) FUNCTION SI::OBJECT STREAM SI::PREFIX SI::PER-LINE-PREFIX-P SI::SUFFIX) ((SI:LOCATION DEFUN SI::DO-PPRINT-LOGICAL-BLOCK) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 26616))
SI::DO-SEQUENCE
(((:LAMBDA-LIST) (ELT SEQUENCE SI::START SI::END &REST SI::ARGS &KEY SI::SETTER SI::INDEX SI::OUTPUT SI::SPECIALIZE) &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::DO-SEQUENCE) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/src/lsp/seqmacros.lsp" . 4108))
SI::DO-SEQUENCES
(((:LAMBDA-LIST) (SI::ELT-LIST SI::SEQ-LIST &KEY SI::OUTPUT) &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::DO-SEQUENCES) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/src/lsp/seqmacros.lsp" . 4944))
SI::DO-SUBLIST
(((:LAMBDA-LIST) (ELT LIST SI::START SI::END &KEY SI::OUTPUT SI::SETTER (SI::INDEX (GENSYM))) &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::DO-SUBLIST) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/src/lsp/seqmacros.lsp" . 3487))
DO-SYMBOLS
(((DOCUMENTATION . FUNCTION) . "Syntax: (do-symbols (var [package [result]])
          {decl}* {tag | statement}*)
Executes STATEMENTs once for each symbol in PACKAGE (which defaults to the
current package), with VAR bound to the symbol.  Then evaluates RESULT (which
defaults to NIL) and returns all values.") ((:LAMBDA-LIST) (SI::VAR &OPTIONAL (PACKAGE '*PACKAGE*) (SI::RESULT-FORM NIL)) &REST SI::BODY) ((SI:LOCATION DEFMACRO DO-SYMBOLS) #P"SRC:LSP;PACKLIB.LSP.NEWEST" . 3822))
SI::DO-TIME
(((:LAMBDA-LIST) SI::CLOSURE) ((SI:LOCATION DEFUN SI::DO-TIME) #P"SRC:LSP;MISLIB.LSP.NEWEST" . 1655))
SI::DO-VECTOR
(((:LAMBDA-LIST) (ELT VECTOR SI::START SI::END &KEY SI::FROM-END SI::OUTPUT SI::SETTER (SI::INDEX (GENSYM))) &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::DO-VECTOR) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/src/lsp/seqmacros.lsp" . 2487))
C::DO-WT-COMMENT
(((:LAMBDA-LIST) C::MESSAGE-OR-FORMAT C::ARGS C::SINGLE-LINE-P) ((SI:LOCATION DEFUN C::DO-WT-COMMENT) #P"SRC:CMP;CMPC-WT.LSP.NEWEST" . 2135))
SI::DOCFUN
(((:LAMBDA-LIST) SYMBOL SI::KIND SI::ARGS SI::DOC) ((SI:LOCATION DEFMACRO SI::DOCFUN) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/src/doc/help.lsp" . 598))
SI::DOCTYPE
(((:LAMBDA-LIST) SYMBOL SI::DOC) ((SI:LOCATION DEFMACRO SI::DOCTYPE) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/src/doc/help.lsp" . 1696))
DOCUMENTATION
(((SI:LOCATION DEFMETHOD DOCUMENTATION (CLOS::OBJECT CLOS:SLOT-DEFINITION) CLOS::DOC-TYPE) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 15374) ((SI:LOCATION DEFMETHOD DOCUMENTATION (CLOS::OBJECT FUNCTION) CLOS::DOC-TYPE) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 15065) ((SI:LOCATION DEFMETHOD DOCUMENTATION (CLOS::OBJECT STANDARD-METHOD) CLOS::DOC-TYPE) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 14745) ((SI:LOCATION DEFMETHOD DOCUMENTATION (CLOS::OBJECT STANDARD-GENERIC-FUNCTION) CLOS::DOC-TYPE) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 14405) ((SI:LOCATION DEFMETHOD DOCUMENTATION (CLOS::OBJECT LIST) CLOS::DOC-TYPE) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 14078) ((SI:LOCATION DEFMETHOD DOCUMENTATION (CLOS::OBJECT STRUCTURE-CLASS) CLOS::DOC-TYPE) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 13734) ((SI:LOCATION DEFMETHOD DOCUMENTATION (CLOS::OBJECT CLASS) CLOS::DOC-TYPE) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 13400) ((SI:LOCATION DEFMETHOD DOCUMENTATION (CLOS::OBJECT PACKAGE) CLOS::DOC-TYPE) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 13095) ((SI:LOCATION DEFMETHOD DOCUMENTATION (CLOS::OBJECT SYMBOL) CLOS::DOC-TYPE) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 11795) ((:LAMBDA-LIST) CLOS::OBJECT CLOS::DOC-TYPE) ((SI:LOCATION DEFGENERIC DOCUMENTATION) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 11687))
SI::DOCVAR
(((:LAMBDA-LIST) SYMBOL SI::KIND SI::DOC) ((SI:LOCATION DEFMACRO SI::DOCVAR) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/src/doc/help.lsp" . 1431))
SI::DODEFPACKAGE
(((:LAMBDA-LIST) SI::NAME SI::NICKNAMES DOCUMENTATION SI::USE SI::SHADOWED-SYMBOL-NAMES SI::INTERNED-SYMBOL-NAMES SI::EXPORTED-SYMBOL-NAMES SI::SHADOWING-IMPORTED-FROM-SYMBOL-NAMES-LIST SI::IMPORTED-FROM-SYMBOL-NAMES-LIST SI::EXPORTED-FROM-PACKAGE-NAMES) ((SI:LOCATION DEFUN SI::DODEFPACKAGE) #P"SRC:LSP;DEFPACKAGE.LSP.NEWEST" . 7230))
DOLIST
(((DOCUMENTATION . FUNCTION) . "Macro in COMMON-LISP package:
Syntax: (dolist (var form [result])
          {decl}* {tag | statement}*)

Establishes a NIL block and executes STATEMENTs once for each member of the
list value of FORM, with VAR bound to the member.  Then evaluates RESULT
(which defaults to NIL) and returns all values.
") ((:LAMBDA-LIST) . "(dolist (var form [result])
          {decl}* {tag | statement}*)"))
DOTIMES
(((DOCUMENTATION . FUNCTION) . "Macro in COMMON-LISP package:
Syntax: (dotimes (var form [result])
          {decl}* {tag | statement}*)

Establishes a NIL block and executes STATEMENTs once for each integer between
0 (inclusive) and the value of FORM (exclusive), with VAR bound to the
integer.  Then evaluates RESULT (which defaults to NIL) and returns all
values.
") ((:LAMBDA-LIST) . "(dotimes (var form [result])
          {decl}* {tag | statement}*)") ((SI:LOCATION DEFINE-COMPILER-MACRO DOTIMES) #P"SRC:CMP;CMPOPT-TYPE.LSP.NEWEST" . 1357))
DOUBLE-FLOAT
(((DOCUMENTATION . TYPE) . "
A double-float is a double-precision floating point number.
DOUBLE-FLOAT as a type specifier is equivalent to LONG-FLOAT in ECL."))
DOUBLE-FLOAT-EPSILON
(((SI:LOCATION DEFCONSTANT DOUBLE-FLOAT-EPSILON) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 625) ((DOCUMENTATION . VARIABLE) . "The smallest postive double-float E that satisfies
	(not (= (float 1 E) (+ (float 1 E) E)))"))
DOUBLE-FLOAT-NEGATIVE-EPSILON
(((SI:LOCATION DEFCONSTANT DOUBLE-FLOAT-NEGATIVE-EPSILON) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 625) ((DOCUMENTATION . VARIABLE) . "The smallest positive double-float E that satisfies
	(not (= (float 1 E) (- (float 1 E) E)))"))
SI:DOUBLE-FLOAT-NEGATIVE-INFINITY
(((SI:LOCATION DEFCONSTANT SI:DOUBLE-FLOAT-NEGATIVE-INFINITY) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 2925))
SI:DOUBLE-FLOAT-POSITIVE-INFINITY
(((SI:LOCATION DEFCONSTANT SI:DOUBLE-FLOAT-POSITIVE-INFINITY) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 2925))
DPB
(((DOCUMENTATION . FUNCTION) . "Args: (newbyte bytespec integer)
Replaces the specified byte of INTEGER with NEWBYTE (an integer) and returns
the result.") ((:LAMBDA-LIST) SI::NEWBYTE SI::BYTESPEC INTEGER) ((SI:LOCATION DEFUN DPB) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 11001))
DRIBBLE
(((DOCUMENTATION . FUNCTION) . "Args: (&optional filespec)
If FILESPEC is given, starts recording the interaction to the specified file.
FILESPEC may be a symbol, a string, a pathname, or a file stream.  If FILESPEC
is not given, ends the recording.") ((:LAMBDA-LIST) &OPTIONAL (PATHNAME "DRIBBLE.LOG" SI::PSP)) ((SI:LOCATION DEFUN DRIBBLE) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 8628))
SI::DUPLICATABLE-CODE-P
(((:LAMBDA-LIST) SI::EXPR SI::ENV) ((SI:LOCATION DEFUN SI::DUPLICATABLE-CODE-P) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 33402))
ECASE
(((DOCUMENTATION . FUNCTION) . "Syntax: (ecase keyform {({key | ({key}*)} {form}*)}*)
Evaluates KEYFORM and tries to find the KEY that is EQL to the value of
KEYFORM.  If found, then evaluates FORMs that follow the KEY (or the key list
that contains the KEY) and returns all values of the last FORM.  If not,
signals an error.") ((:LAMBDA-LIST) SI::KEYFORM &REST SI::CLAUSES) ((SI:LOCATION DEFMACRO ECASE) #P"SRC:LSP;ASSERT.LSP.NEWEST" . 3871))
SI::ECASE-ERROR
(((:LAMBDA-LIST) SI::KEYFORM SI::VALUE VALUES) ((SI:LOCATION DEFUN SI::ECASE-ERROR) #P"SRC:LSP;ASSERT.LSP.NEWEST" . 3712))
C::ECL-INCLUDE-DIRECTORY
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::ECL-INCLUDE-DIRECTORY) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 32173))
C::ECL-LIBRARY-DIRECTORY
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::ECL-LIBRARY-DIRECTORY) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 32580))
ED
(((DOCUMENTATION . FUNCTION) . "Args: (&optional filename)
Invokes the editor.  The action depends on the version of ECL.  See the ECL
Report for details.") ((:LAMBDA-LIST) &OPTIONAL SI::FILENAME) ((SI:LOCATION DEFUN ED) #P"SRC:LSP;AUTOLOAD.LSP.NEWEST" . 1265))
CLOS::EFFECTIVE-METHOD-FUNCTION
(((:LAMBDA-LIST) CLOS::FORM &OPTIONAL CLOS::TOP-LEVEL) ((SI:LOCATION DEFUN CLOS::EFFECTIVE-METHOD-FUNCTION) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 2324))
CLOS:EFFECTIVE-SLOT-DEFINITION
(((SI:LOCATION DEFCLASS CLOS:EFFECTIVE-SLOT-DEFINITION) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 1919))
CLOS:EFFECTIVE-SLOT-DEFINITION-CLASS
(((SI:LOCATION DEFMETHOD CLOS:EFFECTIVE-SLOT-DEFINITION-CLASS (CLASS T) &REST CLOS::CANONICALIZED-SLOT) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 5685))
EIGHTH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CADDDR (CDDDDR X)).
") ((:LAMBDA-LIST) SI::X))
ELT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SEQUENCE N)

Returns the N-th element of SEQUENCE.
") ((:LAMBDA-LIST) SEQUENCE SI::N))
C::EMIT-INLINE-FORM
(((:LAMBDA-LIST) C::FORM C::FORMS) ((SI:LOCATION DEFUN C::EMIT-INLINE-FORM) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 5029))
C::EMIT-INLINED-CALL-GLOBAL
(((:LAMBDA-LIST) C::FORM C::EXPECTED-TYPE) ((SI:LOCATION DEFUN C::EMIT-INLINED-CALL-GLOBAL) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 2935))
C::EMIT-INLINED-INSTANCE-REF
(((:LAMBDA-LIST) C::FORM C::REST-FORMS) ((SI:LOCATION DEFUN C::EMIT-INLINED-INSTANCE-REF) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 4483))
C::EMIT-INLINED-PROGN
(((:LAMBDA-LIST) C::FORM C::FORMS) ((SI:LOCATION DEFUN C::EMIT-INLINED-PROGN) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 3465))
C::EMIT-INLINED-SETQ
(((:LAMBDA-LIST) C::FORM C::REST-FORMS) ((SI:LOCATION DEFUN C::EMIT-INLINED-SETQ) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 2588))
C::EMIT-INLINED-STRUCTURE-REF
(((:LAMBDA-LIST) C::FORM C::REST-FORMS) ((SI:LOCATION DEFUN C::EMIT-INLINED-STRUCTURE-REF) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 3901))
C::EMIT-INLINED-VALUES
(((:LAMBDA-LIST) C::FORM C::FORMS) ((SI:LOCATION DEFUN C::EMIT-INLINED-VALUES) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 3680))
C::EMIT-INLINED-VARIABLE
(((:LAMBDA-LIST) C::FORM C::REST-FORMS) ((SI:LOCATION DEFUN C::EMIT-INLINED-VARIABLE) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 2211))
C::EMIT-LOCAL-FUNS
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::EMIT-LOCAL-FUNS) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 3185))
C::ENCODE-NUMBER-IN-NAME
(((:LAMBDA-LIST) NUMBER) ((SI:LOCATION DEFUN C::ENCODE-NUMBER-IN-NAME) #P"SRC:CMP;CMPNAME.LSP.NEWEST" . 857))
ENCODE-UNIVERSAL-TIME
(((DOCUMENTATION . FUNCTION) . "Args: (second minute hour date month year
       &optional (timezone (si::get-local-time-zone)))
Returns an integer that represents the given day-and-time.  See
GET-DECODED-TIME.") ((:LAMBDA-LIST) SI::SEC MIN SI::HOUR SI::DAY SI::MONTH SI::YEAR &OPTIONAL SI::TZ) ((SI:LOCATION DEFUN ENCODE-UNIVERSAL-TIME) #P"SRC:LSP;MISLIB.LSP.NEWEST" . 6287))
SI::END-LOGICAL-BLOCK
(((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFUN SI::END-LOGICAL-BLOCK) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 13369))
END-OF-FILE
(((SI:LOCATION DEFCLASS END-OF-FILE) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
ENDP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is NIL.  Returns NIL if X is a cons.  Otherwise, signals an
error.
") ((:LAMBDA-LIST) SI::X))
C::ENFORCE-TYPES
(((:LAMBDA-LIST) C::FNAME C::ARG-TYPES C::ARGUMENTS) ((SI:LOCATION DEFUN C::ENFORCE-TYPES) #P"SRC:CMP;CMPTYPE-PROP.LSP.NEWEST" . 1123))
ENOUGH-NAMESTRING
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC &OPTIONAL (DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*))

Returns a string which uniquely identifies the file specified by FILESPEC,
with respect to DEFAULTS.  FILESPEC and DEFAULTS may be a symbol, a string, a
pathname, or a file stream.
") ((:LAMBDA-LIST) SI::FILESPEC &OPTIONAL (SI::DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*)))
SI::ENQUEUE
(((:LAMBDA-LIST) STREAM TYPE &REST SI::ARGS) ((SI:LOCATION DEFMACRO SI::ENQUEUE) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 10690))
SI::ENQUEUE-INDENT
(((:LAMBDA-LIST) STREAM SI::KIND SI::AMOUNT) ((SI:LOCATION DEFUN SI::ENQUEUE-INDENT) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 12337))
SI::ENQUEUE-NEWLINE
(((:LAMBDA-LIST) STREAM SI::KIND) ((SI:LOCATION DEFUN SI::ENQUEUE-NEWLINE) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 11643))
SI::ENQUEUE-TAB
(((:LAMBDA-LIST) STREAM SI::KIND SI::COLNUM SI::COLINC) ((SI:LOCATION DEFUN SI::ENQUEUE-TAB) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 13903))
FFI:ENSURE-CHAR-CHARACTER
(((:LAMBDA-LIST) CHAR) ((SI:LOCATION DEFUN FFI:ENSURE-CHAR-CHARACTER) #P"SRC:LSP;FFI.LSP.NEWEST" . 12676))
FFI:ENSURE-CHAR-INTEGER
(((:LAMBDA-LIST) CHAR) ((SI:LOCATION DEFUN FFI:ENSURE-CHAR-INTEGER) #P"SRC:LSP;FFI.LSP.NEWEST" . 12843))
FFI:ENSURE-CHAR-STORABLE
(((:LAMBDA-LIST) CHAR) ((SI:LOCATION DEFUN FFI:ENSURE-CHAR-STORABLE) #P"SRC:LSP;FFI.LSP.NEWEST" . 13006))
CLOS:ENSURE-CLASS
(((:LAMBDA-LIST) CLOS::NAME &REST CLOS::INITARGS) ((SI:LOCATION DEFUN CLOS:ENSURE-CLASS) #P"SRC:CLOS;DEFCLASS.LSP.NEWEST" . 4012))
CLOS:ENSURE-CLASS-USING-CLASS
(((SI:LOCATION DEFMETHOD CLOS:ENSURE-CLASS-USING-CLASS (CLASS NULL) CLOS::NAME &REST REST) #P"SRC:CLOS;BUILTIN.LSP.NEWEST" . 3358) ((SI:LOCATION DEFMETHOD CLOS:ENSURE-CLASS-USING-CLASS (CLASS CLASS) CLOS::NAME &REST REST &KEY CLOS::DIRECT-SLOTS CLOS::DIRECT-DEFAULT-INITARGS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 18105))
ENSURE-DIRECTORIES-EXIST
(((DOCUMENTATION . FUNCTION) . "Args: (ensure-directories pathname &key :verbose)
Creates tree of directories specified by the given pathname. Outputs
	(VALUES pathname created)
where CREATED is true only if we succeeded on creating all directories.") ((:LAMBDA-LIST) PATHNAME &KEY SI::VERBOSE) ((SI:LOCATION DEFUN ENSURE-DIRECTORIES-EXIST) #P"SRC:LSP;MISLIB.LSP.NEWEST" . 9190))
ENSURE-GENERIC-FUNCTION
(((:LAMBDA-LIST) CLOS::NAME &REST CLOS::ARGS &KEY &ALLOW-OTHER-KEYS) ((SI:LOCATION DEFUN ENSURE-GENERIC-FUNCTION) #P"SRC:CLOS;GENERIC.LSP.NEWEST" . 9099))
CLOS:ENSURE-GENERIC-FUNCTION-USING-CLASS
(((SI:LOCATION DEFMETHOD CLOS:ENSURE-GENERIC-FUNCTION-USING-CLASS (CLOS::GFUN NULL) CLOS::NAME &REST CLOS::ARGS &KEY (CLOS::METHOD-CLASS 'STANDARD-METHOD CLOS::METHOD-CLASS-P) (CLOS::GENERIC-FUNCTION-CLASS 'STANDARD-GENERIC-FUNCTION) (CLOS::DELETE-METHODS NIL)) #P"SRC:CLOS;GENERIC.LSP.NEWEST" . 8439) ((SI:LOCATION DEFMETHOD CLOS:ENSURE-GENERIC-FUNCTION-USING-CLASS (CLOS::GFUN GENERIC-FUNCTION) CLOS::NAME &REST CLOS::ARGS &KEY (CLOS::METHOD-CLASS 'STANDARD-METHOD CLOS::METHOD-CLASS-P) (CLOS::GENERIC-FUNCTION-CLASS (CLASS-OF CLOS::GFUN)) (CLOS::DELETE-METHODS NIL)) #P"SRC:CLOS;GENERIC.LSP.NEWEST" . 7056))
C::ENSURE-NONRATIONAL-TYPE
(((:LAMBDA-LIST) C::GENERAL-TYPE) ((SI:LOCATION DEFUN C::ENSURE-NONRATIONAL-TYPE) #P"SRC:CMP;CMPNUM.LSP.NEWEST" . 3460))
C::ENSURE-NUMBER-TYPE
(((:LAMBDA-LIST) C::GENERAL-TYPE) ((SI:LOCATION DEFUN C::ENSURE-NUMBER-TYPE) #P"SRC:CMP;CMPNUM.LSP.NEWEST" . 3367))
C::ENSURE-REAL-TYPE
(((:LAMBDA-LIST) C::GENERAL-TYPE) ((SI:LOCATION DEFUN C::ENSURE-REAL-TYPE) #P"SRC:CMP;CMPNUM.LSP.NEWEST" . 3559))
CLOS::ENSURE-UP-TO-DATE-INSTANCE
(((:LAMBDA-LIST) CLOS::INSTANCE) ((SI:LOCATION DEFMACRO CLOS::ENSURE-UP-TO-DATE-INSTANCE) #P"SRC:CLOS;MACROS.LSP.NEWEST" . 551))
SI::ENTRY<
(((:LAMBDA-LIST) SI::E1 SI::E2) ((SI:LOCATION DEFUN SI::ENTRY<) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 39506))
C::ENV-GROWS
(((:LAMBDA-LIST) C::POSSIBILY) ((SI:LOCATION DEFUN C::ENV-GROWS) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 8529))
C::ENV-VAR-NAME
(((:LAMBDA-LIST) C::N) ((SI:LOCATION DEFUN C::ENV-VAR-NAME) #P"SRC:CMP;CMPCALL.LSP.NEWEST" . 8112))
C::ENV-VAR-NAME-EMPTY-CACHE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::ENV-VAR-NAME-EMPTY-CACHE) #P"SRC:CMP;CMPMAC.LSP.NEWEST" . 2059))
C::ENVIRONMENT-ACCESSOR
(((:LAMBDA-LIST) C::FUN) ((SI:LOCATION DEFUN C::ENVIRONMENT-ACCESSOR) #P"SRC:CMP;CMPSPECIAL.LSP.NEWEST" . 4714))
CLOS::ENVIRONMENT-CONTAINS-CLOSURE
(((:LAMBDA-LIST) CLOS::ENV) ((SI:LOCATION DEFUN CLOS::ENVIRONMENT-CONTAINS-CLOSURE) #P"SRC:CLOS;METHOD.LSP.NEWEST" . 4766))
EQ
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X Y)

Returns T if the args are identical; NIL otherwise.
") ((:LAMBDA-LIST) SI::X SI::Y))
EQL
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X Y)

Returns T if the args satisfy one of the following conditions.
	1. identical
	2. are numbers of the same type with the same value
	3. are characters that represent the same character
Returns NIL otherwise.
") ((:LAMBDA-LIST) SI::X SI::Y))
EQUAL
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X Y)

Returns T if the args satisfy one of the following conditions.
	1. EQL
	2. are conses with EQUAL cars and EQUAL cdrs
	3. are strings of the same length and element-wise EQL
	4. are bit-vectors of the same length and element-wise EQL
	5. are pathnames with EQUAL slots
Returns NIL otherwise.
") ((:LAMBDA-LIST) SI::X SI::Y))
EQUALP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X Y)

Returns T if the args satisfy one of the following conditions.
	1. EQUAL
	2. are characters that satisfy CHARACTER-EQUAL
	3. are numbers that satisfy =
	4. are conses with EQUALP cars and EQUALP cdrs
	5. are arrays of the same dimensions and element-wise EQUALP
Returns NIL otherwise.
") ((:LAMBDA-LIST) SI::X SI::Y))
ERROR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FORMAT-STRING &REST ARGS)

Signals an error.  The args are FORMATed to *error-output*.
") ((:LAMBDA-LIST) SI::FORMAT-STRING &REST SI::ARGS) ((SI:LOCATION DEFCLASS ERROR) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
SI::ERROR-COERCE
(((:LAMBDA-LIST) SI::OBJECT TYPE) ((SI:LOCATION DEFUN SI::ERROR-COERCE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 21903))
SI::ERROR-NOT-A-SEQUENCE
(((:LAMBDA-LIST) SI::VALUE) ((SI:LOCATION DEFUN SI::ERROR-NOT-A-SEQUENCE) #P"SRC:LSP;SEQ.LSP.NEWEST" . 676))
CLOS::ERROR-QUALIFIER
(((:LAMBDA-LIST) CLOS::M CLOS::QUALIFIER) ((SI:LOCATION DEFUN CLOS::ERROR-QUALIFIER) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 4680))
SI::ERROR-SEQUENCE-INDEX
(((:LAMBDA-LIST) SEQUENCE SI::INDEX) ((SI:LOCATION DEFUN SI::ERROR-SEQUENCE-INDEX) #P"SRC:LSP;SEQ.LSP.NEWEST" . 778))
SI::ERROR-SEQUENCE-LENGTH
(((:LAMBDA-LIST) SI::OBJECT TYPE SI::SIZE) ((SI:LOCATION DEFUN SI::ERROR-SEQUENCE-LENGTH) #P"SRC:LSP;SEQ.LSP.NEWEST" . 1341))
SI::ERROR-SEQUENCE-TYPE
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN SI::ERROR-SEQUENCE-TYPE) #P"SRC:LSP;SEQ.LSP.NEWEST" . 1055))
SI::ERROR-TYPE-SPECIFIER
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN SI::ERROR-TYPE-SPECIFIER) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 14539))
SI::ESTIMATE-CODE-SIZE
(((:LAMBDA-LIST) SI::X SI::ENV) ((SI:LOCATION DEFUN SI::ESTIMATE-CODE-SIZE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 34567))
SI::ESTIMATE-CODE-SIZE-1
(((:LAMBDA-LIST) SI::X SI::ENV) ((SI:LOCATION DEFUN SI::ESTIMATE-CODE-SIZE-1) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 34693))
ETYPECASE
(((DOCUMENTATION . FUNCTION) . "Syntax: (etypecase keyform {(type {form}*)}*)
Evaluates KEYFORM and searches a TYPE to which the value of KEYFORM belongs.
If found, then evaluates FORMs that follow the TYPE and returns all values of
the last FORM.  If not, signals an error.") ((:LAMBDA-LIST) SI::KEYFORM &REST SI::CLAUSES &AUX (SI::KEY (GENSYM))) ((SI:LOCATION DEFMACRO ETYPECASE) #P"SRC:LSP;ASSERT.LSP.NEWEST" . 6857))
SI::ETYPECASE-ERROR
(((:LAMBDA-LIST) SI::KEYFORM SI::VALUE SI::TYPES) ((SI:LOCATION DEFUN SI::ETYPECASE-ERROR) #P"SRC:LSP;ASSERT.LSP.NEWEST" . 6697))
EVAL
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FORM)

Evaluates FORM and returns all values.
") ((:LAMBDA-LIST) SI::FORM))
EVAL-WHEN
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (eval-when ({situation}*) {form}*)

Specifies when to evaluate FORMs.  Each SITUATION must be one of the following
symbols.
	COMPILE	(compile-time)
	LOAD	(load-time of the fasl file)
	EVAL	(load-time of the source file)
") ((:LAMBDA-LIST) . "(eval-when ({situation}*) {form}*)"))
SI::EVALHOOK
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (FORM FUN1 FUN2 &OPTIONAL (ENV NIL))

Evaluates FORM with *EVALHOOK* bound to FUN1 and *APPLYHOOK* bound to FUN2,
and returns all the values.
") ((:LAMBDA-LIST) SI::FORM SI::FUN1 SI::FUN2 &OPTIONAL (SI::ENV NIL)))
EVENP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (INTEGER)

Returns T if INTEGER is an even number; NIL otherwise.
") ((:LAMBDA-LIST) INTEGER))
EVERY
(((DOCUMENTATION . FUNCTION) . "Args: (predicate sequence &rest more-sequences)
Returns T if every elements of SEQUENCEs satisfy PREDICATE; NIL otherwise.") ((:LAMBDA-LIST) SI::PREDICATE SEQUENCE &REST SI::MORE-SEQUENCES) ((SI:LOCATION DEFUN EVERY) #P"SRC:LSP;SEQ.LSP.NEWEST" . 10729))
SI::EVERY*
(((DOCUMENTATION . FUNCTION) . "Args: (predicate sequence &rest more-sequences)
Returns T if every elements of SEQUENCEs satisfy PREDICATE and all sequences
have the same length; NIL otherwise.") ((:LAMBDA-LIST) SI::PREDICATE &REST SI::SEQUENCES) ((SI:LOCATION DEFUN SI::EVERY*) #P"SRC:LSP;SEQ.LSP.NEWEST" . 11486))
EXP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER)

Returns E raised to the power NUMBER, where E is the base of natural
logarithms.
") ((:LAMBDA-LIST) NUMBER))
C::EXPAND-AREF
(((:LAMBDA-LIST) ARRAY C::INDICES C::ENV) ((SI:LOCATION DEFUN C::EXPAND-AREF) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 5329))
C::EXPAND-ASET
(((:LAMBDA-LIST) ARRAY C::INDICES C::VALUE C::ENV) ((SI:LOCATION DEFUN C::EXPAND-ASET) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 6031))
C::EXPAND-ASSOC
(((:LAMBDA-LIST) C::VALUE LIST &REST C::SEQUENCE-ARGS) ((SI:LOCATION DEFUN C::EXPAND-ASSOC) #P"SRC:CMP;CMPOPT-SEQUENCE.LSP.NEWEST" . 8709))
SI::EXPAND-BIND-DEFAULTS
(((:LAMBDA-LIST) SI::SPECS SI::PARAMS &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::EXPAND-BIND-DEFAULTS) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 21402))
C::EXPAND-COERCE
(((:LAMBDA-LIST) C::FORM C::VALUE TYPE C::ENV) ((SI:LOCATION DEFUN C::EXPAND-COERCE) #P"SRC:CMP;CMPOPT.LSP.NEWEST" . 6727))
SI::EXPAND-CONTROL-STRING
(((:LAMBDA-LIST) STRING) ((SI:LOCATION DEFUN SI::EXPAND-CONTROL-STRING) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 18280))
CLOS::EXPAND-DEFMETHOD
(((:LAMBDA-LIST) CLOS:GENERIC-FUNCTION-NAME CLOS::QUALIFIERS CLOS::LAMBDA-LIST CLOS::REQUIRED-PARAMETERS CLOS::SPECIALIZERS CLOS::BODY CLOS::ENV) ((SI:LOCATION DEFUN CLOS::EXPAND-DEFMETHOD) #P"SRC:CLOS;METHOD.LSP.NEWEST" . 1779))
SI::EXPAND-DEFTYPE
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN SI::EXPAND-DEFTYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 21396))
C::EXPAND-DEFTYPE
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN C::EXPAND-DEFTYPE) #P"SRC:CMP;CMPTYPE.LSP.NEWEST" . 1518))
SI::EXPAND-DIRECTIVE
(((:LAMBDA-LIST) SI::DIRECTIVE SI::MORE-DIRECTIVES) ((SI:LOCATION DEFUN SI::EXPAND-DIRECTIVE) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 18280))
SI::EXPAND-DIRECTIVE-LIST
(((:LAMBDA-LIST) SI::DIRECTIVES) ((SI:LOCATION DEFUN SI::EXPAND-DIRECTIVE-LIST) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 18280))
SI::EXPAND-DO-SYMBOLS
(((:LAMBDA-LIST) SI::VAR PACKAGE SI::RESULT-FORM SI::BODY SI::OPTIONS) ((SI:LOCATION DEFUN SI::EXPAND-DO-SYMBOLS) #P"SRC:LSP;PACKLIB.LSP.NEWEST" . 3389))
C::EXPAND-FIND
(((:LAMBDA-LIST) C::VALUE SEQUENCE &REST C::SEQUENCE-ARGS) ((SI:LOCATION DEFUN C::EXPAND-FIND) #P"SRC:CMP;CMPOPT-SEQUENCE.LSP.NEWEST" . 10631))
SI::EXPAND-FORMAT-INTEGER
(((:LAMBDA-LIST) SI::BASE SI::COLONP SI::ATSIGNP SI::PARAMS) ((SI:LOCATION DEFUN SI::EXPAND-FORMAT-INTEGER) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 32525))
SI::EXPAND-FORMAT-JUSTIFICATION
(((:LAMBDA-LIST) SI::SEGMENTS SI::COLONP SI::ATSIGNP SI::FIRST-SEMI SI::PARAMS) ((SI:LOCATION DEFUN SI::EXPAND-FORMAT-JUSTIFICATION) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 82931))
SI::EXPAND-FORMAT-LOGICAL-BLOCK
(((:LAMBDA-LIST) SI::PREFIX SI::PER-LINE-P SI::INSIDES SI::SUFFIX SI::ATSIGNP) ((SI:LOCATION DEFUN SI::EXPAND-FORMAT-LOGICAL-BLOCK) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 89482))
C::EXPAND-IN-INTERVAL-P
(((:LAMBDA-LIST) C::VAR C::INTERVAL) ((SI:LOCATION DEFUN C::EXPAND-IN-INTERVAL-P) #P"SRC:CMP;CMPOPT.LSP.NEWEST" . 711))
C::EXPAND-MAPCAR
(((:LAMBDA-LIST) C::WHOLE) ((SI:LOCATION DEFUN C::EXPAND-MAPCAR) #P"SRC:CMP;CMPMAP.LSP.NEWEST" . 559))
SI::EXPAND-MAYBE-CONDITIONAL
(((:LAMBDA-LIST) SI::SUBLIST) ((SI:LOCATION DEFUN SI::EXPAND-MAYBE-CONDITIONAL) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 68168))
C::EXPAND-MEMBER
(((:LAMBDA-LIST) C::VALUE LIST &REST C::SEQUENCE-ARGS) ((SI:LOCATION DEFUN C::EXPAND-MEMBER) #P"SRC:CMP;CMPOPT-SEQUENCE.LSP.NEWEST" . 6432))
SI::EXPAND-NEXT-ARG
(((:LAMBDA-LIST) &OPTIONAL SI::OFFSET) ((SI:LOCATION DEFUN SI::EXPAND-NEXT-ARG) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 18280))
C::EXPAND-ROW-MAJOR-INDEX
(((:LAMBDA-LIST) C::A C::INDICES C::ENV) ((SI:LOCATION DEFUN C::EXPAND-ROW-MAJOR-INDEX) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 7321))
C::EXPAND-SIMPLE-OPTIMIZER
(((:LAMBDA-LIST) VALUES C::ARG-TYPES C::INLINE-FORM C::ENV) ((SI:LOCATION DEFUN C::EXPAND-SIMPLE-OPTIMIZER) #P"SRC:CMP;CMPOPT-CONS.LSP.NEWEST" . 532))
SI::EXPAND-TABS
(((:LAMBDA-LIST) STREAM SI::THROUGH) ((SI:LOCATION DEFUN SI::EXPAND-TABS) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 15569))
SI::EXPAND-TRUE-FALSE-CONDITIONAL
(((:LAMBDA-LIST) SI::TRUE SI::FALSE) ((SI:LOCATION DEFUN SI::EXPAND-TRUE-FALSE-CONDITIONAL) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 68783))
C::EXPAND-TYPEP
(((:LAMBDA-LIST) C::FORM FFI:OBJECT TYPE C::ENV) ((SI:LOCATION DEFUN C::EXPAND-TYPEP) #P"SRC:CMP;CMPOPT.LSP.NEWEST" . 1182))
C::EXPAND-VECTOR-INDEX-CHECK
(((:LAMBDA-LIST) C::A C::INDEX C::ENV) ((SI:LOCATION DEFUN C::EXPAND-VECTOR-INDEX-CHECK) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 6809))
C::EXPAND-VECTOR-PUSH
(((:LAMBDA-LIST) C::WHOLE C::ENV C::EXTEND) ((SI:LOCATION DEFUN C::EXPAND-VECTOR-PUSH) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 3691))
C::EXPAND-ZERO-DIM-INDEX-CHECK
(((:LAMBDA-LIST) C::A C::ENV) ((SI:LOCATION DEFUN C::EXPAND-ZERO-DIM-INDEX-CHECK) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 6631))
SI::EXPANDER-NEXT-ARG
(((:LAMBDA-LIST) STRING SI::OFFSET) ((SI:LOCATION DEFMACRO SI::EXPANDER-NEXT-ARG) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 18280))
SI::EXPANDER-PPRINT-NEXT-ARG
(((:LAMBDA-LIST) STRING SI::OFFSET) ((SI:LOCATION DEFMACRO SI::EXPANDER-PPRINT-NEXT-ARG) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 18280))
EXPORT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL &OPTIONAL (PACKAGE *PACKAGE*))

Register SYMBOL as an external symbol of PACKAGE.  SYMBOL may be a list of
symbols.
") ((:LAMBDA-LIST) SYMBOL &OPTIONAL (PACKAGE *PACKAGE*)))
C::EXPORTED-FNAME
(((:LAMBDA-LIST) C::NAME) ((SI:LOCATION DEFUN C::EXPORTED-FNAME) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 10043))
EXPT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER1 NUMBER2)

Returns NUMBER1 raised to the power NUMBER2.
") ((:LAMBDA-LIST) SI::NUMBER1 SI::NUMBER2))
SI::EXTEND-TYPE-TAG
(((:LAMBDA-LIST) SI::TAG SI::MINIMAL-SUPERTYPE-TAG) ((SI:LOCATION DEFUN SI::EXTEND-TYPE-TAG) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 43904))
EXTENDED-CHAR
(((DOCUMENTATION . TYPE) . "A character which is not of type BASE-CHAR."))
SI:EXTENDED-STRING
(((DOCUMENTATION . TYPE) . "A string which is nt a base string"))
SI:EXTERNAL-PROCESS
(((SI:LOCATION DEFCLASS SI:EXTERNAL-PROCESS) #P"SRC:LSP;PROCESS.LSP.NEWEST" . 519))
SI:EXTERNAL-PROCESS-STATUS
(((:LAMBDA-LIST) SI:EXTERNAL-PROCESS) ((SI:LOCATION DEFUN SI:EXTERNAL-PROCESS-STATUS) #P"SRC:LSP;PROCESS.LSP.NEWEST" . 708))
C::EXTRACT-CONSTANT-VALUE
(((:LAMBDA-LIST) C::FORM &OPTIONAL C::FAILURE) ((SI:LOCATION DEFUN C::EXTRACT-CONSTANT-VALUE) #P"SRC:CMP;CMPOPT-CONSTANT.LSP.NEWEST" . 865))
C::EXTRACT-LAMBDA-TYPE-CHECKS
(((:LAMBDA-LIST) C::FNAME C::REQUIREDS C::OPTIONALS C::KEYWORDS C::TS C::OTHER-DECLS) ((SI:LOCATION DEFUN C::EXTRACT-LAMBDA-TYPE-CHECKS) #P"SRC:CMP;CMPTYPE.LSP.NEWEST" . 3741))
SI::EXTRACT-USER-FUNCTION-NAME
(((:LAMBDA-LIST) STRING SI::START SI::END) ((SI:LOCATION DEFUN SI::EXTRACT-USER-FUNCTION-NAME) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 91998))
SI::FAST-SUBTYPEP
(((:LAMBDA-LIST) SI::T1 SI::T2) ((SI:LOCATION DEFUN SI::FAST-SUBTYPEP) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 47917))
CLOS::FAST-SUBTYPEP
(((:LAMBDA-LIST) CLOS::SPEC1 CLOS::SPEC2) ((SI:LOCATION DEFUN CLOS::FAST-SUBTYPEP) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 12689))
SI::FAST-TYPE=
(((:LAMBDA-LIST) SI::T1 SI::T2) ((SI:LOCATION DEFUN SI::FAST-TYPE=) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 49395))
SI::FAST-UPGRADED-ARRAY-ELEMENT-TYPE
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN SI::FAST-UPGRADED-ARRAY-ELEMENT-TYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 33490))
FBOUNDP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL)

Returns T if SYMBOL names a special form, a global macro, or a global
function.  Returns NIL otherwise.
") ((:LAMBDA-LIST) SYMBOL))
FCEILING
(((DOCUMENTATION . FUNCTION) . "Args: (number &optional (divisor 1))
Same as CEILING, but returns a float as the first value.") ((:LAMBDA-LIST) SI::X &OPTIONAL (SI::Y 1.0)) ((SI:LOCATION DEFUN FCEILING) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 8904))
FFLOOR
(((DOCUMENTATION . FUNCTION) . "Args: (number &optional (divisor 1))
Same as FLOOR, but returns a float as the first value.") ((:LAMBDA-LIST) SI::X &OPTIONAL (SI::Y 1)) ((SI:LOCATION DEFUN FFLOOR) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 8677))
FIFTH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CAR (CDDDDR X)).
") ((:LAMBDA-LIST) SI::X))
FILE-AUTHOR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC)

Returns the author of the specified file, as a string.  Returns NIL if the
author is unknown.  FILESPEC may be a symbol, a string, a pathname, or a file
stream.
") ((:LAMBDA-LIST) SI::FILESPEC))
FILE-ERROR
(((SI:LOCATION DEFCLASS FILE-ERROR) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
FILE-LENGTH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILE-STREAM)

Returns the length of the specified FILE-STREAM.  Returns NIL if the length is
unknown.
") ((:LAMBDA-LIST) FILE-STREAM))
FILE-NAMESTRING
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC)

Returns as a string the name, type, and version parts of the specified
pathname.  FILESPEC may be a symbol, a string, a pathname, or a file stream.
") ((:LAMBDA-LIST) SI::FILESPEC))
FILE-POSITION
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILE-STREAM &OPTIONAL FILE-POSITION)

With one arg, returns the current position of FILE-STREAM's file pointer as a
non-negative integer.  Returns NIL if the position is unknown.  With two args,
resets the file pointer and returns T.  Returns NIL if the file pointer cannot
be reset.  FILE-POSITION may be a non-negative integer, :START, or :END.
") ((:LAMBDA-LIST) FILE-STREAM &OPTIONAL FILE-POSITION))
FILE-WRITE-DATE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC)

Returns an integer that represents the last write day-and-time of the
specified file (See GET-DECODED-TIME).   Returns NIL if the last write day-
and-time is unknown.  FILESPEC may be a symbol, a string, a pathname, or a
file stream.
") ((:LAMBDA-LIST) SI::FILESPEC))
FILL
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SEQUENCE ITEM &KEY (START 0) (END (LENGTH SEQUENCE)))

Replaces the specified elements of SEQUENCE with ITEM.
") ((:LAMBDA-LIST) SEQUENCE SI::ITEM &KEY (SI::START 0) (SI::END (LENGTH SEQUENCE))) ((SI:LOCATION DEFUN FILL) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 4112))
SI::FILL-ARRAY-WITH-SEQ
(((:LAMBDA-LIST) ARRAY SI::INITIAL-CONTENTS) ((SI:LOCATION DEFUN SI::FILL-ARRAY-WITH-SEQ) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 2826))
FILL-POINTER
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (VECTOR)

Returns the fill-pointer of VECTOR as an integer.  VECTOR must have a fill-
pointer.
") ((:LAMBDA-LIST) VECTOR))
SI::FILTER-DUPLICATES-VECTOR
(((:LAMBDA-LIST) SI::OUT SI::IN SI::START SI::END SI::FROM-END SI::TEST SI::TEST-NOT SI::KEY) ((SI:LOCATION DEFUN SI::FILTER-DUPLICATES-VECTOR) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 24107))
C::FILTER-ONLY-DECLARATIONS
(((:LAMBDA-LIST) C::ASSUMPTIONS) ((SI:LOCATION DEFUN C::FILTER-ONLY-DECLARATIONS) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 9722))
SI::FILTER-VECTOR
(((:LAMBDA-LIST) SI::WHICH SI::OUT SI::IN SI::START SI::END SI::FROM-END COUNT SI::TEST SI::TEST-NOT SI::KEY) ((SI:LOCATION DEFUN SI::FILTER-VECTOR) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 5916))
CLOS:FINALIZE-INHERITANCE
(((SI:LOCATION DEFMETHOD CLOS:FINALIZE-INHERITANCE (CLASS STRUCTURE-CLASS)) #P"SRC:CLOS;BUILTIN.LSP.NEWEST" . 5116) ((SI:LOCATION DEFMETHOD CLOS:FINALIZE-INHERITANCE (CLASS CLOS::STD-CLASS)) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 13599) ((SI:LOCATION DEFMETHOD CLOS:FINALIZE-INHERITANCE (CLASS CLASS)) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 9668))
CLOS::FINALIZE-UNLESS-FORWARD
(((:LAMBDA-LIST) CLASS) ((SI:LOCATION DEFUN CLOS::FINALIZE-UNLESS-FORWARD) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 6058))
FIND
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ITEM SEQUENCE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT (START 0) (END (LENGTH SEQUENCE)) (FROM-END NIL))

Returns the first element in SEQUENCE satisfying TEST with ITEM.  Returns NIL
if no such element exists.
") ((SI:LOCATION DEFINE-COMPILER-MACRO FIND) #P"SRC:CMP;CMPOPT-SEQUENCE.LSP.NEWEST" . 11158) ((:LAMBDA-LIST) SI::ITEM SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::TEST '#'EQL) SI::TEST-NOT (SI::START 0) (SI::END (LENGTH SEQUENCE)) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN FIND) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 17414))
FIND-ALL-SYMBOLS
(((DOCUMENTATION . FUNCTION) . "Args: (string-designator)
Returns a list of all symbols that have the specified print name.
STRING-DESIGNATOR may be a symbol, in which case the print name of the symbol
is used.") ((:LAMBDA-LIST) SI::STRING-OR-SYMBOL) ((SI:LOCATION DEFUN FIND-ALL-SYMBOLS) #P"SRC:LSP;PACKLIB.LSP.NEWEST" . 575))
SI::FIND-BUILT-IN-TAG
(((:LAMBDA-LIST) SI::NAME) ((SI:LOCATION DEFUN SI::FIND-BUILT-IN-TAG) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 43298))
SI::FIND-DIRECTIVE
(((:LAMBDA-LIST) SI::DIRECTIVES SI::KIND SI::STOP-AT-SEMI) ((SI:LOCATION DEFUN SI::FIND-DIRECTIVE) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 26258))
SI::FIND-DUPLICATES
(((:LAMBDA-LIST) &REST SI::LISTS) ((SI:LOCATION DEFUN SI::FIND-DUPLICATES) #P"SRC:LSP;DEFPACKAGE.LSP.NEWEST" . 9179))
FFI:FIND-FOREIGN-LIBRARY
(((:LAMBDA-LIST) FFI::NAMES FFI::DIRECTORIES &KEY FFI::DRIVE-LETTERS FFI::TYPES) ((SI:LOCATION DEFUN FFI:FIND-FOREIGN-LIBRARY) #P"SRC:LSP;FFI.LSP.NEWEST" . 20664))
C::FIND-FORM-IN-NODE-LIST
(((:LAMBDA-LIST) C::FORM LIST) ((SI:LOCATION DEFUN C::FIND-FORM-IN-NODE-LIST) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 7050))
FIND-IF
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (FROM-END NIL))

Returns the index of the first element in SEQUENCE that satisfies TEST.
Returns NIL if no such element exists.
") ((:LAMBDA-LIST) SI::TEST SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::START 0) (SI::END (LENGTH SEQUENCE)) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN FIND-IF) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 17897))
FIND-IF-NOT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (FROM-END NIL))

Returns the index of the first element in SEQUENCE that does not satisfy TEST.
Returns NIL if no such element exists.
") ((:LAMBDA-LIST) SI::TEST SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::START 0) (SI::END (LENGTH SEQUENCE)) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN FIND-IF-NOT) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 18096))
C::FIND-INIT-NAME
(((:LAMBDA-LIST) C::FILE &KEY (C::TAG "@EcLtAg")) ((SI:LOCATION DEFUN C::FIND-INIT-NAME) #P"SRC:CMP;CMPNAME.LSP.NEWEST" . 2796))
FIND-METHOD
(((:LAMBDA-LIST) CLOS::GF CLOS::QUALIFIERS CLOS::SPECIALIZERS &OPTIONAL (CLOS::ERRORP T)) ((SI:LOCATION DEFUN FIND-METHOD) #P"SRC:CLOS;METHOD.LSP.NEWEST" . 12052))
SI::FIND-OR-MAKE-SYMBOL
(((:LAMBDA-LIST) SI::NAME PACKAGE) ((SI:LOCATION DEFUN SI::FIND-OR-MAKE-SYMBOL) #P"SRC:LSP;DEFPACKAGE.LSP.NEWEST" . 8816))
FIND-PACKAGE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NAME)

Returns the package whose package name or nickname is NAME.  Returns NIL if no
such package exists.  NAME may be a string or a symbol.
") ((:LAMBDA-LIST) SI::NAME))
SI::FIND-REGISTERED-TAG
(((:LAMBDA-LIST) TYPE &OPTIONAL (SI::TEST #'EQUAL)) ((SI:LOCATION DEFUN SI::FIND-REGISTERED-TAG) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 25526))
SI:FIND-RELATIVE-PACKAGE
(((:LAMBDA-LIST) SI::NAME) ((SI:LOCATION DEFUN SI:FIND-RELATIVE-PACKAGE) #P"SRC:LSP;PACKLIB.LSP.NEWEST" . 6880))
FIND-RESTART
(((:LAMBDA-LIST) SI::NAME &OPTIONAL CONDITION) ((SI:LOCATION DEFUN FIND-RESTART) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 2741))
SI::FIND-RESTART-NEVER-FAIL
(((:LAMBDA-LIST) RESTART &OPTIONAL CONDITION) ((SI:LOCATION DEFUN SI::FIND-RESTART-NEVER-FAIL) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 2948))
C::FIND-SLOT-ACCESSORS
(((:LAMBDA-LIST) C::GF) ((SI:LOCATION DEFUN C::FIND-SLOT-ACCESSORS) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 2094))
CLOS::FIND-SLOT-DEFINITION
(((:LAMBDA-LIST) CLASS CLOS::SLOT-NAME) ((SI:LOCATION DEFUN CLOS::FIND-SLOT-DEFINITION) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 9245))
SI::FIND-SUBCLASSES-OF-TYPE
(((:LAMBDA-LIST) TYPE CLASS) ((SI:LOCATION DEFUN SI::FIND-SUBCLASSES-OF-TYPE) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 8213))
FIND-SYMBOL
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING &OPTIONAL (PACKAGE *PACKAGE*))

Searches PACKAGE for a symbol whose print name is NAME.  If such a symbol is
found, then returns the symbol as the first value and returns one of the
following symbols as the second value.
	:INTERNAL (internal symbol in PACKAGE)
	:EXTERNAL (external symbol in PACKAGE)
	:INHERITED (external symbol of a package that PACKAGE is using)
If no such symbol is found, returns NIL as the first and second values.
") ((:LAMBDA-LIST) STRING &OPTIONAL (PACKAGE *PACKAGE*)))
SI::FIND-TYPE-BOUNDS
(((:LAMBDA-LIST) TYPE SI::IN-OUR-FAMILY-P SI::TYPE-<= SI::MINIMIZE-SUPER) ((SI:LOCATION DEFUN SI::FIND-TYPE-BOUNDS) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 27219))
FINISH-OUTPUT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&OPTIONAL (STREAM *STANDARD-OUTPUT*))

Sends the contents of the output buffer for STREAM to the destination.  Waits
until the buffer becomes empty and then returns NIL.
") ((:LAMBDA-LIST) &OPTIONAL (STREAM *STANDARD-OUTPUT*)))
FIRST
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to CAR.
") ((:LAMBDA-LIST) SI::X))
SI::FITS-ON-LINE-P
(((:LAMBDA-LIST) STREAM SI:UNTIL SI::FORCE-NEWLINES-P) ((SI:LOCATION DEFUN SI::FITS-ON-LINE-P) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 20356))
C::FIX-FOR-MINGW
(((:LAMBDA-LIST) DIRECTORY-NAMESTRING) ((SI:LOCATION DEFMACRO C::FIX-FOR-MINGW) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 4227))
C::FIX-READ-ONLY-VARIABLE-TYPE
(((:LAMBDA-LIST) C::VAR C::FORM C::REST-FORMS) ((SI:LOCATION DEFUN C::FIX-READ-ONLY-VARIABLE-TYPE) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 5294))
FIXNUM
(((DOCUMENTATION . TYPE) . "A FIXNUM is an integer between MOST-NEGATIVE-FIXNUM (= - 2^29 in ECL) and
MOST-POSITIVE-FIXNUM (= 2^29 - 1 in ECL) inclusive.  Other integers are
bignums."))
SI:FIXNUMP
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (X)

ECL specific.
Returns T if the X is a fixnum; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
FLET
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (flet ({(name lambda-list {decl | doc}* {form}*)}*) . body)

Introduces local functions and evaluates BODY as a PROGN.  BODY is the scope
of each local function but the local function definitions are not.  Thus each
local function can reference externally defined functions of the same name as
local functions.  Doc-strings for local functions are simply ignored.
") ((:LAMBDA-LIST) . "(flet ({(name lambda-list {decl | doc}* {form}*)}*) . body)"))
FLOAT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER &OPTIONAL FLOAT)

With one arg, converts NUMBER to a single-float.  With two args, converts
NUMBER to a float of the same float format as FLOAT.
") ((:LAMBDA-LIST) NUMBER &OPTIONAL FLOAT) ((DOCUMENTATION . TYPE) . "
A float (floating-point number) represents a real number or its approximation.
ECL supports two formats for floats.  One format is called SHORT-FLOAT and the
other format is called SINGLE-FLOAT, DOUBLE-FLOAT, or LONG-FLOAT.  Precisions
and exponent sizes of floats depends on the version of ECL.  See the ECL
Report at your hand for details.
The following syntax is used to notate a float.
	[+ | -] {digit}* . {digit}+ [exp]
	[+ | -] {digit}+ [. {digit}*}] exp
where DIGIT is a decimal digit (0,..,9) and EXP is
	marker [+ | -] {digit}+
with one of the following marker.
	e or E	the default float format
	s or S	short-float
	f or F	single-float
	d or D	double-float
	l or L	long-float
The default float format is single-float normally, but may be any other float
format.  See *READ-DEFAULT-FLOAT-FORMAT*."))
FLOAT-DIGITS
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FLOAT)

Returns the number of radix-B digits used to represent the significand of
FLOAT, where B is the base number used in the representation of FLOAT.
") ((:LAMBDA-LIST) FLOAT))
SI:FLOAT-INFINITY-STRING
(((:LAMBDA-LIST) CLOS::X) ((SI:LOCATION DEFUN SI:FLOAT-INFINITY-STRING) #P"SRC:CLOS;PRINT.LSP.NEWEST" . 6102))
SI:FLOAT-NAN-STRING
(((:LAMBDA-LIST) CLOS::X) ((SI:LOCATION DEFUN SI:FLOAT-NAN-STRING) #P"SRC:CLOS;PRINT.LSP.NEWEST" . 5732))
FLOAT-PRECISION
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FLOAT)

Returns the number of effective radix-B digits in the representation of the
significand of FLOAT, where B is the base number used in the representation
of FLOAT.
") ((:LAMBDA-LIST) FLOAT))
FLOAT-RADIX
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FLOAT)

Returns the base number used in the representation of FLOAT.
") ((:LAMBDA-LIST) FLOAT))
FLOAT-SIGN
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FLOAT1 &OPTIONAL (FLOAT2 (FLOAT 1 FLOAT1)))

Returns a float with the same sign as FLOAT1 and with the same absolute value
as FLOAT2.
") ((:LAMBDA-LIST) SI::FLOAT1 &OPTIONAL (SI::FLOAT2 (FLOAT 1 SI::FLOAT1))))
FLOATING-POINT-INEXACT
(((SI:LOCATION DEFCLASS FLOATING-POINT-INEXACT) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
FLOATING-POINT-INVALID-OPERATION
(((SI:LOCATION DEFCLASS FLOATING-POINT-INVALID-OPERATION) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
FLOATING-POINT-OVERFLOW
(((SI:LOCATION DEFCLASS FLOATING-POINT-OVERFLOW) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
FLOATING-POINT-UNDERFLOW
(((SI:LOCATION DEFCLASS FLOATING-POINT-UNDERFLOW) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
FLOATP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a float; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
SI::FLONUM-TO-STRING
(((:LAMBDA-LIST) SI::X &OPTIONAL SI::WIDTH SI::FDIGITS SI::SCALE SI::FMIN) ((SI:LOCATION DEFUN SI::FLONUM-TO-STRING) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 4500))
FLOOR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER &OPTIONAL (DIVISOR 1))

Returns the largest integer not larger than the NUMBER divided by DIVISOR.
Returns the value of (- NUMBER (* first-value DIVISOR)) as the second value.
") ((:LAMBDA-LIST) NUMBER &OPTIONAL (SI::DIVISOR 1)))
FMAKUNBOUND
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL)

Removes the global function definition associated with SYMBOL.  Returns SYMBOL.
") ((:LAMBDA-LIST) SYMBOL))
FORCE-OUTPUT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&OPTIONAL (STREAM *STANDARD-OUTPUT*))

Sends the contents of the output buffer for STREAM to the destination.
Returns NIL without waiting until the buffer becomes empty.
") ((:LAMBDA-LIST) &OPTIONAL (STREAM *STANDARD-OUTPUT*)))
SI::FORCE-PRETTY-OUTPUT
(((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFUN SI::FORCE-PRETTY-OUTPUT) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 24233))
C::FOREIGN-ELT-TYPE-CODE
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN C::FOREIGN-ELT-TYPE-CODE) #P"SRC:CMP;CMPCBK.LSP.NEWEST" . 2697))
FFI:FOREIGN-STRING-LENGTH
(((:LAMBDA-LIST) FFI::FOREIGN-STRING) ((SI:LOCATION DEFUN FFI:FOREIGN-STRING-LENGTH) #P"SRC:LSP;FFI.LSP.NEWEST" . 13835))
C::FORM-CAUSES-SIDE-EFFECT
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::FORM-CAUSES-SIDE-EFFECT) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 6644))
FORMAT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (DESTINATION FORMAT-STRING &REST ARGS)

Outputs ARGs to DESTINATION in the format specified by FORMAT-STRING.  FORMAT-
STRING is a string consisting of characters to output and format directives
which begin with '~~'.  Outputs to DESTINATION if it is a stream and to the
standard output if DESTINATION is T.  If DESTINATION is NIL, does not output
actually but returns the output as a string.  Here are some format directives:
	~~A	PRINCs one arg
	~~S	PRIN1s one arg
	~~D	Prints one integer in decimal
	~~B	Prints one integer in binary
	~~O	Prints one integer in octal
	~~X	Prints one integer in hexa
	~~%	Does TERPRI
	~~&	Does FRESH-LINE
	~~|	Outputs #\\Page
	~~~~	Outputs '~~'
") ((:LAMBDA-LIST) SI::DESTINATION SI::FORMAT-STRING &REST SI::ARGS))
SI::FORMAT-ABSOLUTE-TAB
(((:LAMBDA-LIST) STREAM SI::COLNUM SI::COLINC) ((SI:LOCATION DEFUN SI::FORMAT-ABSOLUTE-TAB) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 58227))
SI::FORMAT-ADD-COMMAS
(((:LAMBDA-LIST) STRING SI::COMMACHAR SI::COMMAINTERVAL) ((SI:LOCATION DEFUN SI::FORMAT-ADD-COMMAS) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 31902))
SI::FORMAT-DOLLARS
(((:LAMBDA-LIST) STREAM NUMBER SI::D SI::N SI::W SI::PAD SI::COLON SI::ATSIGN) ((SI:LOCATION DEFUN SI::FORMAT-DOLLARS) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 51139))
SI:FORMAT-ERROR
(((SI:LOCATION DEFCLASS SI:FORMAT-ERROR) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
SI::FORMAT-EXP-AUX
(((:LAMBDA-LIST) STREAM NUMBER SI::W SI::D SI::E SI::K SI::OVF SI::PAD SI::MARKER SI::ATSIGN) ((SI:LOCATION DEFUN SI::FORMAT-EXP-AUX) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 46659))
SI::FORMAT-EXPONENT-MARKER
(((:LAMBDA-LIST) NUMBER) ((SI:LOCATION DEFUN SI::FORMAT-EXPONENT-MARKER) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 45686))
SI::FORMAT-EXPONENTIAL
(((:LAMBDA-LIST) STREAM NUMBER SI::W SI::D SI::E SI::K SI::OVF SI::PAD SI::MARKER SI::ATSIGN) ((SI:LOCATION DEFUN SI::FORMAT-EXPONENTIAL) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 45181))
SI::FORMAT-FIXED
(((:LAMBDA-LIST) STREAM NUMBER SI::W SI::D SI::K SI::OVF SI::PAD SI::ATSIGN) ((SI:LOCATION DEFUN SI::FORMAT-FIXED) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 42550))
SI::FORMAT-FIXED-AUX
(((:LAMBDA-LIST) STREAM NUMBER SI::W SI::D SI::K SI::OVF SI::PAD SI::ATSIGN) ((SI:LOCATION DEFUN SI::FORMAT-FIXED-AUX) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 43123))
SI::FORMAT-GENERAL
(((:LAMBDA-LIST) STREAM NUMBER SI::W SI::D SI::E SI::K SI::OVF SI::PAD SI::MARKER SI::ATSIGN) ((SI:LOCATION DEFUN SI::FORMAT-GENERAL) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 49056))
SI::FORMAT-GENERAL-AUX
(((:LAMBDA-LIST) STREAM NUMBER SI::W SI::D SI::E SI::K SI::OVF SI::PAD SI::MARKER SI::ATSIGN) ((SI:LOCATION DEFUN SI::FORMAT-GENERAL-AUX) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 49623))
SI::FORMAT-JUSTIFICATION
(((:LAMBDA-LIST) STREAM SI::NEWLINE-PREFIX SI::EXTRA-SPACE SI::LINE-LEN SI::STRINGS SI::PAD-LEFT SI::PAD-RIGHT SI::MINCOL SI::COLINC SI::MINPAD SI::PADCHAR) ((SI:LOCATION DEFUN SI::FORMAT-JUSTIFICATION) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 85329))
SI::FORMAT-PRIN1
(((:LAMBDA-LIST) STREAM SI::ARG SI::COLONP SI::ATSIGNP SI::MINCOL SI::COLINC SI::MINPAD SI::PADCHAR) ((SI:LOCATION DEFUN SI::FORMAT-PRIN1) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 28410))
SI::FORMAT-PRINC
(((:LAMBDA-LIST) STREAM SI::ARG SI::COLONP SI::ATSIGNP SI::MINCOL SI::COLINC SI::MINPAD SI::PADCHAR) ((SI:LOCATION DEFUN SI::FORMAT-PRINC) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 27448))
SI::FORMAT-PRINT-CARDINAL
(((:LAMBDA-LIST) STREAM SI::N) ((SI:LOCATION DEFUN SI::FORMAT-PRINT-CARDINAL) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 37320))
SI::FORMAT-PRINT-CARDINAL-AUX
(((:LAMBDA-LIST) STREAM SI::N SI::PERIOD SI::ERR) ((SI:LOCATION DEFUN SI::FORMAT-PRINT-CARDINAL-AUX) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 37599))
SI::FORMAT-PRINT-INTEGER
(((:LAMBDA-LIST) STREAM NUMBER SI::PRINT-COMMAS-P SI::PRINT-SIGN-P SI::RADIX SI::MINCOL SI::PADCHAR SI::COMMACHAR SI::COMMAINTERVAL) ((SI:LOCATION DEFUN SI::FORMAT-PRINT-INTEGER) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 31209))
SI::FORMAT-PRINT-NAMED-CHARACTER
(((:LAMBDA-LIST) CHAR STREAM) ((SI:LOCATION DEFUN SI::FORMAT-PRINT-NAMED-CHARACTER) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 30168))
SI::FORMAT-PRINT-OLD-ROMAN
(((:LAMBDA-LIST) STREAM SI::N) ((SI:LOCATION DEFUN SI::FORMAT-PRINT-OLD-ROMAN) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 39212))
SI::FORMAT-PRINT-ORDINAL
(((:LAMBDA-LIST) STREAM SI::N) ((SI:LOCATION DEFUN SI::FORMAT-PRINT-ORDINAL) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 38113))
SI::FORMAT-PRINT-ROMAN
(((:LAMBDA-LIST) STREAM SI::N) ((SI:LOCATION DEFUN SI::FORMAT-PRINT-ROMAN) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 39719))
SI::FORMAT-PRINT-SMALL-CARDINAL
(((:LAMBDA-LIST) STREAM SI::N) ((SI:LOCATION DEFUN SI::FORMAT-PRINT-SMALL-CARDINAL) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 36576))
SI::FORMAT-RELATIVE-TAB
(((:LAMBDA-LIST) STREAM SI::COLREL SI::COLINC) ((SI:LOCATION DEFUN SI::FORMAT-RELATIVE-TAB) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 57798))
SI::FORMAT-WRITE-FIELD
(((:LAMBDA-LIST) STREAM STRING SI::MINCOL SI::COLINC SI::MINPAD SI::PADCHAR SI::PADLEFT) ((SI:LOCATION DEFUN SI::FORMAT-WRITE-FIELD) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 26980))
FORMATTER
(((:LAMBDA-LIST) SI::CONTROL-STRING) ((SI:LOCATION DEFMACRO FORMATTER) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 18280))
SI:FORMATTER-AUX
(((:LAMBDA-LIST) STREAM SI::STRING-OR-FUN SI::ORIG-ARGS &OPTIONAL (SI::ARGS SI::ORIG-ARGS)) ((SI:LOCATION DEFUN SI:FORMATTER-AUX) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 16721))
CLOS:FORWARD-REFERENCED-CLASS
(((SI:LOCATION DEFCLASS CLOS:FORWARD-REFERENCED-CLASS) #P"SRC:CLOS;CHANGE.LSP.NEWEST" . 512))
CLOS::FORWARD-REFERENCED-CLASS-P
(((:LAMBDA-LIST) CLOS::X) ((SI:LOCATION DEFUN CLOS::FORWARD-REFERENCED-CLASS-P) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 9107))
FOURTH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to CADDDR.
") ((:LAMBDA-LIST) SI::X))
FFI:FREE-CSTRING
(((:LAMBDA-LIST) FFI:OBJECT) ((SI:LOCATION DEFMACRO FFI:FREE-CSTRING) #P"SRC:LSP;FFI.LSP.NEWEST" . 13506))
FFI:FREE-FOREIGN-OBJECT
(((:LAMBDA-LIST) FFI::PTR) ((SI:LOCATION DEFUN FFI:FREE-FOREIGN-OBJECT) #P"SRC:LSP;FFI.LSP.NEWEST" . 5187))
CLOS::FREEZE-CLASS-SLOT-INITFUNCTION
(((:LAMBDA-LIST) CLOS::SLOTD) ((SI:LOCATION DEFUN CLOS::FREEZE-CLASS-SLOT-INITFUNCTION) #P"SRC:CLOS;SLOT.LSP.NEWEST" . 2476))
FRESH-LINE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&OPTIONAL (STREAM *STANDARD-OUTPUT*))

Outputs a newline character only if the current position of STREAM is not at
the beginning of a line.  Returns T if it outputs a newline; NIL otherwise.
") ((:LAMBDA-LIST) &OPTIONAL (STREAM *STANDARD-OUTPUT*)))
FROUND
(((DOCUMENTATION . FUNCTION) . "Args: (number &optional (divisor 1))
Same as ROUND, but returns a float as the first value.") ((:LAMBDA-LIST) SI::X &OPTIONAL (SI::Y 1.0)) ((SI:LOCATION DEFUN FROUND) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 9381))
SI:FRS-BDS
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (N)

ECL specific.
Returns the bind stack index of the N-th entity in the frame stack.
") ((:LAMBDA-LIST) SI::N))
SI:FRS-IHS
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (N)

ECL specific.
Returns the invocation history stack index of the N-th entity in the frame
stack.
") ((:LAMBDA-LIST) SI::N))
FTRUNCATE
(((DOCUMENTATION . FUNCTION) . "Args: (number &optional (divisor 1))
Same as TRUNCATE, but returns a float as the first value.") ((:LAMBDA-LIST) SI::X &OPTIONAL (SI::Y 1.0)) ((SI:LOCATION DEFUN FTRUNCATE) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 9141))
C::FUN
(((SI:LOCATION DEFCLASS C::FUN) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 5093))
C::FUN-FIXED-NARG
(((:LAMBDA-LIST) C::FUN) ((SI:LOCATION DEFUN C::FUN-FIXED-NARG) #P"SRC:CMP;CMPLAM.LSP.NEWEST" . 1717))
C::FUN-NEEDS-NARG
(((:LAMBDA-LIST) C::FUN) ((SI:LOCATION DEFUN C::FUN-NEEDS-NARG) #P"SRC:CMP;CMPLAM.LSP.NEWEST" . 1658))
C::FUN-REFERRED-LOCAL-VARS
(((:LAMBDA-LIST) C::FUN) ((SI:LOCATION DEFUN C::FUN-REFERRED-LOCAL-VARS) #P"SRC:CMP;CMPFLET.LSP.NEWEST" . 3241))
FUNCALL
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FUNCTION &REST ARGS)

Calls FUNCTION with the ARGs as the arguments and returns all values that the
call returns.
") ((:LAMBDA-LIST) FUNCTION &REST SI::ARGS))
CLOS:FUNCALLABLE-STANDARD-OBJECT
(((SI:LOCATION DEFCLASS CLOS:FUNCALLABLE-STANDARD-OBJECT) #P"SRC:CLOS;STDMETHOD.LSP.NEWEST" . 645))
FUNCTION
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (function x) | #'x

If X is a lambda expression, creates and returns a lexical closure of X in the
current lexical environment.  If X is a symbol that names a function, returns
that function definition.
") ((:LAMBDA-LIST) . "(function x) | #'x") ((DOCUMENTATION . TYPE) . "
A function object specifies a function to be invoked by function-calling
functions such as FUNCALL or APPLY.  A function is either:
	1. a compiled function
	2. a list of one of the following form
		(lambda lambda-list . body)
		(lambda-block block-name lambda-list . body)
		(lambda-closure env1 env2 env3 lambda-list . body)
		(lambda-block-closure env1 env2 env3 block-name lambda-list
		                      . body)
	   where ENV1, ENV2, and ENV3 respectively represent the variable
	   environment, the function/macro environment, and the block/tagbody
	   environment at the time of the function creation.
	3. a symbol that names a global function."))
C::FUNCTION-ARG-TYPES
(((:LAMBDA-LIST) C::ARG-TYPES &AUX (C::TYPES NIL)) ((SI:LOCATION DEFUN C::FUNCTION-ARG-TYPES) #P"SRC:CMP;CMPENV-FUN.LSP.NEWEST" . 582))
FUNCTION-KEYWORDS
(((:LAMBDA-LIST) METHOD) ((SI:LOCATION DEFUN FUNCTION-KEYWORDS) #P"SRC:CLOS;STDMETHOD.LSP.NEWEST" . 1416))
SI:FUNCTION-LAMBDA-LIST
(((:LAMBDA-LIST) FUNCTION) ((SI:LOCATION DEFUN SI:FUNCTION-LAMBDA-LIST) #P"SRC:LSP;TOP.LSP.NEWEST" . 28749))
C::FUNCTION-MAY-CHANGE-SP
(((:LAMBDA-LIST) C::FNAME) ((SI:LOCATION DEFUN C::FUNCTION-MAY-CHANGE-SP) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 6884))
C::FUNCTION-MAY-HAVE-SIDE-EFFECTS
(((:LAMBDA-LIST) C::FNAME) ((SI:LOCATION DEFUN C::FUNCTION-MAY-HAVE-SIDE-EFFECTS) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 6790))
C::FUNCTION-RETURN-TYPE
(((:LAMBDA-LIST) C::RETURN-TYPES) ((SI:LOCATION DEFUN C::FUNCTION-RETURN-TYPE) #P"SRC:CMP;CMPENV-FUN.LSP.NEWEST" . 911))
CLOS::FUNCTION-TO-METHOD
(((:LAMBDA-LIST) CLOS::NAME CLOS::SIGNATURE) ((SI:LOCATION DEFUN CLOS::FUNCTION-TO-METHOD) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 7592))
FUNCTIONP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is an object that can be used to specify a function to be
invoked by function-calling functions such as FUNCALL or APPLY.  Returns NIL
otherwise.
") ((:LAMBDA-LIST) SI::X))
GRAY:FUNDAMENTAL-BINARY-INPUT-STREAM
(((SI:LOCATION DEFCLASS GRAY:FUNDAMENTAL-BINARY-INPUT-STREAM) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 10248))
GRAY:FUNDAMENTAL-BINARY-OUTPUT-STREAM
(((SI:LOCATION DEFCLASS GRAY:FUNDAMENTAL-BINARY-OUTPUT-STREAM) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 10353))
GRAY:FUNDAMENTAL-BINARY-STREAM
(((SI:LOCATION DEFCLASS GRAY:FUNDAMENTAL-BINARY-STREAM) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 9961))
GRAY:FUNDAMENTAL-CHARACTER-INPUT-STREAM
(((SI:LOCATION DEFCLASS GRAY:FUNDAMENTAL-CHARACTER-INPUT-STREAM) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 10024))
GRAY:FUNDAMENTAL-CHARACTER-OUTPUT-STREAM
(((SI:LOCATION DEFCLASS GRAY:FUNDAMENTAL-CHARACTER-OUTPUT-STREAM) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 10135))
GRAY:FUNDAMENTAL-CHARACTER-STREAM
(((SI:LOCATION DEFCLASS GRAY:FUNDAMENTAL-CHARACTER-STREAM) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 9895))
GRAY:FUNDAMENTAL-INPUT-STREAM
(((SI:LOCATION DEFCLASS GRAY:FUNDAMENTAL-INPUT-STREAM) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 9770))
GRAY:FUNDAMENTAL-OUTPUT-STREAM
(((SI:LOCATION DEFCLASS GRAY:FUNDAMENTAL-OUTPUT-STREAM) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 9832))
GRAY:FUNDAMENTAL-STREAM
(((SI:LOCATION DEFCLASS GRAY:FUNDAMENTAL-STREAM) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 9609))
SI:GC
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (X)

ECL specific.
Starts garbage collection with the specified collection level.  If X is NIL,
collects only cells.  If X is T, collects everything.
") ((:LAMBDA-LIST) SI::X))
GCD
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&REST INTEGERS)

Returns the greatest common divisor of the args.
") ((:LAMBDA-LIST) &REST SI::INTEGERS))
GENERIC-FUNCTION
(((SI:LOCATION DEFCLASS GENERIC-FUNCTION) #P"SRC:CLOS;STDMETHOD.LSP.NEWEST" . 888))
CLOS::GENERIC-FUNCTION-A-P-O-FUNCTION
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS::GENERIC-FUNCTION-A-P-O-FUNCTION) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS::GENERIC-FUNCTION-A-P-O-FUNCTION) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 4576))
CLOS:GENERIC-FUNCTION-ARGUMENT-PRECEDENCE-ORDER
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS:GENERIC-FUNCTION-ARGUMENT-PRECEDENCE-ORDER) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS:GENERIC-FUNCTION-ARGUMENT-PRECEDENCE-ORDER) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 4576))
CLOS::GENERIC-FUNCTION-DEPENDENTS
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS::GENERIC-FUNCTION-DEPENDENTS) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS::GENERIC-FUNCTION-DEPENDENTS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 4576))
CLOS:GENERIC-FUNCTION-LAMBDA-LIST
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS:GENERIC-FUNCTION-LAMBDA-LIST) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS:GENERIC-FUNCTION-LAMBDA-LIST) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 4576))
CLOS:GENERIC-FUNCTION-METHOD-CLASS
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS:GENERIC-FUNCTION-METHOD-CLASS) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS:GENERIC-FUNCTION-METHOD-CLASS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 4576))
CLOS:GENERIC-FUNCTION-METHOD-COMBINATION
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS:GENERIC-FUNCTION-METHOD-COMBINATION) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS:GENERIC-FUNCTION-METHOD-COMBINATION) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 4576))
CLOS:GENERIC-FUNCTION-METHODS
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS:GENERIC-FUNCTION-METHODS) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS:GENERIC-FUNCTION-METHODS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 4576))
CLOS:GENERIC-FUNCTION-NAME
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS:GENERIC-FUNCTION-NAME) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS:GENERIC-FUNCTION-NAME) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 4576))
CLOS::GENERIC-FUNCTION-SPEC-LIST
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS::GENERIC-FUNCTION-SPEC-LIST) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS::GENERIC-FUNCTION-SPEC-LIST) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 4576))
GENSYM
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&OPTIONAL (X NIL))

Creates and returns a new uninterned symbol whose print name begins with some
prefix (initially \"G\"), followed by a generation number.  The generation
number is incremented by one at each call to GENSYM.  If X is an integer, it
becomes the new generation number.  If X is a string, it becomes the new
prefix.
") ((:LAMBDA-LIST) &OPTIONAL (SI::X NIL)))
GENTEMP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&OPTIONAL (STRING \"T\") (PACKAGE *PACKAGE*))

Creates a new symbol interned in PACKAGE with PREFIX and returns the symbol.
The symbol is given a print name beginning with PREFIX followed by some
generation number.
") ((:LAMBDA-LIST) &OPTIONAL (STRING SI::|"T"|) (PACKAGE *PACKAGE*)))
GET
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL PROPERTY &OPTIONAL (DEFAULT NIL))

Searches the symbol property of SYMBOL for a property that is EQ to PROPERTY.
If found, returns the value of the property.  Otherwise, returns DEFAULT.
") ((:LAMBDA-LIST) SYMBOL SI::PROPERTY &OPTIONAL (SI::DEFAULT NIL)))
C::GET-ARG-TYPES
(((:LAMBDA-LIST) C::FNAME &OPTIONAL (C::ENV C::*CMP-ENV*) (C::MAY-BE-GLOBAL T)) ((SI:LOCATION DEFUN C::GET-ARG-TYPES) #P"SRC:CMP;CMPENV-FUN.LSP.NEWEST" . 2844))
GET-DECODED-TIME
(((DOCUMENTATION . FUNCTION) . "Args: ()
Returns the current day-and-time as nine values:
	second (0 - 59)
	minute (0 - 59)
	hour (0 - 23)
	date (1 - 31)
	month (1 - 12)
	year (Christian, not Japanese long-live-Emperor)
	day of week (0 for Mon, .. 6 for Sun)
	summer time or not (T or NIL)
	time zone (-9 in Japan)
Sunday is the *last* day of the week!!") ((:LAMBDA-LIST)) ((SI:LOCATION DEFUN GET-DECODED-TIME) #P"SRC:LSP;MISLIB.LSP.NEWEST" . 8788))
GET-DISPATCH-MACRO-CHARACTER
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR SUBCHAR &OPTIONAL (READTABLE *READTABLE*))

Returns the read macro for SUBCHAR associated with the dispatch macro
character CHAR in READTABLE.
") ((:LAMBDA-LIST) CHAR SI::SUBCHAR &OPTIONAL (READTABLE *READTABLE*)))
C::GET-INLINE-INFO
(((:LAMBDA-LIST) C::FNAME C::TYPES C::RETURN-TYPE C::RETURN-REP-TYPE) ((SI:LOCATION DEFUN C::GET-INLINE-INFO) #P"SRC:CMP;CMPC-INLINER.LSP.NEWEST" . 3322))
GET-INTERNAL-REAL-TIME
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: NIL

Returns the time (in 1/100 seconds) since the invocation of ECL.
") ((:LAMBDA-LIST)))
GET-INTERNAL-RUN-TIME
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: NIL

Returns the CPU time (in 1/100 seconds) since the invocation of ECL.
") ((:LAMBDA-LIST)))
C::GET-LOCAL-ARG-TYPES
(((:LAMBDA-LIST) C::FUN &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::GET-LOCAL-ARG-TYPES) #P"SRC:CMP;CMPENV-FUN.LSP.NEWEST" . 3551))
C::GET-LOCAL-RETURN-TYPE
(((:LAMBDA-LIST) C::FUN &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::GET-LOCAL-RETURN-TYPE) #P"SRC:CMP;CMPENV-FUN.LSP.NEWEST" . 3729))
GET-MACRO-CHARACTER
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR &OPTIONAL (READTABLE *READTABLE*))

Returns the read macro associated with the macro character CHAR in READTABLE.
Returns the non-terminating-p flag (see READTABLE) as the second value.
Returns NIL if CHAR is not a macro character.
") ((:LAMBDA-LIST) CHAR &OPTIONAL (READTABLE *READTABLE*)))
GET-OUTPUT-STREAM-STRING
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING-OUTPUT-STREAM)

Returns as a string all outputs to STRING-OUTPUT-STREAM since the last call of
GET-OUTPUT-STREAM-STRING for the same stream.
") ((:LAMBDA-LIST) SI::STRING-OUTPUT-STREAM))
C::GET-PROCLAIMED-NARG
(((:LAMBDA-LIST) C::FUN &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::GET-PROCLAIMED-NARG) #P"SRC:CMP;CMPENV-FUN.LSP.NEWEST" . 3910))
GET-PROPERTIES
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (PLIST LIST)

Searches PLIST for a property that is EQ to one of the members of LIST.
Returns three values.  If such a property if found, returns the property, the
value of the property, and the rest of LIST.  If not, returns three NILs.
") ((:LAMBDA-LIST) SI::PLIST LIST))
C::GET-RETURN-TYPE
(((:LAMBDA-LIST) C::FNAME &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::GET-RETURN-TYPE) #P"SRC:CMP;CMPENV-FUN.LSP.NEWEST" . 3225))
GET-SETF-EXPANSION
(((DOCUMENTATION . FUNCTION) . "Args: (form)
Returns the 'five gangs' (see DEFINE-SETF-EXPANDER) for PLACE as five values.
Does not check if the third gang is a single-element list.") ((:LAMBDA-LIST) SI::FORM &OPTIONAL SI::ENV &AUX SI::F) ((SI:LOCATION DEFUN GET-SETF-EXPANSION) #P"SRC:LSP;SETF.LSP.NEWEST" . 3752))
FFI:GET-SLOT-POINTER
(((:LAMBDA-LIST) FFI:OBJECT FFI::STRUCT-TYPE FFI::FIELD) ((SI:LOCATION DEFUN FFI:GET-SLOT-POINTER) #P"SRC:LSP;FFI.LSP.NEWEST" . 8163))
C::GET-SLOT-TYPE
(((:LAMBDA-LIST) C::NAME C::INDEX) ((SI:LOCATION DEFUN C::GET-SLOT-TYPE) #P"SRC:CMP;CMPSTRUCTURES.LSP.NEWEST" . 634))
FFI:GET-SLOT-VALUE
(((:LAMBDA-LIST) FFI:OBJECT FFI::STRUCT-TYPE FFI::FIELD) ((SI:LOCATION DEFUN FFI:GET-SLOT-VALUE) #P"SRC:LSP;FFI.LSP.NEWEST" . 7562))
GET-UNIVERSAL-TIME
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: NIL

Returns the current day-and-time as an integer.  See DECODE-UNIVERSAL-TIME.
") ((:LAMBDA-LIST)))
SI:GETCWD
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (&OPTIONAL (UPDATE-LISP T))

Returns the current working directory of the C library. When UPDATE-LISP is
true, *DEFAULT-PATHNAME-DEFAULTS* is set to this value.
") ((:LAMBDA-LIST) &OPTIONAL (SI::UPDATE-LISP T)))
SI:GETENV
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (STRING)

ECL/UNIX specific.
Returns the environment with the name STRING as a string.  Returns NIL, if the
specified environment is not found.
") ((:LAMBDA-LIST) STRING))
GETF
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (PLIST PROPERTY &OPTIONAL (DEFAULT NIL))

Searches PLIST for a property that is EQ to PROPERTY.  If one is found,
returns the value of the property.  If not, returns DEFAULT.
The SETF form
	(setf (getf place property-form) value-form)
replaces the property value of the plist stored in PLACE, or adds a new
property if the plist does not have the property yet.
") ((:LAMBDA-LIST) SI::PLIST SI::PROPERTY &OPTIONAL (SI::DEFAULT NIL)))
GETHASH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (KEY HASH-TABLE &OPTIONAL (DEFAULT NIL))

Searches HASH-TABLE for the entry of KEY.  If found, returns the value of the
entry and T, as two values.  If not, returns DEFAULT and NIL.
") ((:LAMBDA-LIST) SI::KEY HASH-TABLE &OPTIONAL (SI::DEFAULT NIL)))
SI::GFUN-INSTANCE
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (GFUN)

ECL/CLOS specific.
Returns the generic function instance associated with the GFUN
generic function object.
") ((:LAMBDA-LIST) SI::GFUN))
SI::GFUN-INSTANCE-SET
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (GFUN INSTANCE)

ECL/CLOS specific.
Sets to INSTANCE the generic function instance associated with the
FUN generic function object.
") ((:LAMBDA-LIST) SI::GFUN SI:INSTANCE))
SI::GFUN-METHOD-HT
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (GFUN)

ECL/CLOS specific.
Returns the hashtable for caching methods associated with the GFUN
generic function object.
") ((:LAMBDA-LIST) SI::GFUN))
SI::GFUN-METHOD-HT-SET
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (GFUN HASH-TABLE)

ECL/CLOS specific.
Sets to HASH-TABLE the hashtable for caching methods associated with the
GFUN generic function object.
") ((:LAMBDA-LIST) SI::GFUN HASH-TABLE))
SI::GFUN-NAME
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (GFUN)

ECL/CLOS specific.
Returns the name of the GFUN generic function object.
") ((:LAMBDA-LIST) SI::GFUN))
SI::GFUN-NAME-SET
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (GFUN NAME)

ECL/CLOS specific.
Sets to NAME the name of the GFUN generic function object.
") ((:LAMBDA-LIST) SI::GFUN SI::NAME))
SI::GFUN-SPEC-HOW-REF
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (GFUN INDEX)

ECL/CLOS specific.
Returns the INDEX-th element of specialization list associated  with the
GFUN generic function object. The first element has INDEX equal to zero.
") ((:LAMBDA-LIST) SI::GFUN SI::INDEX))
SI::GFUN-SPEC-HOW-SET
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (GFUN INDEX SPECIALIZER)

ECL/CLOS specific.
Sets to SPECIALIZER the INDEX-th element of specialization list associated
with the GFUN generic function object. The first element has INDEX
equal to zero.
") ((:LAMBDA-LIST) SI::GFUN SI::INDEX SI::SPECIALIZER))
SI::GFUNP
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (OBJECT)

ECL/CLOS specific.
Returns T if OBJECT is of gfun type.
") ((:LAMBDA-LIST) SI::OBJECT))
C::GLOBAL-VAR-P
(((:LAMBDA-LIST) C::VAR) ((SI:LOCATION DEFUN C::GLOBAL-VAR-P) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 8325))
GO
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (go tag)

Jumps to TAG.  See TAGBODY.
") ((:LAMBDA-LIST) . "(go tag)"))
GRAPHIC-CHAR-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR)

Returns T if CHAR is a printing character, i.e., a standard character other
than #\\Newline.  Returns NIL otherwise.
") ((:LAMBDA-LIST) CHAR))
C::GUESS-ARRAY-DIMENSIONS-TYPE
(((:LAMBDA-LIST) C::ORIG-DIMENSIONS &AUX C::DIMENSIONS) ((SI:LOCATION DEFUN C::GUESS-ARRAY-DIMENSIONS-TYPE) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 828))
C::GUESS-ARRAY-ELEMENT-TYPE
(((:LAMBDA-LIST) C::ELEMENT-TYPE) ((SI:LOCATION DEFUN C::GUESS-ARRAY-ELEMENT-TYPE) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 612))
C::GUESS-INIT-NAME
(((:LAMBDA-LIST) PATHNAME C::KIND) ((SI:LOCATION DEFUN C::GUESS-INIT-NAME) #P"SRC:CMP;CMPNAME.LSP.NEWEST" . 3474))
C::GUESS-KIND
(((:LAMBDA-LIST) PATHNAME) ((SI:LOCATION DEFUN C::GUESS-KIND) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 9015))
C::GUESS-LD-FLAGS
(((:LAMBDA-LIST) PATHNAME &KEY (C::KIND (C::GUESS-KIND PATHNAME))) ((SI:LOCATION DEFUN C::GUESS-LD-FLAGS) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 9549))
C::HANDLE-COMPILER-ERROR
(((:LAMBDA-LIST) C::C) ((SI:LOCATION DEFUN C::HANDLE-COMPILER-ERROR) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 5670))
C::HANDLE-COMPILER-INTERNAL-ERROR
(((:LAMBDA-LIST) C::C) ((SI:LOCATION DEFUN C::HANDLE-COMPILER-INTERNAL-ERROR) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 5792))
C::HANDLE-COMPILER-NOTE
(((:LAMBDA-LIST) C::C) ((SI:LOCATION DEFUN C::HANDLE-COMPILER-NOTE) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 5556))
C::HANDLE-COMPILER-WARNING
(((:LAMBDA-LIST) C::C) ((SI:LOCATION DEFUN C::HANDLE-COMPILER-WARNING) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 5594))
HANDLER-BIND
(((:LAMBDA-LIST) SI::BINDINGS &BODY SI::FORMS) ((SI:LOCATION DEFMACRO HANDLER-BIND) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 11341))
HANDLER-CASE
(((:LAMBDA-LIST) SI::FORM &REST SI::CASES) ((SI:LOCATION DEFMACRO HANDLER-CASE) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 22483))
SI::HARDEN-COMMAND
(((:LAMBDA-LIST) SI::CMD-FORM) ((SI:LOCATION DEFUN SI::HARDEN-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 23975))
CLOS::HAS-FORWARD-REFERENCED-PARENTS
(((:LAMBDA-LIST) CLASS) ((SI:LOCATION DEFUN CLOS::HAS-FORWARD-REFERENCED-PARENTS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 5822))
HASH-TABLE
(((DOCUMENTATION . TYPE) . "
A hash-table is a table used to map from objects to objects efficiently by the
hashing technique.  A hash-table is notated as
	#<hash-table n>
where N is actually a number that identifies the hash-table."))
HASH-TABLE-COUNT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (HASH-TABLE)

Returns the number of entries in HASH-TABLE.
") ((:LAMBDA-LIST) HASH-TABLE))
HASH-TABLE-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a hash-table object; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
SI::HELP
(((DOCUMENTATION . FUNCTION) . "Args: (&optional symbol)
ECL specific.
Prints the documentation associated with SYMBOL.  With no args, prints the
greeting message to ECL beginners.

Welcome to ECL. Here are the few functions you should learn first.

	(HELP symbol) prints the online documentation associated with the
	symbol.  For example, (HELP 'CONS) will print the useful information
	about the CONS function, the CONS data type, and so on.

	(HELP* string) prints the online documentation associated with those
	symbols whose print-names have the string as substring.  For example,
	(HELP* \"PROG\") will print the documentation of the symbols such as
	PROG, PROGN, and MULTIPLE-VALUE-PROG1.

	(QUIT) ends the current ECL session.

For the precise language specification, refer to Guy Steele's \"Common Lisp,
the Language\" and our \"ECL Manual\".  \"ECL Dictionary\", the hard-copied
version of ECL online documentation, will be useful as a handbook.

Good luck!
") ((:LAMBDA-LIST) &OPTIONAL (SYMBOL 'SI::HELP)) ((SI:LOCATION DEFUN SI::HELP) #P"SRC:LSP;AUTOLOAD.LSP.NEWEST" . 4801))
SI::HELP*
(((DOCUMENTATION . FUNCTION) . "Args: (string &optional (package-spec 'lisp))
ECL specific.
Prints the documentation associated with those symbols in the specified
package whose print names contain STRING as substring.  STRING may be a
symbol, in which case the print-name of that symbol is used.  If PACKAGE is
NIL, then all packages are searched.") ((:LAMBDA-LIST) STRING &OPTIONAL (PACKAGE "CL")) ((SI:LOCATION DEFUN SI::HELP*) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 20442))
CLOS::HELP-ENSURE-CLASS
(((:LAMBDA-LIST) &REST CLOS::OPTIONS &KEY (CLOS::METACLASS 'STANDARD-CLASS) CLOS::DIRECT-SUPERCLASSES &ALLOW-OTHER-KEYS) ((SI:LOCATION DEFUN CLOS::HELP-ENSURE-CLASS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 19167))
SI::HIDE-VARIABLE-REFERENCE
(((:LAMBDA-LIST) SI::REALLY-HIDE VARIABLE SI::FORM) ((SI:LOCATION DEFUN SI::HIDE-VARIABLE-REFERENCE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 9395))
SI::HIDE-VARIABLE-REFERENCES
(((:LAMBDA-LIST) SI::VARIABLE-LIST SI::FORM) ((SI:LOCATION DEFUN SI::HIDE-VARIABLE-REFERENCES) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 7781))
HOST-NAMESTRING
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC)

Returns as a string the host part of the pathname specified by FILESPEC.
FILESPEC may be a symbol, a string, a pathname, or a file stream.
") ((:LAMBDA-LIST) SI::FILESPEC))
IDENTITY
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns X.
") ((:LAMBDA-LIST) SI::X))
IF
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (if test form1 [form2])

If TEST evaluates to non-NIL, then evaluates FORM1 and returns all values.
Otherwise, evaluates FORM2 (which defaults to NIL) and returns all values.
") ((:LAMBDA-LIST) . "(if test form1 [form2])"))
IGNORE-ERRORS
(((:LAMBDA-LIST) &REST SI::FORMS) ((SI:LOCATION DEFMACRO IGNORE-ERRORS) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 23934))
SI::IHS-ENVIRONMENT
(((:LAMBDA-LIST) SI::IHS-INDEX) ((SI:LOCATION DEFUN SI::IHS-ENVIRONMENT) #P"SRC:LSP;TOP.LSP.NEWEST" . 32037))
SI::IHS-FNAME
(((:LAMBDA-LIST) SI::I) ((SI:LOCATION DEFUN SI::IHS-FNAME) #P"SRC:LSP;TOP.LSP.NEWEST" . 41687))
SI:IHS-FUN
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (N)

ECL specific.
Returns the function value of the N-th entity in the invocation history stack.
") ((:LAMBDA-LIST) SI::N))
SI::IHS-SEARCH
(((:LAMBDA-LIST) STRING SI::UNRESTRICTED &OPTIONAL (SI::START (SI:IHS-TOP))) ((SI:LOCATION DEFUN SI::IHS-SEARCH) #P"SRC:LSP;TOP.LSP.NEWEST" . 42214))
SI::IHS-VISIBLE
(((:LAMBDA-LIST) SI::I) ((SI:LOCATION DEFUN SI::IHS-VISIBLE) #P"SRC:LSP;TOP.LSP.NEWEST" . 41312))
SI::ILLEGAL-INSIDE-JUSTIFICATION-P
(((:LAMBDA-LIST) SI::DIRECTIVE) ((SI:LOCATION DEFUN SI::ILLEGAL-INSIDE-JUSTIFICATION-P) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 79756))
SI::IMAG-ONE
(((SI:LOCATION DEFCONSTANT SI::IMAG-ONE) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 3754))
IMAGPART
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER)

Returns the imagpart of NUMBER if it is a complex.  Otherwise, returns zero of
the same type as NUMBER.
") ((:LAMBDA-LIST) NUMBER))
IMPORT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL &OPTIONAL (PACKAGE *PACKAGE*))

Registers SYMBOL to PACKAGE as an internal symbol.  Does nothing if SYMBOL is
already registered in PACKAGE.  SYMBOL may be a list of symbols.
") ((:LAMBDA-LIST) SYMBOL &OPTIONAL (PACKAGE *PACKAGE*)))
SI::IN-INTERVAL-P
(((:LAMBDA-LIST) SI::X SI::INTERVAL) ((SI:LOCATION DEFUN SI::IN-INTERVAL-P) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 13868))
IN-PACKAGE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (PACKAGE-NAME &KEY (NICKNAMES NIL) (USE '(LISP)))

Makes the package named PACKAGE-NAME as the current package.  If such a
package does not exist, then creates one by passing all args to MAKE-PACKAGE.
Otherwise, adds the specified nicknames and packages to the nickname list and
use list of the package.  NICKNAMES must be a list consisting of strings and
symbols.  USE must be a list consisting of package objects and package names
(either string or symbol).
") ((:LAMBDA-LIST) PACKAGE-NAME &KEY (SI::NICKNAMES NIL) (SI::USE '(SI::LISP))) ((SI:LOCATION DEFMACRO IN-PACKAGE) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 11162))
INCF
(((DOCUMENTATION . FUNCTION) . "Syntax: (incf place [form])
Increments the value of PLACE by the value of FORM.  FORM defaults to 1.") ((:LAMBDA-LIST) &ENVIRONMENT SI::ENV SI::%REFERENCE &OPTIONAL (SI::DELTA 1)) ((SI:LOCATION DEFMACRO INCF) #P"SRC:LSP;SETF.LSP.NEWEST" . 23519))
SI::INDENTATION
(((SI:LOCATION DEFCLASS SI::INDENTATION) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 12198))
SI::INDEX-COLUMN
(((:LAMBDA-LIST) SI::INDEX STREAM) ((SI:LOCATION DEFUN SI::INDEX-COLUMN) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 14879))
SI::INDEX-POSN
(((:LAMBDA-LIST) SI::INDEX STREAM) ((SI:LOCATION DEFUN SI::INDEX-POSN) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 4754))
C::INFER-ARG-AND-RETURN-TYPES
(((:LAMBDA-LIST) C::FNAME C::FORMS &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::INFER-ARG-AND-RETURN-TYPES) #P"SRC:CMP;CMPTYPE-PROP.LSP.NEWEST" . 584))
C::INFO
(((SI:LOCATION DEFCLASS C::INFO) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 8929))
C::INIT-FUNCTION-NAME
(((:LAMBDA-LIST) C::S &KEY (C::KIND :OBJECT)) ((SI:LOCATION DEFUN C::INIT-FUNCTION-NAME) #P"SRC:CMP;CMPNAME.LSP.NEWEST" . 4405))
C::INIT-NAME-TAG
(((:LAMBDA-LIST) C::INIT-NAME) ((SI:LOCATION DEFUN C::INIT-NAME-TAG) #P"SRC:CMP;CMPNAME.LSP.NEWEST" . 2158))
CLOS::INITARGS-UPDATER
(((SI:LOCATION DEFCLASS CLOS::INITARGS-UPDATER) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 10426))
SI::INITIAL-BUFFER-SIZE
(((SI:LOCATION DEFCONSTANT SI::INITIAL-BUFFER-SIZE) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 950))
INITIALIZE-INSTANCE
(((SI:LOCATION DEFMETHOD INITIALIZE-INSTANCE (CLASS CLASS) &REST CLOS::INITARGS &KEY CLOS::SEALEDP CLOS::DIRECT-SUPERCLASSES CLOS::DIRECT-SLOTS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 6220) ((SI:LOCATION DEFMETHOD INITIALIZE-INSTANCE (CLOS::INSTANCE T) &REST CLOS::INITARGS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 601))
C::INLINE-ARGS
(((:LAMBDA-LIST) C::FORMS) ((SI:LOCATION DEFUN C::INLINE-ARGS) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 6084))
C::INLINE-ARITH-UNOP
(((:LAMBDA-LIST) C::EXPECTED-TYPE C::ARG1 C::CONSING C::NON-CONSING) ((SI:LOCATION DEFUN C::INLINE-ARITH-UNOP) #P"SRC:CMP;CMPNUM.LSP.NEWEST" . 5505))
C::INLINE-BINOP
(((:LAMBDA-LIST) C::EXPECTED-TYPE C::ARG1 C::ARG2 C::INTEGER-RESULT-TYPE C::CONSING C::NON-CONSING) ((SI:LOCATION DEFUN C::INLINE-BINOP) #P"SRC:CMP;CMPNUM.LSP.NEWEST" . 4793))
C::INLINE-FUNCTION
(((:LAMBDA-LIST) C::FNAME C::ARG-TYPES C::RETURN-TYPE &OPTIONAL (C::RETURN-REP-TYPE 'C::ANY)) ((SI:LOCATION DEFUN C::INLINE-FUNCTION) #P"SRC:CMP;CMPC-INLINER.LSP.NEWEST" . 1516))
C::INLINE-INFO
(((SI:LOCATION DEFCLASS C::INLINE-INFO) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 9252))
C::INLINE-POSSIBLE
(((:LAMBDA-LIST) C::FNAME &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::INLINE-POSSIBLE) #P"SRC:CMP;CMPENV-FUN.LSP.NEWEST" . 5313))
C::INLINE-TYPE-MATCHES
(((:LAMBDA-LIST) C::INLINE-INFO C::ARG-TYPES C::RETURN-TYPE) ((SI:LOCATION DEFUN C::INLINE-TYPE-MATCHES) #P"SRC:CMP;CMPC-INLINER.LSP.NEWEST" . 4941))
C::INLINED-ARG-LOC
(((:LAMBDA-LIST) C::ARG) ((SI:LOCATION DEFUN C::INLINED-ARG-LOC) #P"SRC:CMP;CMPC-INLINER.LSP.NEWEST" . 600))
C::INLINED-ARG-REP-TYPE
(((:LAMBDA-LIST) C::ARG) ((SI:LOCATION DEFUN C::INLINED-ARG-REP-TYPE) #P"SRC:CMP;CMPC-INLINER.LSP.NEWEST" . 692))
C::INLINED-ARG-TYPE
(((:LAMBDA-LIST) C::ARG) ((SI:LOCATION DEFUN C::INLINED-ARG-TYPE) #P"SRC:CMP;CMPC-INLINER.LSP.NEWEST" . 646))
C::INNERMOST-NON-EXPANDED-FORM
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::INNERMOST-NON-EXPANDED-FORM) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 1573))
INPUT-STREAM-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STREAM)

Returns T if STREAM can handle input operations; NIL otherwise.
") ((:LAMBDA-LIST) STREAM))
GRAY:INPUT-STREAM-P
(((SI:LOCATION DEFMETHOD GRAY:INPUT-STREAM-P (STREAM T)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 13232) ((SI:LOCATION DEFMETHOD GRAY:INPUT-STREAM-P (STREAM SI:ANSI-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 13152) ((SI:LOCATION DEFMETHOD GRAY:INPUT-STREAM-P (STREAM GRAY:FUNDAMENTAL-INPUT-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 13084) ((SI:LOCATION DEFMETHOD GRAY:INPUT-STREAM-P (STREAM GRAY:FUNDAMENTAL-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 13021) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:INPUT-STREAM-P) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 2984))
INSPECT
(((DOCUMENTATION . FUNCTION) . "Args: (object)
Shows the information about OBJECT interactively.  See the ECL Report for the
inspect commands, or type '?' to the inspector.") ((:LAMBDA-LIST) SI::OBJECT &AUX (SI::*INSPECT-MODE* T) (SI::*INSPECT-LEVEL* 0) (SI::*INSPECT-HISTORY* NIL) (SI::*OLD-PRINT-LEVEL* *PRINT-LEVEL*) (SI::*OLD-PRINT-LENGTH* *PRINT-LENGTH*) (*PRINT-LEVEL* 3) (*PRINT-LENGTH* 3)) ((SI:LOCATION DEFUN INSPECT) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 15371))
SI::INSPECT-ARRAY
(((:LAMBDA-LIST) ARRAY) ((SI:LOCATION DEFUN SI::INSPECT-ARRAY) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 10779))
SI::INSPECT-CHARACTER
(((:LAMBDA-LIST) CHARACTER) ((SI:LOCATION DEFUN SI::INSPECT-CHARACTER) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 7899))
SI::INSPECT-CONS
(((:LAMBDA-LIST) CONS) ((SI:LOCATION DEFUN SI::INSPECT-CONS) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 8958))
SI::INSPECT-HASHTABLE
(((:LAMBDA-LIST) SI::HASHTABLE) ((SI:LOCATION DEFUN SI::INSPECT-HASHTABLE) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 12860))
SI::INSPECT-INDENT
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::INSPECT-INDENT) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 5197))
SI::INSPECT-INDENT-1
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::INSPECT-INDENT-1) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 5320))
SI::INSPECT-INSTANCE
(((:LAMBDA-LIST) SI:INSTANCE) ((SI:LOCATION DEFUN SI::INSPECT-INSTANCE) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 14172))
SI::INSPECT-NUMBER
(((:LAMBDA-LIST) NUMBER) ((SI:LOCATION DEFUN SI::INSPECT-NUMBER) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 8161))
CLOS::INSPECT-OBJ
(((SI:LOCATION DEFMETHOD CLOS::INSPECT-OBJ (CLOS::INSTANCE T)) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 11375) ((SI:LOCATION DEFMETHOD CLOS::INSPECT-OBJ (CLOS::INSTANCE CLOS::STD-CLASS)) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 11290) ((SI:LOCATION DEFMETHOD CLOS::INSPECT-OBJ (CLOS::INSTANCE STANDARD-OBJECT)) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 7812))
CLOS::INSPECT-OBJ-INNER-CLASS
(((:LAMBDA-LIST) CLOS::INSTANCE) ((SI:LOCATION DEFUN CLOS::INSPECT-OBJ-INNER-CLASS) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 9810))
SI::INSPECT-OBJECT
(((:LAMBDA-LIST) SI::OBJECT &AUX (SI::*INSPECT-LEVEL* SI::*INSPECT-LEVEL*)) ((SI:LOCATION DEFUN SI::INSPECT-OBJECT) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 14330))
SI::INSPECT-PACKAGE
(((:LAMBDA-LIST) PACKAGE) ((SI:LOCATION DEFUN SI::INSPECT-PACKAGE) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 7323))
SI::INSPECT-PRINT
(((:LAMBDA-LIST) SI::LABEL SI::OBJECT &OPTIONAL SI::PLACE) ((SI:LOCATION DEFMACRO SI::INSPECT-PRINT) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 4845))
SI::INSPECT-READ-LINE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::INSPECT-READ-LINE) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 953))
SI::INSPECT-RECURSIVELY
(((:LAMBDA-LIST) SI::LABEL SI::OBJECT &OPTIONAL SI::PLACE) ((SI:LOCATION DEFMACRO SI::INSPECT-RECURSIVELY) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 4490))
SI::INSPECT-STRING
(((:LAMBDA-LIST) STRING) ((SI:LOCATION DEFUN SI::INSPECT-STRING) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 9500))
SI::INSPECT-SYMBOL
(((:LAMBDA-LIST) SYMBOL) ((SI:LOCATION DEFUN SI::INSPECT-SYMBOL) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 5451))
SI::INSPECT-VECTOR
(((:LAMBDA-LIST) VECTOR) ((SI:LOCATION DEFUN SI::INSPECT-VECTOR) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 10139))
CLOS::INSTALL-METHOD
(((:LAMBDA-LIST) CLOS::NAME CLOS::QUALIFIERS CLOS::SPECIALIZERS CLOS::LAMBDA-LIST CLOS::DOC CLOS::PLIST CLOS::FUN &OPTIONAL CLOS::METHOD-CLASS &REST CLOS::OPTIONS) ((SI:LOCATION DEFUN CLOS::INSTALL-METHOD) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 7126))
CLOS::INSTALL-METHOD-COMBINATION
(((:LAMBDA-LIST) CLOS::NAME FUNCTION) ((SI:LOCATION DEFUN CLOS::INSTALL-METHOD-COMBINATION) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 7778))
SI:INSTANCE-CLASS
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (INSTANCE)

ECL/CLOS specific.
Returns the class of which the given INSTANCE is an instance.
") ((:LAMBDA-LIST) SI:INSTANCE))
SI:INSTANCE-CLASS-SET
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (INSTANCE CLASS)

ECL/CLOS specific.
Makes INSTANCE an instance of CLASS class.
") ((:LAMBDA-LIST) SI:INSTANCE CLASS))
SI:INSTANCE-REF
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (INSTANCE INDEX)

ECL/CLOS specific.
Returns the value of the INDEX-th slot of INSTANCE. The first slot has
INDEX equal to zero.
") ((:LAMBDA-LIST) SI:INSTANCE SI::INDEX))
SI:INSTANCE-SET
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (INSTANCE INDEX VALUE)

ECL/CLOS specific.
Sets to VALUE the value of INDEX-th slot of INSTANCE. The first slot has
INDEX equal to zero.
") ((:LAMBDA-LIST) SI:INSTANCE SI::INDEX SI::VALUE))
SI:INSTANCEP
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (OBJECT)

ECL/CLOS specific.
Returns T if OBJECT is of instance type.
") ((:LAMBDA-LIST) SI::OBJECT))
SI::INT-CHAR
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (INTEGER)

Equivalent to CODE-CHAR.
") ((:LAMBDA-LIST) INTEGER))
INTEGER
(((DOCUMENTATION . TYPE) . "
An integer object represents an integer in mathematical sense.  An integer may
be a fixnum, or else it is a bignum.  Normally, an integer is notated in radix
10 (see *PRINT-BASE* and *READ-BASE*) as
	[sign] {digit}+
where DIGIT is a decimal digit ('0', ..., '9') and SIGN is either '+' or '-'.
Also, the following syntax is used to notate the radix explicitly.
	# radix {r | R} [sign] {digit}+
where RADIX is one of '2', '3', ..., '36' and DIGIT is a digit in radix RADIX:
	Digits in radix 2 are '0' and '1'
	Digits in radix 8 are '0', ..., '7'
	Digits in radix 16 are '0', ..., '9', 'a', ..., 'f', and 'A', ..., 'F'
The following syntax is also available for radix 2, 8, 10, and 16.
	# {b | B} [sign] {digit}+
	# {o | O} [sign] {digit}+
		  [sign] {digit}+ .
	# {x | X} [sign] {digit}+"))
INTEGER-DECODE-FLOAT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FLOAT)

Returns, as three values, the integer interpretation of significand F, the
exponent E, and the sign S of FLOAT, such that
	FLOAT = S * F * B^E
where B = (float-radix FLOAT).  F is a non-negative integer, E is an integer,
and S is either 1 or -1.
") ((:LAMBDA-LIST) FLOAT))
INTEGER-LENGTH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (INTEGER)

Returns the number of \"significant bits\" in the representation of INTEGER.
With positive arg, returns one plus the position of the most significant bit
that is 'on'.  With negative arg other than -1, returns one plus the position
of the most significant bit that is 'off'.  For 0 and -1, returns 0.
") ((:LAMBDA-LIST) INTEGER))
INTEGERP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is an integer; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
SI:INTERACTIVE-INTERRUPT
(((SI:LOCATION DEFCLASS SI:INTERACTIVE-INTERRUPT) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
INTERN
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING &OPTIONAL (PACKAGE *PACKAGE*))

Searches PACKAGE for a symbol whose print name is STRING.  If such a symbol is
found, returns the symbol and, as the second value, one of the keywords
:INTERNAL, :EXTERNAL, and :INHERITED.  Otherwise, creates and returns a new
symbol and, as the second value, returns NIL.
") ((:LAMBDA-LIST) STRING &OPTIONAL (PACKAGE *PACKAGE*)))
INTERNAL-TIME-UNITS-PER-SECOND
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Gives the time unit used by GET-INTERNAL-REAL-TIME and GET-INTERNAL-RUN-TIME.
1000 in ECL.
"))
SI::INTERPRET-BIND-DEFAULTS
(((:LAMBDA-LIST) SI::SPECS SI::PARAMS &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::INTERPRET-BIND-DEFAULTS) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 21402))
SI::INTERPRET-DIRECTIVE-LIST
(((:LAMBDA-LIST) STREAM SI::DIRECTIVES SI::ORIG-ARGS SI::ARGS) ((SI:LOCATION DEFUN SI::INTERPRET-DIRECTIVE-LIST) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 17263))
SI::INTERPRET-FORMAT-INTEGER
(((:LAMBDA-LIST) SI::BASE) ((SI:LOCATION DEFMACRO SI::INTERPRET-FORMAT-INTEGER) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 32966))
SI::INTERPRET-FORMAT-JUSTIFICATION
(((:LAMBDA-LIST) STREAM SI::ORIG-ARGS SI::ARGS SI::SEGMENTS SI::COLONP SI::ATSIGNP SI::FIRST-SEMI SI::PARAMS) ((SI:LOCATION DEFUN SI::INTERPRET-FORMAT-JUSTIFICATION) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 84163))
SI::INTERPRET-FORMAT-LOGICAL-BLOCK
(((:LAMBDA-LIST) STREAM SI::ORIG-ARGS SI::ARGS SI::PREFIX SI::PER-LINE-P SI::INSIDES SI::SUFFIX SI::ATSIGNP) ((SI:LOCATION DEFUN SI::INTERPRET-FORMAT-LOGICAL-BLOCK) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 90136))
INTERSECTION
(((DOCUMENTATION . FUNCTION) . "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns a list consisting of those objects that are elements of both LIST1 and
LIST2.") ((:LAMBDA-LIST) SI::LIST1 SI::LIST2 &KEY SI::TEST SI::TEST-NOT SI::KEY) ((SI:LOCATION DEFUN INTERSECTION) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 1485))
C::INVALID-LET-BINDINGS
(((:LAMBDA-LIST) C::LET/LET* C::BINDINGS) ((SI:LOCATION DEFUN C::INVALID-LET-BINDINGS) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 2441))
INVALID-METHOD-ERROR
(((:LAMBDA-LIST) METHOD CLOS::FORMAT-CONTROL &REST CLOS::ARGS) ((SI:LOCATION DEFUN INVALID-METHOD-ERROR) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 11436))
INVOKE-DEBUGGER
(((:LAMBDA-LIST) CONDITION) ((SI:LOCATION DEFUN INVOKE-DEBUGGER) #P"SRC:LSP;TOP.LSP.NEWEST" . 49860))
INVOKE-RESTART
(((:LAMBDA-LIST) RESTART &REST VALUES) ((SI:LOCATION DEFUN INVOKE-RESTART) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 3179))
INVOKE-RESTART-INTERACTIVELY
(((:LAMBDA-LIST) RESTART) ((SI:LOCATION DEFUN INVOKE-RESTART-INTERACTIVELY) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 3336))
ISQRT
(((DOCUMENTATION . FUNCTION) . "Args: (integer)
Returns the integer square root of INTEGER.") ((:LAMBDA-LIST) SI::I) ((SI:LOCATION DEFUN ISQRT) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 3790))
C::JUMP-FALSE-DESTINATION?
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::JUMP-FALSE-DESTINATION?) #P"SRC:CMP;CMPIF.LSP.NEWEST" . 4552))
C::JUMP-TRUE-DESTINATION?
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::JUMP-TRUE-DESTINATION?) #P"SRC:CMP;CMPIF.LSP.NEWEST" . 4436))
KEYWORD
(((DOCUMENTATION . TYPE) . "
A keyword is a symbol in the keyword package."))
KEYWORDP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a symbol that belongs to the KEYWORD package; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
C::KNOWN-TYPE-P
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN C::KNOWN-TYPE-P) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 2269))
LABELS
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (labels ({(name lambda-list {decl | doc}* {form}*)}*) . body)

Introduces local functions and evaluates BODY as a PROGN.  The scope of each
local function include the local function definitions.  Thus self- and mutual-
recursive local functions can be defined.  Doc-strings for local functions are
simply ignored.
") ((:LAMBDA-LIST) . "(labels ({(name lambda-list {decl | doc}* {form}*)}*) . body)"))
LAMBDA
(((:LAMBDA-LIST) &REST SI::BODY) ((SI:LOCATION DEFMACRO LAMBDA) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 5444))
SI:LAMBDA-BLOCK
(((:LAMBDA-LIST) SI::NAME SI::LAMBDA-LIST &REST SI::LAMBDA-BODY) ((SI:LOCATION DEFMACRO SI:LAMBDA-BLOCK) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 5506))
C::LAMBDA-FORM-ALLOWED-NARGS
(((:LAMBDA-LIST) LAMBDA) ((SI:LOCATION DEFUN C::LAMBDA-FORM-ALLOWED-NARGS) #P"SRC:CMP;CMPLAM.LSP.NEWEST" . 9991))
LAMBDA-LIST-KEYWORDS
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
List of all lambda-list keywords, including
	&optional	&rest		&key
	&allow-other-keys		&aux
	&whole		&environment	&body
"))
CLOS::LAMBDA-LIST-REQUIRED-ARGUMENTS
(((:LAMBDA-LIST) CLOS::LAMBDA-LIST) ((SI:LOCATION DEFUN CLOS::LAMBDA-LIST-REQUIRED-ARGUMENTS) #P"SRC:CLOS;GENERIC.LSP.NEWEST" . 4286))
LAMBDA-PARAMETERS-LIMIT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The upper bound of the number of parameters specified by a lambda list.
Ignore this number; there is no such upper bound in ECL.
"))
C::LAMBDA-TYPE-CHECK-ASSOCIATE
(((:LAMBDA-LIST) C::FNAME C::REQUIREDS C::OPTIONALS C::KEYWORDS C::GLOBAL-FUN-P) ((SI:LOCATION DEFUN C::LAMBDA-TYPE-CHECK-ASSOCIATE) #P"SRC:CMP;CMPTYPE.LSP.NEWEST" . 1899))
C::LAMBDA-TYPE-CHECK-PRECISE
(((:LAMBDA-LIST) C::ASSOC-LIST C::TS) ((SI:LOCATION DEFUN C::LAMBDA-TYPE-CHECK-PRECISE) #P"SRC:CMP;CMPTYPE.LSP.NEWEST" . 3314))
LAST
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (LIST)

Returns the last cons that constitute LIST.  Returns NIL if LIST is NIL.
") ((:LAMBDA-LIST) LIST))
C::LAST-CALL-P
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::LAST-CALL-P) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 4388))
C::LCL-NAME
(((:LAMBDA-LIST) C::LCL) ((SI:LOCATION DEFUN C::LCL-NAME) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 4693))
LCM
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (INTEGER &REST MORE-INTEGERS)

Returns the least common multiple of the args.  Returns 0 if at least one of
the args is 0.
") ((:LAMBDA-LIST) INTEGER &REST SI::MORE-INTEGERS))
LDB
(((SI:LOCATION DEFINE-COMPILER-MACRO LDB) #P"SRC:CMP;CMPOPT-BITS.LSP.NEWEST" . 614) ((DOCUMENTATION . FUNCTION) . "Args: (bytespec integer)
Extracts a byte from INTEGER at the specified byte position, right-justifies
the byte, and returns the result as an integer.") ((:LAMBDA-LIST) SI::BYTESPEC INTEGER) ((SI:LOCATION DEFUN LDB) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 10333))
LDB-TEST
(((DOCUMENTATION . FUNCTION) . "Args: (bytespec integer)
Returns T if at least one bit of the specified byte is 1; NIL otherwise.") ((:LAMBDA-LIST) SI::BYTESPEC INTEGER) ((SI:LOCATION DEFUN LDB-TEST) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 10620))
LDIFF
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (LIST X)

If X is a cons that constitutes LIST, then returns a new list consisting of
those elements of LIST that appear before X.  Otherwise, returns a copy of
LIST.
") ((:LAMBDA-LIST) LIST SI::X))
SI::LEAP-YEAR-P
(((:LAMBDA-LIST) SI::Y) ((SI:LOCATION DEFUN SI::LEAP-YEAR-P) #P"SRC:LSP;MISLIB.LSP.NEWEST" . 3697))
LEAST-NEGATIVE-DOUBLE-FLOAT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Same as LEAST-NEGATIVE-LONG-FLOAT.
"))
LEAST-NEGATIVE-LONG-FLOAT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The negative long-float with the smallest absolute value.
"))
LEAST-NEGATIVE-SHORT-FLOAT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The negative short-float with the smallest absolute value.
"))
LEAST-NEGATIVE-SINGLE-FLOAT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Same as LEAST-NEGATIVE-LONG-FLOAT.
"))
LEAST-POSITIVE-DOUBLE-FLOAT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Same as LEAST-POSITIVE-LONG-FLOAT.
"))
LEAST-POSITIVE-LONG-FLOAT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The smallest positive long-float.
"))
LEAST-POSITIVE-SHORT-FLOAT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The smallest positive short-float.
"))
LEAST-POSITIVE-SINGLE-FLOAT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Same as LEAST-POSITIVE-LONG-FLOAT.
"))
CLOS::LEGAL-GENERIC-FUNCTION-NAME-P
(((:LAMBDA-LIST) CLOS::NAME) ((SI:LOCATION DEFUN CLOS::LEGAL-GENERIC-FUNCTION-NAME-P) #P"SRC:CLOS;METHOD.LSP.NEWEST" . 6633))
LENGTH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SEQUENCE)

Returns the length of SEQUENCE.
") ((:LAMBDA-LIST) SEQUENCE))
LET
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (let ({var | (var [init])}*) {decl}* {form}*)

Evaluates all INITs (which defaults to NIL), binds the value of each INIT to
the corresponding VAR, evaluates FORMs, and returns all values of the last
FORM.  Returns NIL if no FORM is given.
") ((:LAMBDA-LIST) . "(let ({var | (var [init])}*) {decl}* {form}*)"))
LET*
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (let* ({var | (var [init])}*) {decl}* {form}*)

Evaluates INIT (which defaults to NIL) and binds the value to the
corresponding VAR, one by one for each pair of VAR and INIT.  Then evaluates
FORMs and returns all values of the last FORM.  Returns NIL if no FORM is
given.
") ((:LAMBDA-LIST) . "(let* ({var | (var [init])}*) {decl}* {form}*)"))
C::LEX-ENV-VAR-NAME
(((:LAMBDA-LIST) C::N) ((SI:LOCATION DEFUN C::LEX-ENV-VAR-NAME) #P"SRC:CMP;CMPMAC.LSP.NEWEST" . 2120))
C::LEX-ENV-VAR-NAME-EMPTY-CACHE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::LEX-ENV-VAR-NAME-EMPTY-CACHE) #P"SRC:CMP;CMPMAC.LSP.NEWEST" . 2120))
C::LINKER-CC
(((:LAMBDA-LIST) C::O-PATHNAME C::OBJECT-FILES &KEY (TYPE :PROGRAM) (C::LD-FLAGS (C::SPLIT-PROGRAM-OPTIONS C::*LD-FLAGS*))) ((SI:LOCATION DEFUN C::LINKER-CC) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 4922))
LISP-IMPLEMENTATION-TYPE
(((DOCUMENTATION . FUNCTION) . "Args: ()
Returns the string \"ECL\".") ((:LAMBDA-LIST)) ((SI:LOCATION DEFUN LISP-IMPLEMENTATION-TYPE) #P"SRC:LSP;AUTOLOAD.LSP.NEWEST" . 572))
SI:LISP-IMPLEMENTATION-VCS-ID
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI:LISP-IMPLEMENTATION-VCS-ID) #P"BUILD:LSP;CONFIG.LSP.NEWEST" . 1109))
LISP-IMPLEMENTATION-VERSION
(((DOCUMENTATION . FUNCTION) . "Args:()
Returns the version of your ECL as a string.") ((:LAMBDA-LIST)) ((SI:LOCATION DEFUN LISP-IMPLEMENTATION-VERSION) #P"BUILD:LSP;CONFIG.LSP.NEWEST" . 1003))
FFI::LISP-TO-C-NAME
(((:LAMBDA-LIST) FFI::NAME) ((SI:LOCATION DEFUN FFI::LISP-TO-C-NAME) #P"SRC:LSP;FFI.LSP.NEWEST" . 16773))
C::LISP-TO-C-NAME
(((:LAMBDA-LIST) C::OBJ) ((SI:LOCATION DEFUN C::LISP-TO-C-NAME) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 12639))
C::LISP-TYPE->REP-TYPE
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN C::LISP-TYPE->REP-TYPE) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 6137))
C::LISP-TYPE-P
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN C::LISP-TYPE-P) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 6623))
LIST
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&REST ARGS)

Returns a list of the args.
") ((:LAMBDA-LIST) &REST SI::ARGS) ((DOCUMENTATION . TYPE) . "As a type specifier, LIST is used to specify the type consisting of NIL and
cons objects.  In our ordinary life with Lisp, however, a list is either NIL
or a cons whose cdr is a list, and is notated by its elements surrounded with
parentheses.
The backquote macro is sometimes useful to construct a complicated list
structure.  When evaluating `(...)
	,form embeds the value of FORM,
	,@form and ,.form embed all elements of the list value of FORM,
	and other things embed itself
into the structure at their position.  For example,
	`(a b ,c d e) expands to (list* 'a 'b c '(d e))
	`(a b ,@c d e) expands to (list* 'a 'b (append c '(d e)))
	`(a b ,.c d e) expands to (list* 'a 'b (nconc c '(d e)))"))
LIST*
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ARG &REST MORE-ARGS)

With one arg, simply returns it.  With n args (n > 1), conses the first arg to
the LIST* of the rest of args.
") ((:LAMBDA-LIST) SI::ARG &REST SI::MORE-ARGS))
LIST-ALL-PACKAGES
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: NIL

Returns a list of all packages.
") ((:LAMBDA-LIST)))
LIST-LENGTH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (LIST)

Returns the length of LIST.  Returns NIL if LIST is circular.
") ((:LAMBDA-LIST) LIST))
SI::LIST-MERGE-SORT
(((:LAMBDA-LIST) SI::L SI::PREDICATE SI::KEY) ((SI:LOCATION DEFUN SI::LIST-MERGE-SORT) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 33165))
LISTEN
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&OPTIONAL (STREAM *STANDARD-INPUT*))

Returns T if STREAM is ready to input a character from; NIL otherwise.  In
some versions of ECL, this function does not work correctly because the
underlying OS does not support such a mechanism.
") ((:LAMBDA-LIST) &OPTIONAL (STREAM *STANDARD-INPUT*)))
LISTP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is either a cons or NIL.  Otherwise, returns NIL.
") ((:LAMBDA-LIST) SI::X))
LOAD
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC &KEY (VERBOSE *LOAD-VERBOSE*) (PRINT NIL) (IF-DOES-NOT-EXIST ERROR))

Loads the contents of the specified file into ECL.
If the filetype is not specified, ECL first tries to load the fasl file with
filetype \".fasl\", then tries to load the source file with filetype \".lsp\",
and then tries to load the source file with no filetype.
FILESPEC may be a symbol, a string, a pathname, or a file stream.  VERBOSE
specifies whether or not the loader prints a loading message.  PRINT specifies
whether or not the loader prints the values of the top-level forms.
IF-DOES-NOT-EXIST specifies the behavior of the loader when the specified file
is not found.  It may be :ERROR or NIL.
If the file was loaded successfully, returns the pathname of the file actually
loaded
") ((:LAMBDA-LIST) SI::FILESPEC &KEY (SI::VERBOSE *LOAD-VERBOSE*) (PRINT NIL) (SI::IF-DOES-NOT-EXIST :ERROR)))
SI:LOAD-ENCODING
(((:LAMBDA-LIST) SI::NAME) ((SI:LOCATION DEFUN SI:LOAD-ENCODING) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 12004))
FFI:LOAD-FOREIGN-LIBRARY
(((:LAMBDA-LIST) FFI::FILENAME &KEY FFI::MODULE FFI::SUPPORTING-LIBRARIES FFI::FORCE-LOAD FFI::SYSTEM-LIBRARY) ((SI:LOCATION DEFMACRO FFI:LOAD-FOREIGN-LIBRARY) #P"SRC:LSP;FFI.LSP.NEWEST" . 22685))
LOAD-LOGICAL-PATHNAME-TRANSLATIONS
(((DOCUMENTATION . FUNCTION) . "Search for a logical pathname named host, if not already defined. If already
defined no attempt to find or load a definition is attempted and NIL is
returned. If host is not already defined, but definition is found and loaded
successfully, T is returned, else error.") ((:LAMBDA-LIST) SI::HOST) ((SI:LOCATION DEFUN LOAD-LOGICAL-PATHNAME-TRANSLATIONS) #P"SRC:LSP;MISLIB.LSP.NEWEST" . 672))
C::LOC-IMMEDIATE-VALUE-P
(((:LAMBDA-LIST) C::LOC &AUX C::HEAD) ((SI:LOCATION DEFUN C::LOC-IMMEDIATE-VALUE-P) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 3064))
C::LOC-IN-C1FORM-MOVABLE-P
(((:LAMBDA-LIST) C::LOC) ((SI:LOCATION DEFUN C::LOC-IN-C1FORM-MOVABLE-P) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 2214))
C::LOC-MOVABLE-P
(((:LAMBDA-LIST) C::LOC) ((SI:LOCATION DEFUN C::LOC-MOVABLE-P) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 7832))
C::LOC-REFERS-TO-SPECIAL
(((:LAMBDA-LIST) C::LOC) ((SI:LOCATION DEFUN C::LOC-REFERS-TO-SPECIAL) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 5136))
C::LOC-REPRESENTATION-TYPE
(((:LAMBDA-LIST) C::LOC) ((SI:LOCATION DEFUN C::LOC-REPRESENTATION-TYPE) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 8714))
C::LOC-TYPE
(((:LAMBDA-LIST) C::LOC) ((SI:LOCATION DEFUN C::LOC-TYPE) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 7999))
C::LOCAL
(((:LAMBDA-LIST) C::VAR) ((SI:LOCATION DEFUN C::LOCAL) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 8210))
C::LOCAL-FUNCTION-REF
(((:LAMBDA-LIST) C::FNAME &OPTIONAL C::BUILD-OBJECT) ((SI:LOCATION DEFUN C::LOCAL-FUNCTION-REF) #P"SRC:CMP;CMPFLET.LSP.NEWEST" . 8313))
LOCALLY
(((DOCUMENTATION . FUNCTION) . "Macro in COMMON-LISP package:
Syntax: (locally {decl}* {form}*)

Gives DECLs locally while evaluating FORMs, and returns all values of the last
FORM.  Returns NIL if no FORM is given.
") ((:LAMBDA-LIST) . "(locally {decl}* {form}*)"))
C::LOCATION-PRIMARY-TYPE
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::LOCATION-PRIMARY-TYPE) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 6973))
C::LOCATIVE-TYPE-FROM-VAR-KIND
(((:LAMBDA-LIST) C::KIND) ((SI:LOCATION DEFUN C::LOCATIVE-TYPE-FROM-VAR-KIND) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 21115))
LOG
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER1 &OPTIONAL NUMBER2)

With two args, returns the logarithm of NUMBER1 in base NUMBER2.  With one
arg, returns the natural logarithm of the arg.
") ((:LAMBDA-LIST) SI::NUMBER1 &OPTIONAL SI::NUMBER2))
LOGAND
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&REST INTEGERS)

Returns the bit-wise AND of the args.
") ((:LAMBDA-LIST) &REST SI::INTEGERS))
LOGANDC1
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (INTEGER1 INTEGER2)

Equivalent to (LOGAND (LOGNOT INTEGER1) INTEGER2).
") ((:LAMBDA-LIST) SI::INTEGER1 SI::INTEGER2))
LOGANDC2
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (INTEGER1 INTEGER2)

Equivalent to (LOGAND INTEGER1 (LOGNOT INTEGER2)).
") ((:LAMBDA-LIST) SI::INTEGER1 SI::INTEGER2))
LOGBITP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (BIT-POSITION INTEGER)

Returns T if the specified bit of INTEGER is 1; NIL otherwise.  BIT-POSITION
must be a non-negative integer, with 0 representing the least significant bit.
") ((:LAMBDA-LIST) SI::BIT-POSITION INTEGER))
LOGCOUNT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (INTEGER)

If INTEGER is negative, returns the number of 0 bits.  Otherwise, returns the
number of 1 bits.
") ((:LAMBDA-LIST) INTEGER))
LOGEQV
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&REST INTEGERS)

Returns the bit-wise EQUIVALENCE of the args.
") ((:LAMBDA-LIST) &REST SI::INTEGERS))
SI::LOGICAL-BLOCK
(((SI:LOCATION DEFCLASS SI::LOGICAL-BLOCK) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 7068))
LOGICAL-PATHNAME-TRANSLATIONS
(((:LAMBDA-LIST) SI::P) ((SI:LOCATION DEFUN LOGICAL-PATHNAME-TRANSLATIONS) #P"SRC:LSP;MISLIB.LSP.NEWEST" . 533))
LOGIOR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&REST INTEGERS)

Returns the bit-wise INCLUSIVE OR of the args.
") ((:LAMBDA-LIST) &REST SI::INTEGERS))
LOGNAND
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (INTEGER1 INTEGER2)

Equivalent to (LOGNOT (LOGAND INTEGER1 INTEGER2)).
") ((:LAMBDA-LIST) SI::INTEGER1 SI::INTEGER2))
LOGNOR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (INTEGER1 INTEGER2)

Equivalent to (LOGNOT (LOGIOR INTEGER1 INTEGER2)).
") ((:LAMBDA-LIST) SI::INTEGER1 SI::INTEGER2))
LOGNOT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (INTEGER)

Returns the bit-wise logical NOT of the arg.
") ((:LAMBDA-LIST) INTEGER))
LOGORC1
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (INTEGER1 INTEGER2)

Equivalent to (LOGIOR (LOGNOT INTEGER1) INTEGER2).
") ((:LAMBDA-LIST) SI::INTEGER1 SI::INTEGER2))
LOGORC2
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (INTEGER1 INTEGER2)

Equivalent to (LOGIOR INTEGER1 (LOGNOT INTEGER2)).
") ((:LAMBDA-LIST) SI::INTEGER1 SI::INTEGER2))
LOGTEST
(((DOCUMENTATION . FUNCTION) . "Args: (integer1 integer2)
Equivalent to (NOT (ZEROP (LOGAND INTEGER1 INTEGER2))).") ((:LAMBDA-LIST) SI::X SI::Y) ((SI:LOCATION DEFUN LOGTEST) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 9612))
LOGXOR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&REST INTEGERS)

Returns the bit-wise EXCLUSIVE OR of the args.
") ((:LAMBDA-LIST) &REST SI::INTEGERS))
LONG-FLOAT
(((DOCUMENTATION . TYPE) . "
A long-float is a long-precision floating point number."))
LONG-FLOAT-EPSILON
(((SI:LOCATION DEFCONSTANT LONG-FLOAT-EPSILON) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 625) ((DOCUMENTATION . VARIABLE) . "The smallest postive long-float E that satisfies
	(not (= (float 1 E) (+ (float 1 E) E)))"))
LONG-FLOAT-NEGATIVE-EPSILON
(((SI:LOCATION DEFCONSTANT LONG-FLOAT-NEGATIVE-EPSILON) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 625) ((DOCUMENTATION . VARIABLE) . "The smallest positive long-float E that satisfies
	(not (= (float 1 E) (- (float 1 E) E)))"))
SI:LONG-FLOAT-NEGATIVE-INFINITY
(((SI:LOCATION DEFCONSTANT SI:LONG-FLOAT-NEGATIVE-INFINITY) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 2925))
SI:LONG-FLOAT-POSITIVE-INFINITY
(((SI:LOCATION DEFCONSTANT SI:LONG-FLOAT-POSITIVE-INFINITY) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 2925))
LONG-SITE-NAME
(((DOCUMENTATION . FUNCTION) . "Args: ()
Returns, as a string, the location of the machine on which ECL runs.") ((:LAMBDA-LIST)) ((SI:LOCATION DEFUN LONG-SITE-NAME) #P"BUILD:LSP;CONFIG.LSP.NEWEST" . 843))
LOOP
(((DOCUMENTATION . FUNCTION) . "Syntax: (loop {form}*)
Establishes a NIL block and executes FORMs repeatedly.  The loop is normally
terminated by a non-local exit.") ((:LAMBDA-LIST) &ENVIRONMENT SI::ENV &REST SI::KEYWORDS-AND-FORMS) ((SI:LOCATION DEFMACRO LOOP) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 88537))
SI::LOOP-ACCUMULATE-MINIMAX-VALUE
(((:LAMBDA-LIST) SI::LM SI::OPERATION SI::FORM) ((SI:LOCATION DEFMACRO SI::LOOP-ACCUMULATE-MINIMAX-VALUE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 17025))
SI::LOOP-ANSI-FOR-EQUALS
(((:LAMBDA-LIST) SI::VAR SI::VAL SI::DATA-TYPE) ((SI:LOCATION DEFUN SI::LOOP-ANSI-FOR-EQUALS) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 63098))
SI::LOOP-BIND-BLOCK
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::LOOP-BIND-BLOCK) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 46656))
SI::LOOP-BODY
(((:LAMBDA-LIST) &ENVIRONMENT SI::ENV SI::PROLOGUE SI::BEFORE-LOOP SI::MAIN-BODY SI::AFTER-LOOP SI::EPILOGUE &AUX SI::RBEFORE SI::RAFTER SI::FLAGVAR) ((SI:LOCATION DEFMACRO SI::LOOP-BODY) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 29779))
SI::LOOP-BUILD-DESTRUCTURING-BINDINGS
(((:LAMBDA-LIST) SI::CROCKS SI::FORMS) ((SI:LOCATION DEFUN SI::LOOP-BUILD-DESTRUCTURING-BINDINGS) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 38594))
SI::LOOP-CHECK-DATA-TYPE
(((:LAMBDA-LIST) SI::SPECIFIED-TYPE SI::REQUIRED-TYPE &OPTIONAL (SI::DEFAULT-TYPE SI::REQUIRED-TYPE)) ((SI:LOCATION DEFUN SI::LOOP-CHECK-DATA-TYPE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 37458))
SI::LOOP-CODE-DUPLICATION-THRESHOLD
(((:LAMBDA-LIST) SI::ENV) ((SI:LOCATION DEFUN SI::LOOP-CODE-DUPLICATION-THRESHOLD) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 29598))
SI::LOOP-COLLECT-ANSWER
(((:LAMBDA-LIST) SI::HEAD-VAR &OPTIONAL SI::USER-HEAD-VAR) ((SI:LOCATION DEFMACRO SI::LOOP-COLLECT-ANSWER) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 12472))
SI::LOOP-COLLECT-PREPOSITIONAL-PHRASES
(((:LAMBDA-LIST) SI::PREPOSITION-GROUPS &OPTIONAL SI::USING-ALLOWED SI::INITIAL-PHRASES) ((SI:LOCATION DEFUN SI::LOOP-COLLECT-PREPOSITIONAL-PHRASES) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 72132))
SI::LOOP-COLLECT-RPLACD
(((:LAMBDA-LIST) &ENVIRONMENT SI::ENV (SI::HEAD-VAR SI::TAIL-VAR &OPTIONAL SI::USER-HEAD-VAR) SI::FORM) ((SI:LOCATION DEFMACRO SI::LOOP-COLLECT-RPLACD) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 10418))
SI::LOOP-CONSTANT-FOLD-IF-POSSIBLE
(((:LAMBDA-LIST) SI::FORM &OPTIONAL SI::EXPECTED-TYPE) ((SI:LOCATION DEFUN SI::LOOP-CONSTANT-FOLD-IF-POSSIBLE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 28258))
SI::LOOP-CONSTANTP
(((:LAMBDA-LIST) SI::FORM) ((SI:LOCATION DEFUN SI::LOOP-CONSTANTP) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 29333))
SI::LOOP-CONSTRUCT-RETURN
(((:LAMBDA-LIST) SI::FORM) ((SI:LOCATION DEFUN SI::LOOP-CONSTRUCT-RETURN) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 42714))
SI::LOOP-CONTEXT
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::LOOP-CONTEXT) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 36924))
SI::LOOP-COPYLIST*
(((:LAMBDA-LIST) SI::L) ((SI:LOCATION DEFMACRO SI::LOOP-COPYLIST*) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 5932))
SI::LOOP-DECLARE-VARIABLE
(((:LAMBDA-LIST) SI::NAME SI::DTYPE) ((SI:LOCATION DEFUN SI::LOOP-DECLARE-VARIABLE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 49089))
SI::LOOP-DISALLOW-AGGREGATE-BOOLEANS
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::LOOP-DISALLOW-AGGREGATE-BOOLEANS) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 43847))
SI::LOOP-DISALLOW-ANONYMOUS-COLLECTORS
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::LOOP-DISALLOW-ANONYMOUS-COLLECTORS) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 43652))
SI::LOOP-DISALLOW-CONDITIONAL
(((:LAMBDA-LIST) &OPTIONAL SI::KWD) ((SI:LOCATION DEFUN SI::LOOP-DISALLOW-CONDITIONAL) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 43387))
SI::LOOP-DO-ALWAYS
(((:LAMBDA-LIST) SI::RESTRICTIVE SI::NEGATE) ((SI:LOCATION DEFUN SI::LOOP-DO-ALWAYS) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 57496))
SI::LOOP-DO-DO
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::LOOP-DO-DO) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 52273))
SI::LOOP-DO-FINALLY
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::LOOP-DO-FINALLY) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 52164))
SI::LOOP-DO-FOR
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::LOOP-DO-FOR) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 61413))
SI::LOOP-DO-IF
(((:LAMBDA-LIST) SI::FOR SI::NEGATEP) ((SI:LOCATION DEFUN SI::LOOP-DO-IF) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 50463))
SI::LOOP-DO-INITIALLY
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::LOOP-DO-INITIALLY) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 52050))
SI::LOOP-DO-NAMED
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::LOOP-DO-NAMED) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 52332))
SI::LOOP-DO-REPEAT
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::LOOP-DO-REPEAT) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 61887))
SI::LOOP-DO-RETURN
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::LOOP-DO-RETURN) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 52826))
SI::LOOP-DO-THEREIS
(((:LAMBDA-LIST) SI::RESTRICTIVE) ((SI:LOCATION DEFUN SI::LOOP-DO-THEREIS) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 57876))
SI::LOOP-DO-WHILE
(((:LAMBDA-LIST) SI::NEGATE SI::KWD &AUX (SI::FORM (SI::LOOP-GET-FORM))) ((SI:LOCATION DEFUN SI::LOOP-DO-WHILE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 58159))
SI::LOOP-DO-WITH
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::LOOP-DO-WITH) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 58328))
SI::LOOP-EMIT-BODY
(((:LAMBDA-LIST) SI::FORM) ((SI:LOCATION DEFUN SI::LOOP-EMIT-BODY) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 42822))
SI::LOOP-EMIT-FINAL-VALUE
(((:LAMBDA-LIST) &OPTIONAL (SI::FORM NIL SI::FORM-SUPPLIED-P)) ((SI:LOCATION DEFUN SI::LOOP-EMIT-FINAL-VALUE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 42936))
SI::LOOP-ERROR
(((:LAMBDA-LIST) SI::FORMAT-STRING &REST SI::FORMAT-ARGS) ((SI:LOCATION DEFUN SI::LOOP-ERROR) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 37102))
LOOP-FINISH
(((DOCUMENTATION . FUNCTION) . "Causes the iteration to terminate \"normally\", the same as implicit
termination by an iteration driving clause, or by use of WHILE or
UNTIL -- the epilogue code (if any) will be run, and any implicitly
collected result will be returned as the value of the LOOP.") ((:LAMBDA-LIST)) ((SI:LOCATION DEFMACRO LOOP-FINISH) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 38038))
SI::LOOP-FOR-ACROSS
(((:LAMBDA-LIST) SI::VAR SI::VAL SI::DATA-TYPE) ((SI:LOCATION DEFUN SI::LOOP-FOR-ACROSS) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 63453))
SI::LOOP-FOR-ARITHMETIC
(((:LAMBDA-LIST) SI::VAR SI::VAL SI::DATA-TYPE SI::KWD) ((SI:LOCATION DEFUN SI::LOOP-FOR-ARITHMETIC) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 79302))
SI::LOOP-FOR-BEING
(((:LAMBDA-LIST) SI::VAR SI::VAL SI::DATA-TYPE) ((SI:LOCATION DEFUN SI::LOOP-FOR-BEING) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 69387))
SI::LOOP-FOR-IN
(((:LAMBDA-LIST) SI::VAR SI::VAL SI::DATA-TYPE) ((SI:LOCATION DEFUN SI::LOOP-FOR-IN) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 67437))
SI::LOOP-FOR-ON
(((:LAMBDA-LIST) SI::VAR SI::VAL SI::DATA-TYPE) ((SI:LOCATION DEFUN SI::LOOP-FOR-ON) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 65689))
SI::LOOP-GET-COLLECTION-INFO
(((:LAMBDA-LIST) SI::COLLECTOR CLASS SI::DEFAULT-TYPE) ((SI:LOCATION DEFUN SI::LOOP-GET-COLLECTION-INFO) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 53158))
SI::LOOP-GET-COMPOUND-FORM
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::LOOP-GET-COMPOUND-FORM) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 42014))
SI::LOOP-GET-FORM
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::LOOP-GET-FORM) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 42545))
SI::LOOP-GET-PROGN
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::LOOP-GET-PROGN) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 42208))
SI::LOOP-HACK-ITERATION
(((:LAMBDA-LIST) SI::ENTRY) ((SI:LOCATION DEFUN SI::LOOP-HACK-ITERATION) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 58883))
SI::LOOP-HASH-TABLE-ITERATION-PATH
(((:LAMBDA-LIST) VARIABLE SI::DATA-TYPE SI::PREP-PHRASES &KEY SI::WHICH) ((SI:LOCATION DEFUN SI::LOOP-HASH-TABLE-ITERATION-PATH) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 80791))
SI::LOOP-ITERATION-DRIVER
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::LOOP-ITERATION-DRIVER) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 40746))
SI::LOOP-LIST-COLLECTION
(((:LAMBDA-LIST) SI::SPECIFICALLY) ((SI:LOCATION DEFUN SI::LOOP-LIST-COLLECTION) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 54776))
SI::LOOP-LIST-STEP
(((:LAMBDA-LIST) SI::LISTVAR) ((SI:LOCATION DEFUN SI::LOOP-LIST-STEP) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 64726))
SI::LOOP-LOOKUP-KEYWORD
(((:LAMBDA-LIST) SI::LOOP-TOKEN SI::TABLE) ((SI:LOCATION DEFUN SI::LOOP-LOOKUP-KEYWORD) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 18598))
SI::LOOP-MAKE-DESETQ
(((:LAMBDA-LIST) SI::VAR-VAL-PAIRS) ((SI:LOCATION DEFUN SI::LOOP-MAKE-DESETQ) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 21789))
SI::LOOP-MAKE-ITERATION-VARIABLE
(((:LAMBDA-LIST) SI::NAME SI::INITIALIZATION SI::DTYPE) ((SI:LOCATION DEFUN SI::LOOP-MAKE-ITERATION-VARIABLE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 48945))
SI::LOOP-MAKE-PSETQ
(((:LAMBDA-LIST) SI::FROBS) ((SI:LOCATION DEFUN SI::LOOP-MAKE-PSETQ) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 21556))
SI::LOOP-MAKE-VARIABLE
(((:LAMBDA-LIST) SI::NAME SI::INITIALIZATION SI::DTYPE &OPTIONAL SI::ITERATION-VARIABLE-P) ((SI:LOCATION DEFUN SI::LOOP-MAKE-VARIABLE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 47196))
SI::LOOP-MAXMIN-COLLECTION
(((:LAMBDA-LIST) SI::SPECIFICALLY) ((SI:LOCATION DEFUN SI::LOOP-MAXMIN-COLLECTION) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 56590))
SI::LOOP-MAYBE-BIND-FORM
(((:LAMBDA-LIST) SI::FORM SI::DATA-TYPE) ((SI:LOCATION DEFUN SI::LOOP-MAYBE-BIND-FORM) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 50285))
SI::LOOP-NOTE-MINIMAX-OPERATION
(((:LAMBDA-LIST) SI::OPERATION SI::MINIMAX) ((SI:LOCATION DEFUN SI::LOOP-NOTE-MINIMAX-OPERATION) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 15994))
SI::LOOP-OPTIMIZATION-QUANTITIES
(((:LAMBDA-LIST) SI::ENV) ((SI:LOCATION DEFUN SI::LOOP-OPTIMIZATION-QUANTITIES) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 6130))
SI::LOOP-OPTIONAL-TYPE
(((:LAMBDA-LIST) &OPTIONAL VARIABLE) ((SI:LOCATION DEFUN SI::LOOP-OPTIONAL-TYPE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 44353))
SI::LOOP-PACKAGE-SYMBOLS-ITERATION-PATH
(((:LAMBDA-LIST) VARIABLE SI::DATA-TYPE SI::PREP-PHRASES &KEY SI::SYMBOL-TYPES) ((SI:LOCATION DEFUN SI::LOOP-PACKAGE-SYMBOLS-ITERATION-PATH) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 83436))
SI::LOOP-POP-SOURCE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::LOOP-POP-SOURCE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 41821))
SI::LOOP-REALLY-DESETQ
(((:LAMBDA-LIST) &ENVIRONMENT SI::ENV &REST SI::VAR-VAL-PAIRS) ((SI:LOCATION DEFMACRO SI::LOOP-REALLY-DESETQ) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 22087))
SI::LOOP-SEQUENCER
(((:LAMBDA-LIST) SI::INDEXV SI::INDEXV-TYPE SI::INDEXV-USER-SPECIFIED-P VARIABLE SI::VARIABLE-TYPE SI::SEQUENCE-VARIABLE SI::SEQUENCE-TYPE SI::STEP-HACK SI::DEFAULT-TOP SI::PREP-PHRASES) ((SI:LOCATION DEFUN SI::LOOP-SEQUENCER) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 74092))
SI::LOOP-STANDARD-EXPANSION
(((:LAMBDA-LIST) SI::KEYWORDS-AND-FORMS SI::ENVIRONMENT SI::UNIVERSE) ((SI:LOCATION DEFUN SI::LOOP-STANDARD-EXPANSION) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 88186))
SI::LOOP-STORE-TABLE-DATA
(((:LAMBDA-LIST) SYMBOL SI::TABLE SI::DATUM) ((SI:LOCATION DEFMACRO SI::LOOP-STORE-TABLE-DATA) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 18759))
SI::LOOP-SUM-COLLECTION
(((:LAMBDA-LIST) SI::SPECIFICALLY SI::REQUIRED-TYPE SI::DEFAULT-TYPE) ((SI:LOCATION DEFUN SI::LOOP-SUM-COLLECTION) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 55687))
SI::LOOP-TASSOC
(((:LAMBDA-LIST) SI::KWD SI::ALIST) ((SI:LOCATION DEFUN SI::LOOP-TASSOC) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 18366))
SI::LOOP-TEQUAL
(((:LAMBDA-LIST) SI::X1 SI::X2) ((SI:LOCATION DEFUN SI::LOOP-TEQUAL) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 18276))
SI::LOOP-TMEMBER
(((:LAMBDA-LIST) SI::KWD LIST) ((SI:LOCATION DEFUN SI::LOOP-TMEMBER) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 18482))
SI::LOOP-TRANSLATE
(((:LAMBDA-LIST) SI::*LOOP-SOURCE-CODE* SI::*LOOP-MACRO-ENVIRONMENT* SI::*LOOP-UNIVERSE*) ((SI:LOCATION DEFUN SI::LOOP-TRANSLATE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 38923))
SI::LOOP-TYPED-INIT
(((:LAMBDA-LIST) SI::DATA-TYPE) ((SI:LOCATION DEFUN SI::LOOP-TYPED-INIT) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 44087))
SI::LOOP-UNSAFE
(((:LAMBDA-LIST) &REST SI::X) ((SI:LOCATION DEFMACRO SI::LOOP-UNSAFE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 4970))
SI::LOOP-VARIABLE-P
(((:LAMBDA-LIST) SI::NAME) ((SI:LOCATION DEFUN SI::LOOP-VARIABLE-P) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 47011))
SI::LOOP-WARN
(((:LAMBDA-LIST) SI::FORMAT-STRING &REST SI::FORMAT-ARGS) ((SI:LOCATION DEFUN SI::LOOP-WARN) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 37292))
SI::LOOP-WHEN-IT-VARIABLE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::LOOP-WHEN-IT-VARIABLE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 62548))
LOWER-CASE-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR)

Returns T if CHAR is a lower-case character; NIL otherwise.
") ((:LAMBDA-LIST) CHAR))
MACHINE-INSTANCE
(((DOCUMENTATION . FUNCTION) . "Args: ()
Returns, as a string, the identifier of the machine on which ECL runs.") ((:LAMBDA-LIST)) ((SI:LOCATION DEFUN MACHINE-INSTANCE) #P"BUILD:LSP;CONFIG.LSP.NEWEST" . 1437))
MACHINE-TYPE
(((DOCUMENTATION . FUNCTION) . "Args: ()
Returns, as a string, the type of the machine on which ECL runs.") ((:LAMBDA-LIST)) ((SI:LOCATION DEFUN MACHINE-TYPE) #P"BUILD:LSP;CONFIG.LSP.NEWEST" . 1172))
MACHINE-VERSION
(((DOCUMENTATION . FUNCTION) . "Args: ()
Returns, as a string, the version of the machine on which ECL runs. Obtained from
uname(2) where available.") ((:LAMBDA-LIST)) ((SI:LOCATION DEFUN MACHINE-VERSION) #P"BUILD:LSP;CONFIG.LSP.NEWEST" . 1695))
MACRO-FUNCTION
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL)

Returns the expansion function of the global macro named SYMBOL.  Returns NIL
if no such macro exists.  The expansion function receives a macro form and an
environment, and returns the expanded form.
") ((:LAMBDA-LIST) SYMBOL))
MACROEXPAND
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FORM &OPTIONAL (ENV NIL))

If FORM is a macro form, then expands it repeatedly until the result is not a
macro any more, and returns the result as the first value and T as the second
value.  Otherwise, returns FORM and NIL as two values.
") ((:LAMBDA-LIST) SI::FORM &OPTIONAL (SI::ENV NIL)))
MACROEXPAND-1
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FORM &OPTIONAL (ENV NIL))

If FORM is a macro form, then expands it once and returns the result as the
first value and T as the second value.  Otherwise, returns FORM and NIL as two
values.
") ((:LAMBDA-LIST) SI::FORM &OPTIONAL (SI::ENV NIL)))
MACROLET
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (macrolet ({(name defmacro-lambda-list {decl | doc}* {form}*)}*)
          . body)

Introduces local macros and evaluates BODY as a PROGN.  See DEFMACRO for the
complete syntax of defmacro-lambda-list.  Doc-strings for local macros are
simply ignored.
") ((:LAMBDA-LIST) . "(macrolet ({(name defmacro-lambda-list {decl | doc}* {form}*)}*)
          . body)"))
SI::MAKE-ACCESS-FUNCTION
(((:LAMBDA-LIST) SI::NAME SI::CONC-NAME TYPE SI::NAMED SI::SLOT-DESCR) ((SI:LOCATION DEFUN SI::MAKE-ACCESS-FUNCTION) #P"SRC:LSP;DEFSTRUCT.LSP.NEWEST" . 848))
SI::MAKE-ANSI-LOOP-UNIVERSE
(((:LAMBDA-LIST) SI::EXTENDED-P) ((SI:LOCATION DEFUN SI::MAKE-ANSI-LOOP-UNIVERSE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 84471))
MAKE-ARRAY
(((SI:LOCATION DEFINE-COMPILER-MACRO MAKE-ARRAY) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 1773) ((DOCUMENTATION . FUNCTION) . "Args: (dimensions &key (element-type t) initial-element (initial-contents nil)
		    (adjustable nil) (fill-pointer nil) (displaced-to nil)
		    (displaced-index-offset 0) (static nil))
Creates an array of the specified DIMENSIONS.  DIMENSIONS is a list of
non-negative integers each representing the length of the corresponding
dimension.  It may be an integer for vectors, i.e., one-dimensional arrays.
ELEMENT-TYPE specifies the type of array elements.  INITIAL-ELEMENT specifies
the initial value for all elements.  Its default value depends on ELEMENT-
TYPE.  INITIAL-CONTENTS specifies each element in terms of sequences.
ADJUSTABLE specifies whether or not the array is adjustable (see ADJUST-
ARRAY).  FILL-POINTER is meaningful only for vectors.  It specifies whether
the vector has fill-pointer or not, and if it has, the initial value of the
fill-pointer.  Possible values are NIL (no fill-pointer), T (the length of the
vector), or an integer.  See VECTOR-PUSH and VECTOR-POP.  DISPLACED-TO, if
non-NIL, must be an array and specifies that the new array is displaced to the
given array.  DISPLACED-INDEX-OFFSET is meaningful only when DISPLACED-TO is
non-NIL and specifies that the reference to the I-th element of the new array
in raw-major indexing is actually the reference to the (I + DISPLACED-INDEX-
OFFSET)th element of the given array.If the STATIC argument is supplied
with a non-nil value, then the body of the array is allocated as a
contiguous block.") ((:LAMBDA-LIST) SI::DIMENSIONS &KEY (SI::ELEMENT-TYPE T) (SI::INITIAL-ELEMENT NIL SI::INITIAL-ELEMENT-SUPPLIED-P) (SI::INITIAL-CONTENTS NIL SI::INITIAL-CONTENTS-SUPPLIED-P) SI::ADJUSTABLE FILL-POINTER SI::DISPLACED-TO (SI::DISPLACED-INDEX-OFFSET 0)) ((SI:LOCATION DEFUN MAKE-ARRAY) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 607))
C::MAKE-BLK
(((:LAMBDA-LIST) &KEY #:NAME (#:REF 0) #:REF-CCB #:REF-CLB #:READ-NODES #:EXIT #:DESTINATION #:VAR (#:TYPE '(VALUES &REST T))) ((SI:LOCATION DEFUN C::MAKE-BLK) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 7652))
SI::MAKE-BLOCK-END
(((:LAMBDA-LIST) &KEY (#:POSN 0) #:SUFFIX) ((SI:LOCATION DEFUN SI::MAKE-BLOCK-END) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 13280))
SI::MAKE-BLOCK-START
(((:LAMBDA-LIST) &KEY (#:POSN 0) (#:DEPTH 0) #:SECTION-END #:BLOCK-END #:PREFIX #:SUFFIX) ((SI:LOCATION DEFUN SI::MAKE-BLOCK-START) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 12465))
MAKE-BROADCAST-STREAM
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&REST STREAMS)

Creates and returns a broadcast stream.  Outputs to this stream are output to
all STREAMs.  A broadcast stream is notated as
	#<broadcast stream n>
where N is a number that identify the stream.
") ((:LAMBDA-LIST) &REST SI::STREAMS))
C::MAKE-C1FORM
(((:LAMBDA-LIST) C::NAME C::SUBFORM &REST C::ARGS) ((SI:LOCATION DEFUN C::MAKE-C1FORM) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 3886))
C::MAKE-C1FORM*
(((:LAMBDA-LIST) C::NAME &REST C::ARGS) ((SI:LOCATION DEFUN C::MAKE-C1FORM*) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 4402))
SI::MAKE-CHAR
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (CHAR &OPTIONAL (BITS 0) (FONT 0))

Returns a character object with the same code as CHAR and with the specified
BITS and FONT attributes.  Returns NIL if no such character exists.
") ((:LAMBDA-LIST) CHAR &OPTIONAL (SI::BITS 0) (SI::FONT 0)))
MAKE-CONCATENATED-STREAM
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&REST STREAMS)

Creates and returns a concatenated stream.  Inputs from this stream are first
obtained from the first STREAM.  When the end of the first STREAM is reached,
then inputs are obtained from the second STREAM.  And so forth.
A concatenated stream is notated as
	#<concatenated stream n>
where N is a number that identifies the stream.
") ((:LAMBDA-LIST) &REST SI::STREAMS))
MAKE-CONDITION
(((:LAMBDA-LIST) TYPE &REST SI::SLOT-INITIALIZATIONS) ((SI:LOCATION DEFUN MAKE-CONDITION) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 8508))
SI::MAKE-CONSTRUCTOR
(((:LAMBDA-LIST) SI::NAME SI::CONSTRUCTOR TYPE SI::NAMED SI::SLOT-DESCRIPTIONS) ((SI:LOCATION DEFUN SI::MAKE-CONSTRUCTOR) #P"SRC:LSP;DEFSTRUCT.LSP.NEWEST" . 4242))
MAKE-DISPATCH-MACRO-CHARACTER
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR &OPTIONAL (NON-TERMINATING-P NIL) (READTABLE *READTABLE*))

Register CHAR as a dispatch macro character in READTABLE.  NON-TERMINATING-P
specifies whether CHAR is non-terminating (see READTABLE).
") ((:LAMBDA-LIST) CHAR &OPTIONAL (SI::NON-TERMINATING-P NIL) (READTABLE *READTABLE*)))
C::MAKE-DISPATCH-TABLE
(((:LAMBDA-LIST) C::ALIST) ((SI:LOCATION DEFUN C::MAKE-DISPATCH-TABLE) #P"SRC:CMP;CMPTABLES.LSP.NEWEST" . 6595))
MAKE-ECHO-STREAM
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STREAM1 STREAM2)

Creates and returns an echo stream.  Inputs from this stream are obtained from
STREAM1 and outputs to this stream are output to STREAM2.  In addition, all
inputs from STREAM1 are output to STREAM2.
An echo stream is notated as
	#<echo stream n>
where N is a number that identifies the stream.
") ((:LAMBDA-LIST) SI::STREAM1 SI::STREAM2))
CLOS::MAKE-EMPTY-STANDARD-CLASS
(((:LAMBDA-LIST) CLOS::NAME CLOS::METACLASS) ((SI:LOCATION DEFUN CLOS::MAKE-EMPTY-STANDARD-CLASS) #P"SRC:CLOS;BOOT.LSP.NEWEST" . 774))
SI:MAKE-ENCODING
(((:LAMBDA-LIST) SI::MAPPING) ((SI:LOCATION DEFUN SI:MAKE-ENCODING) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 12739))
SI:MAKE-EXTERNAL-PROCESS
(((:LAMBDA-LIST) SI::PID SI::INPUT SI::OUTPUT &AUX (SI::%STATUS :RUNNING) SI::%CODE) ((SI:LOCATION DEFUN SI:MAKE-EXTERNAL-PROCESS) #P"SRC:LSP;PROCESS.LSP.NEWEST" . 519))
SI::MAKE-FORMAT-DIRECTIVE
(((:LAMBDA-LIST) &KEY (#:STRING T) (#:START 0) (#:END 0) (#:CHARACTER #\ ) #:COLONP #:ATSIGNP #:PARAMS) ((SI:LOCATION DEFUN SI::MAKE-FORMAT-DIRECTIVE) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 9422))
C::MAKE-FUN
(((:LAMBDA-LIST) &KEY #:NAME (#:REF 0) #:REF-CCB #:REF-CLB #:READ-NODES #:CFUN (#:LEVEL 0) (#:ENV 0) #:GLOBAL #:EXPORTED #:NO-ENTRY #:SHARES-WITH #:CLOSURE #:VAR #:DESCRIPTION #:LAMBDA (#:MINARG 0) (#:MAXARG CALL-ARGUMENTS-LIMIT) (#:RETURN-TYPE '(VALUES &REST T)) (#:PARENT C::*CURRENT-FUNCTION*) #:LOCAL-VARS #:REFERRED-VARS #:REFERRED-FUNS #:CHILD-FUNS (#:FILE (CAR SI:*SOURCE-LOCATION*)) (#:FILE-POSITION (OR (CDR SI:*SOURCE-LOCATION*) C::*COMPILE-FILE-POSITION*)) (#:CMP-ENV (C::CMP-ENV-COPY))) ((SI:LOCATION DEFUN C::MAKE-FUN) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 5093))
CLOS::MAKE-FUNCTION-INITFORM
(((:LAMBDA-LIST) CLOS::FORM) ((SI:LOCATION DEFUN CLOS::MAKE-FUNCTION-INITFORM) #P"SRC:CLOS;SLOT.LSP.NEWEST" . 3815))
MAKE-HASH-TABLE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&KEY (TEST 'EQL) (SIZE 1024) (REHASH-SIZE 1.5) (REHASH-THRESHOLD 0.7))

Creates and returns a hash-table.
TEST specifies which predicate should be used to access hash-table entries.
It must be EQ, EQL, or EQUAL.  SIZE specifies the number of entries in the
hash-table.  REHASH-SIZE, if an integer, specifies how many entries should be
added when the hash-table becomes 'almost full'.  REHASH-SIZE, if a float,
specifies the ratio of the new size and the old size.  REHASH-THRESHOLD
specifies when to expand the hash-table.  If an integer, the hash-table is
expanded when REHASH-THRESHOLD / REHASH-SIZE entries have been used.  If a
float, the hash-table is expanded when REHASH-THRESHOLD times the whole
entries have been used.
") ((:LAMBDA-LIST) &KEY (SI::TEST 'EQL) (SI::SIZE 1024) (SI::REHASH-SIZE 1.5) (SI::REHASH-THRESHOLD 0.7)))
SI::MAKE-INDENTATION
(((:LAMBDA-LIST) &KEY (#:POSN 0) (#:KIND (SI::REQUIRED-ARGUMENT)) (#:AMOUNT 0)) ((SI:LOCATION DEFUN SI::MAKE-INDENTATION) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 12198))
C::MAKE-INFO
(((:LAMBDA-LIST) &KEY #:LOCAL-VARS (#:TYPE '(VALUES &REST T)) #:SP-CHANGE #:VOLATILE) ((SI:LOCATION DEFUN C::MAKE-INFO) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 8929))
C::MAKE-INLINE-INFO
(((:LAMBDA-LIST) &KEY #:NAME #:ARG-REP-TYPES #:RETURN-REP-TYPE #:ARG-TYPES #:RETURN-TYPE #:EXACT-RETURN-TYPE #:EXPANSION #:ONE-LINER) ((SI:LOCATION DEFUN C::MAKE-INLINE-INFO) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 9252))
C::MAKE-INLINE-TEMP-VAR
(((:LAMBDA-LIST) C::VALUE-TYPE &OPTIONAL C::REP-TYPE) ((SI:LOCATION DEFUN C::MAKE-INLINE-TEMP-VAR) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 1415))
MAKE-INSTANCE
(((SI:LOCATION DEFMETHOD MAKE-INSTANCE (CLASS STRUCTURE-CLASS) &REST CLOS::INITARGS) #P"SRC:CLOS;BUILTIN.LSP.NEWEST" . 4954) ((SI:LOCATION DEFMETHOD MAKE-INSTANCE (CLASS-NAME SYMBOL) &REST CLOS::INITARGS) #P"SRC:CLOS;BUILTIN.LSP.NEWEST" . 3837) ((SI:LOCATION DEFMETHOD MAKE-INSTANCE (CLASS BUILT-IN-CLASS) &REST CLOS::INITARGS) #P"SRC:CLOS;BUILTIN.LSP.NEWEST" . 1374) ((SI:LOCATION DEFMETHOD MAKE-INSTANCE (CLASS CLASS) &REST CLOS::INITARGS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 3920))
MAKE-INSTANCES-OBSOLETE
(((SI:LOCATION DEFMETHOD MAKE-INSTANCES-OBSOLETE (CLASS CLASS)) #P"SRC:CLOS;CHANGE.LSP.NEWEST" . 8913) ((SI:LOCATION DEFMETHOD MAKE-INSTANCES-OBSOLETE (CLASS SYMBOL)) #P"SRC:CLOS;BUILTIN.LSP.NEWEST" . 3728))
C::MAKE-LCL-VAR
(((:LAMBDA-LIST) &KEY C::REP-TYPE (TYPE 'T)) ((SI:LOCATION DEFUN C::MAKE-LCL-VAR) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 6982))
MAKE-LIST
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (LENGTH &KEY (INITIAL-ELEMENT NIL))

Creates and returns a list of the specified LENGTH, whose elements are all the
value of INITIAL-ELEMENT.
") ((:LAMBDA-LIST) LENGTH &KEY (SI::INITIAL-ELEMENT NIL)))
MAKE-LOAD-FORM
(((SI:LOCATION DEFMETHOD MAKE-LOAD-FORM (PACKAGE PACKAGE) &OPTIONAL CLOS::ENVIRONMENT) #P"SRC:CLOS;PRINT.LSP.NEWEST" . 4661) ((SI:LOCATION DEFMETHOD MAKE-LOAD-FORM (CLASS CLASS) &OPTIONAL CLOS::ENVIRONMENT) #P"SRC:CLOS;PRINT.LSP.NEWEST" . 4433) ((SI:LOCATION DEFMETHOD MAKE-LOAD-FORM (CLOS::OBJECT STANDARD-OBJECT) &OPTIONAL CLOS::ENVIRONMENT) #P"SRC:CLOS;PRINT.LSP.NEWEST" . 4317) ((SI:LOCATION DEFMETHOD MAKE-LOAD-FORM (CLOS::OBJECT T) &OPTIONAL CLOS::ENVIRONMENT) #P"SRC:CLOS;PRINT.LSP.NEWEST" . 2880) ((SI:LOCATION DEFMETHOD MAKE-LOAD-FORM (CLOS::OBJECT STRUCTURE-OBJECT) &OPTIONAL CLOS::ENVIRONMENT) #P"SRC:CLOS;BUILTIN.LSP.NEWEST" . 5607))
MAKE-LOAD-FORM-SAVING-SLOTS
(((:LAMBDA-LIST) CLOS::OBJECT &KEY CLOS::SLOT-NAMES CLOS::ENVIRONMENT) ((SI:LOCATION DEFUN MAKE-LOAD-FORM-SAVING-SLOTS) #P"SRC:CLOS;PRINT.LSP.NEWEST" . 682))
SI::MAKE-LOGICAL-BLOCK
(((:LAMBDA-LIST) &KEY (#:START-COLUMN 0) (#:SECTION-COLUMN 0) (#:PER-LINE-PREFIX-END 0) (#:PREFIX-LENGTH 0) (#:SUFFIX-LENGTH 0) (#:SECTION-START-LINE 0)) ((SI:LOCATION DEFUN SI::MAKE-LOGICAL-BLOCK) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 7068))
SI::MAKE-LOOP-COLLECTOR
(((:LAMBDA-LIST) &KEY #:NAME #:CLASS #:HISTORY #:TEMPVARS #:DTYPE #:DATA) ((SI:LOCATION DEFUN SI::MAKE-LOOP-COLLECTOR) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 52946))
SI::MAKE-LOOP-MINIMAX
(((:LAMBDA-LIST) SI::ANSWER-VARIABLE TYPE) ((SI:LOCATION DEFUN SI::MAKE-LOOP-MINIMAX) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 15546))
SI::MAKE-LOOP-MINIMAX-INTERNAL
(((:LAMBDA-LIST) &KEY #:ANSWER-VARIABLE #:TYPE #:TEMP-VARIABLE #:FLAG-VARIABLE #:OPERATIONS #:INFINITY-DATA) ((SI:LOCATION DEFUN SI::MAKE-LOOP-MINIMAX-INTERNAL) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 13454))
SI::MAKE-LOOP-PATH
(((:LAMBDA-LIST) &KEY #:NAMES #:PREPOSITION-GROUPS #:INCLUSIVE-PERMITTED #:FUNCTION #:USER-DATA) ((SI:LOCATION DEFUN SI::MAKE-LOOP-PATH) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 68396))
SI::MAKE-LOOP-UNIVERSE
(((:LAMBDA-LIST) &KEY #:KEYWORDS #:ITERATION-KEYWORDS #:FOR-KEYWORDS #:PATH-KEYWORDS #:TYPE-SYMBOLS #:TYPE-KEYWORDS #:ANSI #:IMPLICIT-FOR-REQUIRED) ((SI:LOCATION DEFUN SI::MAKE-LOOP-UNIVERSE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 18871))
MAKE-METHOD
(((:LAMBDA-LIST) CLOS::METHOD-CLASS CLOS::QUALIFIERS CLOS::SPECIALIZERS CLOS::ARGLIST FUNCTION CLOS::PLIST CLOS::OPTIONS) ((SI:LOCATION DEFUN MAKE-METHOD) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 4073))
SI::MAKE-NEWLINE
(((:LAMBDA-LIST) &KEY (#:POSN 0) (#:DEPTH 0) #:SECTION-END (#:KIND (SI::REQUIRED-ARGUMENT))) ((SI:LOCATION DEFUN SI::MAKE-NEWLINE) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 11504))
FFI:MAKE-NULL-POINTER
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN FFI:MAKE-NULL-POINTER) #P"SRC:LSP;FFI.LSP.NEWEST" . 11999))
MAKE-PACKAGE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (PACKAGE-NAME &KEY (NICKNAMES NIL) (USE '(LISP)))

Creates and returns a new package named PACKAGE-NAME.  PACKAGE-NAME must be a
string or a symbol.  The print name is used if PACKAGE-NAME is a symbol.
NICKNAMES gives the nicknames of the package.  It must be a list of strings
and symbols.  USE specifies the packages used by the created package.  It must
be a list of package objects, strings, and symbols.
") ((:LAMBDA-LIST) PACKAGE-NAME &KEY (SI::NICKNAMES NIL) (SI::USE '(SI::LISP))))
MAKE-PATHNAME
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&KEY (DEFAULTS (PARSE-NAMESTRING \"\" (PATHNAME-HOST *DEFAULT-PATHNAME-DEFAULTS*))) (HOST (PATHNAME-HOST DEFAULTS)) (DEVICE (PATHNAME-DEVICE DEFAULTS)) (DIRECTORY (PATHNAME-DIRECTORY DEFAULTS)) (NAME (PATHNAME-NAME DEFAULTS)) (TYPE (PATHNAME-TYPE DEFAULTS)) (VERSION (PATHNAME-VERSION DEFAULTS)))

Creates a pathname object with the slot values specified by HOST, DEVICE,
DIRECTORY, NAME, TYPE, and VERSION.
") ((:LAMBDA-LIST) &KEY (SI::DEFAULTS (PARSE-NAMESTRING SI::|""| (PATHNAME-HOST *DEFAULT-PATHNAME-DEFAULTS*))) (SI::HOST (PATHNAME-HOST SI::DEFAULTS)) (SI::DEVICE (PATHNAME-DEVICE SI::DEFAULTS)) (DIRECTORY (PATHNAME-DIRECTORY SI::DEFAULTS)) (SI::NAME (PATHNAME-NAME SI::DEFAULTS)) (TYPE (PATHNAME-TYPE SI::DEFAULTS)) (SI::VERSION (PATHNAME-VERSION SI::DEFAULTS))))
SI:MAKE-PIPE
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: NIL
Creates a pipe in the form of a two-way stream that can be used for
interprocess and interthread communication.
") ((:LAMBDA-LIST)))
FFI:MAKE-POINTER
(((:LAMBDA-LIST) FFI::ADDR TYPE) ((SI:LOCATION DEFUN FFI:MAKE-POINTER) #P"SRC:LSP;FFI.LSP.NEWEST" . 12113))
SI::MAKE-PPRINT-DISPATCH-ENTRY
(((:LAMBDA-LIST) &KEY (#:TYPE (SI::REQUIRED-ARGUMENT)) (#:PRIORITY 0) (#:INITIAL-P (NOT (BOUNDP 'SI::*INITIAL-PPRINT-DISPATCH*))) (#:FUNCTION (SI::REQUIRED-ARGUMENT))) ((SI:LOCATION DEFUN SI::MAKE-PPRINT-DISPATCH-ENTRY) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 37751))
SI::MAKE-PPRINT-DISPATCH-TABLE
(((:LAMBDA-LIST) &KEY #:ENTRIES (#:CONS-ENTRIES (MAKE-HASH-TABLE :TEST #'EQL))) ((SI:LOCATION DEFUN SI::MAKE-PPRINT-DISPATCH-TABLE) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 38530))
SI::MAKE-PREDICATE
(((:LAMBDA-LIST) SI::NAME TYPE SI::NAMED SI::NAME-OFFSET) ((SI:LOCATION DEFUN SI::MAKE-PREDICATE) #P"SRC:LSP;DEFSTRUCT.LSP.NEWEST" . 6759))
SI::MAKE-PRETTY-STREAM
(((:LAMBDA-LIST) SI::TARGET) ((SI:LOCATION DEFUN SI::MAKE-PRETTY-STREAM) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 4322))
SI::MAKE-QUEUED-OP
(((:LAMBDA-LIST) &KEY (#:POSN 0)) ((SI:LOCATION DEFUN SI::MAKE-QUEUED-OP) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 10646))
MAKE-RANDOM-STATE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&OPTIONAL (RANDOM-STATE NIL))

Creates and returns a random-state object.  If RANDOM-STATE is NIL, copies the
value of *RANDOM-STATE*.  If RANDOM-STATE is a random-state, copies it.  If
RANDOM-STATE is T, creates a random-state randomly.
") ((:LAMBDA-LIST) &OPTIONAL (RANDOM-STATE NIL)))
C::MAKE-REF
(((:LAMBDA-LIST) &KEY #:NAME (#:REF 0) #:REF-CCB #:REF-CLB #:READ-NODES) ((SI:LOCATION DEFUN C::MAKE-REF) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 937))
SI::MAKE-RESTART
(((:LAMBDA-LIST) &KEY #:NAME #:FUNCTION #:REPORT-FUNCTION #:INTERACTIVE-FUNCTION (#:TEST-FUNCTION (CONSTANTLY T))) ((SI:LOCATION DEFUN SI::MAKE-RESTART) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 2088))
SI::MAKE-SECTION-START
(((:LAMBDA-LIST) &KEY (#:POSN 0) (#:DEPTH 0) #:SECTION-END) ((SI:LOCATION DEFUN SI::MAKE-SECTION-START) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 11371))
SI::MAKE-SEQ-ITERATOR
(((:LAMBDA-LIST) SEQUENCE &OPTIONAL (SI::START 0)) ((SI:LOCATION DEFUN SI::MAKE-SEQ-ITERATOR) #P"SRC:LSP;SEQ.LSP.NEWEST" . 5190))
MAKE-SEQUENCE
(((DOCUMENTATION . FUNCTION) . "Args: (type length &key initial-element)
Creates and returns a sequence of the given TYPE and LENGTH.  If INITIAL-
ELEMENT is given, then it becomes the elements of the created sequence.  The
default value of INITIAL-ELEMENT depends on TYPE.") ((:LAMBDA-LIST) TYPE SI::SIZE &KEY (SI::INITIAL-ELEMENT NIL SI::IESP) &AUX SEQUENCE) ((SI:LOCATION DEFUN MAKE-SEQUENCE) #P"SRC:LSP;SEQ.LSP.NEWEST" . 4056))
CLOS::MAKE-SIMPLE-SLOTD
(((:LAMBDA-LIST) &KEY CLOS::NAME (CLOS::INITFORM CLOS::+INITFORM-UNSUPPLIED+) CLOS::INITFUNCTION (TYPE 'T) (CLOS::ALLOCATION :INSTANCE) CLOS::INITARGS CLOS::READERS CLOS::WRITERS DOCUMENTATION CLOS::LOCATION) ((SI:LOCATION DEFUN CLOS::MAKE-SIMPLE-SLOTD) #P"SRC:CLOS;SLOT.LSP.NEWEST" . 2126))
SI::MAKE-STANDARD-LOOP-UNIVERSE
(((:LAMBDA-LIST) &KEY SI::KEYWORDS SI::FOR-KEYWORDS SI::ITERATION-KEYWORDS SI::PATH-KEYWORDS SI::TYPE-KEYWORDS SI::TYPE-SYMBOLS SI::ANSI) ((SI:LOCATION DEFUN SI::MAKE-STANDARD-LOOP-UNIVERSE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 20311))
MAKE-STRING
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (LENGTH &KEY (INITIAL-ELEMENT  ))

Creates and returns a new string of the given LENGTH, whose elements are all
INITIAL-ELEMENT.
") ((:LAMBDA-LIST) LENGTH &KEY (SI::INITIAL-ELEMENT #\ )))
MAKE-STRING-INPUT-STREAM
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING &OPTIONAL (START 0) (END (LENGTH STRING)))

Creates and returns a string-input stream.  Inputs from this stream are
obtained form STRING.  A string-input stream is notated as
	#<string-input stream from s>
where S is a string.
") ((:LAMBDA-LIST) STRING &OPTIONAL (SI::START 0) (SI::END (LENGTH STRING))))
MAKE-STRING-OUTPUT-STREAM
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: NIL

Creates and returns a string-output stream.  Outputs to this stream are
obtained as a string by GET-OUTPUT-STREAM-STRING.  A string-output stream
is notated as
	#<string-output stream n>
where N is a number that identifies the stream.
") ((:LAMBDA-LIST)))
SI:MAKE-STRING-OUTPUT-STREAM-FROM-STRING
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (STRING)
)
ECL specific.
Creates and returns a string-output-stream to STRING.  STRING must have a
fill-pointer.
") ((:LAMBDA-LIST) STRING))
MAKE-SYMBOL
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING)

Creates and returns a new uninterned symbol whose print name is STRING.
") ((:LAMBDA-LIST) STRING))
MAKE-SYNONYM-STREAM
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL)

Creates and returns a synonym stream to SYMBOL.  Inputs from this stream are
obtained from, and outputs to this stream are sent to the stream that is the
value of the global variable named SYMBOL.  A synonym stream is notated as
	#<synonym stream to s>
where S is a symbol.
") ((:LAMBDA-LIST) SYMBOL))
SI::MAKE-TAB
(((:LAMBDA-LIST) &KEY (#:POSN 0) #:SECTIONP #:RELATIVEP (#:COLNUM 0) (#:COLINC 0)) ((SI:LOCATION DEFUN SI::MAKE-TAB) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 13729))
C::MAKE-TAG
(((:LAMBDA-LIST) &KEY #:NAME (#:REF 0) #:REF-CCB #:REF-CLB #:READ-NODES #:LABEL #:UNWIND-EXIT #:VAR #:INDEX) ((SI:LOCATION DEFUN C::MAKE-TAG) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 8376))
C::MAKE-TEMP-VAR
(((:LAMBDA-LIST) &OPTIONAL (TYPE 'T)) ((SI:LOCATION DEFUN C::MAKE-TEMP-VAR) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 7205))
MAKE-TWO-WAY-STREAM
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STREAM1 STREAM2)

Creates and returns a two-way stream.  Inputs from this stream are obtained
from STREAM1 and outputs to this stream are sent to STREAM2.  A two-way stream
is notated as
	#<two-way stream n>
where N is a number that identifies the stream.
") ((:LAMBDA-LIST) SI::STREAM1 SI::STREAM2))
C::MAKE-VAR
(((:LAMBDA-LIST) &REST C::ARGS) ((SI:LOCATION DEFUN C::MAKE-VAR) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 555))
C::MAKE-VV
(((:LAMBDA-LIST) &KEY #:LOCATION #:USED-P (#:PERMANENT-P T) #:VALUE) ((SI:LOCATION DEFUN C::MAKE-VV) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 10201))
MAKUNBOUND
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL)

Makes the global variable named SYMBOL have no value.  Returns SYMBOL.
") ((:LAMBDA-LIST) SYMBOL))
MAP
(((DOCUMENTATION . FUNCTION) . "Args: (type function sequence &rest more-sequences)
Creates and returns a sequence of TYPE with K elements, with the N-th element
being the value of applying FUNCTION to the N-th elements of the given
SEQUENCEs, where K is the minimum length of the given SEQUENCEs.") ((:LAMBDA-LIST) SI::RESULT-TYPE FUNCTION SEQUENCE &REST SI::MORE-SEQUENCES) ((SI:LOCATION DEFUN MAP) #P"SRC:LSP;SEQ.LSP.NEWEST" . 9358))
CLOS:MAP-DEPENDENTS
(((SI:LOCATION DEFMETHOD CLOS:MAP-DEPENDENTS (CLOS::C CLASS) FUNCTION) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 9814) ((:LAMBDA-LIST) CLOS::C FUNCTION) ((SI:LOCATION DEFUN CLOS:MAP-DEPENDENTS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 7948))
MAP-INTO
(((DOCUMENTATION . FUNCTION) . "Fills the output sequence with the values returned by applying FUNCTION to the
elements of the given sequences. The i-th element of RESULT-SEQUENCE is the output
of applying FUNCTION to the i-th element of each of the sequences. The map routine
stops when it reaches the end of one of the given sequences.") ((:LAMBDA-LIST) SI::RESULT-SEQUENCE FUNCTION &REST SI::SEQUENCES) ((SI:LOCATION DEFUN MAP-INTO) #P"SRC:LSP;SEQ.LSP.NEWEST" . 12307))
CLOS::MAPAPPEND
(((:LAMBDA-LIST) CLOS::FUN &REST CLOS::ARGS) ((SI:LOCATION DEFMACRO CLOS::MAPAPPEND) #P"SRC:CLOS;MACROS.LSP.NEWEST" . 470))
MAPC
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FUNCTION LIST &REST MORE-LISTS)

For each N (0 <= N < K), applies FUNCTION to the N-th elements of the given
LISTs, where K is the minimum length of the given LISTs.  Returns the first
LIST.
") ((:LAMBDA-LIST) FUNCTION LIST &REST SI::MORE-LISTS) ((SI:LOCATION DEFINE-COMPILER-MACRO MAPC) #P"SRC:CMP;CMPMAP.LSP.NEWEST" . 1979))
MAPCAN
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FUNCTION LIST &REST MORE-LISTS)

For each N (0 <= N < K), applies FUNCTION to the N-th elements of the given
LISTs, where K is the minimum length of the given LISTs.  Nconcs the values,
one for each call to FUNCTION, and returns the result.
") ((:LAMBDA-LIST) FUNCTION LIST &REST SI::MORE-LISTS) ((SI:LOCATION DEFINE-COMPILER-MACRO MAPCAN) #P"SRC:CMP;CMPMAP.LSP.NEWEST" . 2056))
MAPCAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FUNCTION LIST &REST MORE-LISTS)

Creates and returns a list of K elements, with the N-th element being the
value of applying FUNCTION to the N-th elements of the given LISTs, where K
is the minimum length of the given LISTs.
") ((:LAMBDA-LIST) FUNCTION LIST &REST SI::MORE-LISTS) ((SI:LOCATION DEFINE-COMPILER-MACRO MAPCAR) #P"SRC:CMP;CMPMAP.LSP.NEWEST" . 1900))
MAPCON
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FUNCTION LIST &REST MORE-LISTS)

For each N (0 <= N < K), applies FUNCTION to the N-th cdrs of the given LISTs,
where K is the minimum length of the given LISTs.  Nconcs the values, one for
each call to FUNCTION, and returns the result.
") ((:LAMBDA-LIST) FUNCTION LIST &REST SI::MORE-LISTS) ((SI:LOCATION DEFINE-COMPILER-MACRO MAPCON) #P"SRC:CMP;CMPMAP.LSP.NEWEST" . 2292))
MAPHASH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: #'HASH-TABLE

For each entry of HASH-TABLE, applies FUNCTION to the key and the value of the
entry.  Returns NIL.
") ((:LAMBDA-LIST) FUNCTION HASH-TABLE))
MAPL
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FUNCTION LIST &REST MORE-LISTS)

For each N (0 <= N < K), applies FUNCTION to the N-th cdrs of the given LISTs,
where K is the minimum length of the given LISTs.  Returns the first LIST.
") ((:LAMBDA-LIST) FUNCTION LIST &REST SI::MORE-LISTS) ((SI:LOCATION DEFINE-COMPILER-MACRO MAPL) #P"SRC:CMP;CMPMAP.LSP.NEWEST" . 2215))
MAPLIST
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FUNCTION LIST &REST MORE-LISTS)

Creates and returns a list of K elements, with the N-th element being the
value of applying FUNCTION to the N-th cdrs of the given LISTs, where K is the
minimum length of the given LISTs.
") ((:LAMBDA-LIST) FUNCTION LIST &REST SI::MORE-LISTS) ((SI:LOCATION DEFINE-COMPILER-MACRO MAPLIST) #P"SRC:CMP;CMPMAP.LSP.NEWEST" . 2135))
MASK-FIELD
(((DOCUMENTATION . FUNCTION) . "Args: (bytespec integer)
Extracts the specified byte from INTEGER and returns the result as an integer.") ((:LAMBDA-LIST) SI::BYTESPEC INTEGER) ((SI:LOCATION DEFUN MASK-FIELD) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 10798))
SI::MATCH-DIMENSIONS
(((:LAMBDA-LIST) ARRAY SI::PAT) ((SI:LOCATION DEFUN SI::MATCH-DIMENSIONS) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 14668))
MAX
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER &REST MORE-NUMBERS)

Returns the largest arg.  The args must be non-complex numbers.
") ((:LAMBDA-LIST) NUMBER &REST SI::MORE-NUMBERS))
SI::MAXIMUM-ALLOCATABLE-PAGES
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (TYPE)

ECL specific.
Returns the current maximum number of pages for the type class of the ECL
implementation type TYPE.
") ((:LAMBDA-LIST) TYPE))
C::MAXIMUM-FLOAT-TYPE
(((:LAMBDA-LIST) C::T1 C::T2) ((SI:LOCATION DEFUN C::MAXIMUM-FLOAT-TYPE) #P"SRC:CMP;CMPC-INLINER.LSP.NEWEST" . 4582))
C::MAXIMUM-NUMBER-TYPE
(((:LAMBDA-LIST) C::T1 C::T2 &KEY C::ONLY-REAL C::INTEGER-RESULT) ((SI:LOCATION DEFUN C::MAXIMUM-NUMBER-TYPE) #P"SRC:CMP;CMPNUM.LSP.NEWEST" . 2106))
C::MAYBE-ADD-POLICY
(((:LAMBDA-LIST) C::DECL &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::MAYBE-ADD-POLICY) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 3494))
C::MAYBE-OPEN-INLINE-BLOCK
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::MAYBE-OPEN-INLINE-BLOCK) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 6354))
C::MAYBE-OPTIMIZE-GENERIC-FUNCTION
(((:LAMBDA-LIST) C::FNAME C::ARGS) ((SI:LOCATION DEFUN C::MAYBE-OPTIMIZE-GENERIC-FUNCTION) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 555))
C::MAYBE-OPTIMIZE-SLOT-ACCESSOR
(((:LAMBDA-LIST) C::FNAME C::GF C::ARGS) ((SI:LOCATION DEFUN C::MAYBE-OPTIMIZE-SLOT-ACCESSOR) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 2613))
C::MAYBE-OPTIMIZE-STRUCTURE-ACCESS
(((:LAMBDA-LIST) C::FNAME C::ARGS) ((SI:LOCATION DEFUN C::MAYBE-OPTIMIZE-STRUCTURE-ACCESS) #P"SRC:CMP;CMPSTRUCTURES.LSP.NEWEST" . 1032))
SI::MAYBE-OUTPUT
(((:LAMBDA-LIST) STREAM SI::FORCE-NEWLINES-P) ((SI:LOCATION DEFUN SI::MAYBE-OUTPUT) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 18189))
SI:MAYBE-QUOTE
(((:LAMBDA-LIST) SI::FORM) ((SI:LOCATION DEFUN SI:MAYBE-QUOTE) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 12102))
SI::MAYBE-SAVE-TYPES
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::MAYBE-SAVE-TYPES) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 25798))
C::MAYBE-SAVE-VALUE
(((:LAMBDA-LIST) C::VALUE &OPTIONAL (C::OTHER-FORMS NIL C::OTHER-FORMS-FLAG)) ((SI:LOCATION DEFUN C::MAYBE-SAVE-VALUE) #P"SRC:CMP;CMPCALL.LSP.NEWEST" . 7487))
SI:MAYBE-UNQUOTE
(((:LAMBDA-LIST) SI::FORM) ((SI:LOCATION DEFUN SI:MAYBE-UNQUOTE) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 11992))
MEMBER
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ITEM LIST &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT)

Searches LIST for an element that is equal to ITEM in the sense of the TEST.
If found, returns the sublist of LIST that begins with the element.
Otherwise, returns NIL.
") ((:LAMBDA-LIST) SI::ITEM LIST &KEY (SI::KEY '#'IDENTITY) (SI::TEST '#'EQL) SI::TEST-NOT) ((SI:LOCATION DEFINE-COMPILER-MACRO MEMBER) #P"SRC:CMP;CMPOPT-SEQUENCE.LSP.NEWEST" . 8493))
MEMBER-IF
(((DOCUMENTATION . FUNCTION) . "Searches LIST for an element that satisfies TEST.  If found, returns the
sublist of LIST that begins with the element.  If not found, returns NIL.") ((:LAMBDA-LIST) SI::TEST LIST &KEY SI::KEY) ((SI:LOCATION DEFUN MEMBER-IF) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 5128))
MEMBER-IF-NOT
(((DOCUMENTATION . FUNCTION) . "Searches LIST for an element that does not satisfy TEST.  If found, returns
the sublist of LIST that begins with the element.  If not found, returns NIL.") ((:LAMBDA-LIST) SI::TEST LIST &KEY SI::KEY) ((SI:LOCATION DEFUN MEMBER-IF-NOT) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 5365))
C::MEMBER-TYPE
(((:LAMBDA-LIST) TYPE C::DISJOINT-SUPERTYPES) ((SI:LOCATION DEFUN C::MEMBER-TYPE) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 1239))
C::MEMBER-VAR
(((:LAMBDA-LIST) C::VAR LIST) ((SI:LOCATION DEFUN C::MEMBER-VAR) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 12389))
MERGE
(((DOCUMENTATION . FUNCTION) . "Args: (type sequence1 sequence2 test &key key)
Merges two sequences in the way specified by TEST and returns the result as a
sequence of TYPE.  Both SEQUENCEs may be destroyed.  If both SEQUENCE1 and
SEQUENCE2 are sorted in the sense of TEST, then the result is also sorted in
the sense of TEST.") ((:LAMBDA-LIST) SI::RESULT-TYPE SI::SEQUENCE1 SI::SEQUENCE2 SI::PREDICATE &KEY SI::KEY &AUX (SI::L1 (LENGTH SI::SEQUENCE1)) (SI::L2 (LENGTH SI::SEQUENCE2))) ((SI:LOCATION DEFUN MERGE) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 36676))
MERGE-PATHNAMES
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC &OPTIONAL (DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*) DEFAULT-VERSION)

Fills in unspecified slots of the pathname specified by FILESPEC from the
pathname specified by DEFAULTS, and returns the result pathname.  DEFAULT-
VERSION is simply ignored in ECL.  FILESPEC and DEFAULTS may be a symbol, a
string, a pathname, or a file stream.
") ((:LAMBDA-LIST) SI::FILESPEC &OPTIONAL (SI::DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*) SI::DEFAULT-VERSION))
METHOD
(((SI:LOCATION DEFCLASS METHOD) #P"SRC:CLOS;STDMETHOD.LSP.NEWEST" . 1308))
METHOD-COMBINATION-ERROR
(((:LAMBDA-LIST) CLOS::FORMAT-CONTROL &REST CLOS::ARGS) ((SI:LOCATION DEFUN METHOD-COMBINATION-ERROR) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 11239))
CLOS:METHOD-FUNCTION
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS:METHOD-FUNCTION) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS:METHOD-FUNCTION) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 5417))
CLOS:METHOD-GENERIC-FUNCTION
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS:METHOD-GENERIC-FUNCTION) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS:METHOD-GENERIC-FUNCTION) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 5417))
CLOS::METHOD-KEYWORDS
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS::METHOD-KEYWORDS) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS::METHOD-KEYWORDS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 5417))
CLOS:METHOD-LAMBDA-LIST
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS:METHOD-LAMBDA-LIST) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS:METHOD-LAMBDA-LIST) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 5417))
CLOS::METHOD-NEEDS-NEXT-METHODS-P
(((:LAMBDA-LIST) METHOD) ((SI:LOCATION DEFUN CLOS::METHOD-NEEDS-NEXT-METHODS-P) #P"SRC:CLOS;METHOD.LSP.NEWEST" . 11144))
CLOS::METHOD-P
(((:LAMBDA-LIST) METHOD) ((SI:LOCATION DEFUN CLOS::METHOD-P) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 4024))
CLOS::METHOD-PLIST
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS::METHOD-PLIST) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS::METHOD-PLIST) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 5417))
METHOD-QUALIFIERS
(((SI:LOCATION DEFINE-COMPILER-MACRO METHOD-QUALIFIERS) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN METHOD-QUALIFIERS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 5417))
CLOS:METHOD-SPECIALIZERS
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS:METHOD-SPECIALIZERS) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS:METHOD-SPECIALIZERS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 5417))
MIN
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER &REST MORE-NUMBERS)

Returns the smallest arg.  The args must be non-complex numbers.
") ((:LAMBDA-LIST) NUMBER &REST SI::MORE-NUMBERS))
MINUSP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER)

Returns T if NUMBER is negative; NIL otherwise.
") ((:LAMBDA-LIST) NUMBER))
SI::MISERING-P
(((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFUN SI::MISERING-P) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 20094))
MISMATCH
(((DOCUMENTATION . FUNCTION) . "Args: (sequence1 sequence2
       &key key (test '#'eql) test-not
            (start1 0) (end1 (length sequence1))
            (start2 0) (end2 (length sequence2))
            (from-end nil))
Compares element-wise the specified subsequences of SEQUENCE1 and SEQUENCE2.
Returns NIL if they are of the same length and they have the same elements in
the sense of TEST.  Otherwise, returns the index of SEQUENCE1 to the first
element that does not match.") ((:LAMBDA-LIST) SI::SEQUENCE1 SI::SEQUENCE2 &KEY SI::FROM-END SI::TEST SI::TEST-NOT SI::KEY (SI::START1 0) (SI::START2 0) SI::END1 SI::END2) ((SI:LOCATION DEFUN MISMATCH) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 26756))
MOD
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER DIVISOR)

Returns the second result of (FLOOR NUMBER DIVISOR), i.e. the value of
	(- NUMBER (* (FLOOR NUMBER DIVISOR) DIVISOR))
") ((:LAMBDA-LIST) NUMBER SI::DIVISOR))
SI::MONTH-STARTDAYS
(((SI:LOCATION DEFCONSTANT SI::MONTH-STARTDAYS) #P"SRC:LSP;MISLIB.LSP.NEWEST" . 4011))
MOST-NEGATIVE-DOUBLE-FLOAT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Same as MOST-NEGATIVE-LONG-FLOAT.
"))
MOST-NEGATIVE-FIXNUM
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The negative fixnum with the largest absolute value.  - 2^29 in ECL.
"))
MOST-NEGATIVE-LONG-FLOAT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The long-float with the largest absolute value.
"))
MOST-NEGATIVE-SHORT-FLOAT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The short-float with the largest absolute value.
"))
MOST-NEGATIVE-SINGLE-FLOAT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Same as MOST-NEGATIVE-LONG-FLOAT.
"))
MOST-POSITIVE-DOUBLE-FLOAT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Same as MOST-POSITIVE-LONG-FLOAT.
"))
MOST-POSITIVE-FIXNUM
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The largest positive fixnum.  2^29 - 1 in ECL.
"))
MOST-POSITIVE-LONG-FLOAT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The largest positive long-float.
"))
MOST-POSITIVE-SHORT-FLOAT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The largest positive short-float.
"))
MOST-POSITIVE-SINGLE-FLOAT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
Same as MOST-POSITIVE-LONG-FLOAT.
"))
MUFFLE-WARNING
(((:LAMBDA-LIST) &OPTIONAL SI::C) ((SI:LOCATION DEFUN MUFFLE-WARNING) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 24286))
MULTIPLE-VALUE-BIND
(((DOCUMENTATION . FUNCTION) . "Syntax: (multiple-value-bind ({var}*) init {decl}* {form}*)

Evaluates INIT and binds the N-th VAR to the N-th value of INIT or, if INIT
returns less than N values, to NIL.  Then evaluates FORMs, and returns all
values of the last FORM.  If no FORM is given, returns NIL.") ((:LAMBDA-LIST) SI::VARS SI::FORM &REST SI::BODY) ((SI:LOCATION DEFMACRO MULTIPLE-VALUE-BIND) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 9301))
MULTIPLE-VALUE-CALL
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (multiple-value-call function-form {form}*)

Evaluates FUNCTION-FORM, whose value must be a function.  Then evaluates FORMs
and applies the function to all values of FORMs.  Unlike FUNCALL, all values
of each FORM are used as arguments.  Returns all values of the function.
") ((:LAMBDA-LIST) . "(multiple-value-call function-form {form}*)"))
MULTIPLE-VALUE-LIST
(((DOCUMENTATION . FUNCTION) . "Evaluates FORM and returns a list of all values FORM returns.") ((:LAMBDA-LIST) SI::FORM) ((SI:LOCATION DEFMACRO MULTIPLE-VALUE-LIST) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 8534))
MULTIPLE-VALUE-PROG1
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (multiple-value-prog1 first-form {form}*)

Evaluates FIRST-FORM, saves all values it returns, and then evaluates FORMs.
Returns all the saved values of FIRST-FORM.
") ((:LAMBDA-LIST) . "(multiple-value-prog1 first-form {form}*)"))
MULTIPLE-VALUE-SETQ
(((DOCUMENTATION . FUNCTION) . "Syntax: (multiple-value-setq {var}* form)

Evaluates FORM and binds the N-th VAR to the N-th value of FORM or, if FORM
returns less than N values, to NIL.  Returns the first value of FORM or, if
FORM returns no value, NIL.") ((:LAMBDA-LIST) SI::VARS SI::FORM) ((SI:LOCATION DEFMACRO MULTIPLE-VALUE-SETQ) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 8675))
MULTIPLE-VALUES-LIMIT
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The upper bound on the number of values that a function can return.  Actually,
however, there is no such upper bound in ECL.
"))
NAME-CHAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NAME)

Given an argument acceptable to string,
Returns a character object with the specified character name (see CHARACTER).
Returns NIL if no such character object exists.  NAME is typically a string
but may be any object that can be coerced to string.
") ((:LAMBDA-LIST) SI::NAME))
SI::NAMED-VARIABLE
(((:LAMBDA-LIST) SI::NAME) ((SI:LOCATION DEFUN SI::NAMED-VARIABLE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 71848))
NAMESTRING
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC)

Returns as a string all slots of the pathname specified by FILESPEC.  FILESPEC
may be a symbol, a string, a pathname, or a file stream.
") ((:LAMBDA-LIST) SI::FILESPEC))
NBUTLAST
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (LIST &OPTIONAL (N 1))

Destructive BUTLAST.  LIST may be destroyed.
") ((:LAMBDA-LIST) LIST &OPTIONAL (SI::N 1)))
NCONC
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&REST LISTS)

Destructive APPEND.  The args except for the last may be destroyed.
") ((:LAMBDA-LIST) &REST SI::LISTS))
SI::NEED-HAIRY-ARGS
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::NEED-HAIRY-ARGS) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 18280))
CLOS::NEED-TO-MAKE-LOAD-FORM-P
(((DOCUMENTATION . FUNCTION) . "Return T if the object cannot be externalized using the lisp
printer and we should rather use MAKE-LOAD-FORM.") ((:LAMBDA-LIST) CLOS::OBJECT) ((SI:LOCATION DEFUN CLOS::NEED-TO-MAKE-LOAD-FORM-P) #P"SRC:CLOS;PRINT.LSP.NEWEST" . 1386))
C::NEGATE-ARGUMENT
(((:LAMBDA-LIST) C::INLINED-ARG C::DEST-LOC) ((SI:LOCATION DEFUN C::NEGATE-ARGUMENT) #P"SRC:CMP;CMPIF.LSP.NEWEST" . 3104))
C::NEW-DEFUN
(((:LAMBDA-LIST) C::NEW &OPTIONAL C::NO-ENTRY) ((SI:LOCATION DEFUN C::NEW-DEFUN) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 10300))
C::NEW-LOCAL
(((:LAMBDA-LIST) C::FUN) ((SI:LOCATION DEFUN C::NEW-LOCAL) #P"SRC:CMP;CMPSPECIAL.LSP.NEWEST" . 3364))
SI::NEW-TYPE-TAG
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::NEW-TYPE-TAG) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 25309))
SI::NEWLINE
(((SI:LOCATION DEFCLASS SI::NEWLINE) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 11504))
SI::NEXT-ARG
(((:LAMBDA-LIST) &OPTIONAL SI::OFFSET) ((SI:LOCATION DEFMACRO SI::NEXT-ARG) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 21402))
C::NEXT-CFUN
(((:LAMBDA-LIST) &OPTIONAL (C::PREFIX "L~D~A") (C::LISP-NAME NIL)) ((SI:LOCATION DEFUN C::NEXT-CFUN) #P"SRC:CMP;CMPMAC.LSP.NEWEST" . 2494))
C::NEXT-CMACRO
(((:LAMBDA-LIST)) ((SI:LOCATION DEFMACRO C::NEXT-CMACRO) #P"SRC:CMP;CMPMAC.LSP.NEWEST" . 2264))
C::NEXT-ENV
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::NEXT-ENV) #P"SRC:CMP;CMPMAC.LSP.NEWEST" . 2885))
C::NEXT-LABEL
(((:LAMBDA-LIST)) ((SI:LOCATION DEFMACRO C::NEXT-LABEL) #P"SRC:CMP;CMPMAC.LSP.NEWEST" . 2335))
C::NEXT-LABEL*
(((:LAMBDA-LIST)) ((SI:LOCATION DEFMACRO C::NEXT-LABEL*) #P"SRC:CMP;CMPMAC.LSP.NEWEST" . 2391))
C::NEXT-LCL
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::NEXT-LCL) #P"SRC:CMP;CMPMAC.LSP.NEWEST" . 2448))
C::NEXT-LEX
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::NEXT-LEX) #P"SRC:CMP;CMPMAC.LSP.NEWEST" . 2763))
NEXT-METHOD-P
(((SI:LOCATION DEFINE-COMPILER-MACRO NEXT-METHOD-P) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 4614) ((:LAMBDA-LIST)) ((SI:LOCATION DEFUN NEXT-METHOD-P) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 4309))
C::NEXT-TEMP
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::NEXT-TEMP) #P"SRC:CMP;CMPMAC.LSP.NEWEST" . 2650))
NIL
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The value of NIL is NIL.
") ((DOCUMENTATION . TYPE) . "
The type NIL is a subtype of every type.  No object belongs to this type."))
NINTERSECTION
(((DOCUMENTATION . FUNCTION) . "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Destructive INTERSECTION.  Only LIST1 may be destroyed.") ((:LAMBDA-LIST) SI::LIST1 SI::LIST2 &KEY SI::TEST SI::TEST-NOT SI::KEY) ((SI:LOCATION DEFUN NINTERSECTION) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 1899))
NINTH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CAR (CDDDDR (CDDDDR X))).
") ((:LAMBDA-LIST) SI::X))
NO-APPLICABLE-METHOD
(((SI:LOCATION DEFMETHOD NO-APPLICABLE-METHOD CLOS::GF CLOS::ARGS) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 8469))
NO-NEXT-METHOD
(((SI:LOCATION DEFMETHOD NO-NEXT-METHOD CLOS::GF METHOD &REST CLOS::ARGS) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 8648))
CLOS::NO-PRIMARY-METHOD
(((:LAMBDA-LIST) CLOS::GF &REST CLOS::ARGS) ((SI:LOCATION DEFUN CLOS::NO-PRIMARY-METHOD) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 8800))
SI::NORMALIZE-TYPE
(((:LAMBDA-LIST) TYPE &AUX SI::TP SI::I SI::FD) ((SI:LOCATION DEFUN SI::NORMALIZE-TYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 20824))
NOT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is NIL; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
NOTANY
(((DOCUMENTATION . FUNCTION) . "Args: (predicate sequence &rest more-sequences)
Returns T if none of the elements in SEQUENCEs satisfies PREDICATE; NIL
otherwise.") ((:LAMBDA-LIST) SI::PREDICATE SEQUENCE &REST SI::MORE-SEQUENCES) ((SI:LOCATION DEFUN NOTANY) #P"SRC:LSP;SEQ.LSP.NEWEST" . 11787))
NOTEVERY
(((DOCUMENTATION . FUNCTION) . "Args: (predicate sequence &rest more-sequences)
Returns T if at least one of the elements in SEQUENCEs does not satisfy
PREDICATE; NIL otherwise.") ((:LAMBDA-LIST) SI::PREDICATE SEQUENCE &REST SI::MORE-SEQUENCES) ((SI:LOCATION DEFUN NOTEVERY) #P"SRC:LSP;SEQ.LSP.NEWEST" . 12038))
NRECONC
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X Y)

Equivalent to (NCONC (NREVERSE X) Y).
") ((:LAMBDA-LIST) SI::X SI::Y))
NREVERSE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SEQUENCE)

Destructive REVERSE.  The arg may be destroyed.
") ((:LAMBDA-LIST) SEQUENCE))
NSET-DIFFERENCE
(((DOCUMENTATION . FUNCTION) . "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Destructive SET-DIFFERENCE.  Only LIST1 may be destroyed.") ((:LAMBDA-LIST) SI::LIST1 SI::LIST2 &KEY SI::TEST SI::TEST-NOT SI::KEY) ((SI:LOCATION DEFUN NSET-DIFFERENCE) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 2682))
NSET-EXCLUSIVE-OR
(((DOCUMENTATION . FUNCTION) . "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Destructive SET-EXCLUSIVE-OR.  Both LIST1 and LIST2 may be destroyed.") ((:LAMBDA-LIST) SI::LIST1 SI::LIST2 &KEY SI::TEST SI::TEST-NOT SI::KEY) ((SI:LOCATION DEFUN NSET-EXCLUSIVE-OR) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 3651))
NSTRING-CAPITALIZE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING &KEY (START 0) (END (LENGTH STRING)))

Destructive STRING-CAPITALIZE.  STRING may be destroyed.
") ((:LAMBDA-LIST) STRING &KEY (SI::START 0) (SI::END (LENGTH STRING))))
SI::NSTRING-CAPITALIZE-FIRST
(((:LAMBDA-LIST) SI::S) ((SI:LOCATION DEFUN SI::NSTRING-CAPITALIZE-FIRST) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 63515))
NSTRING-DOWNCASE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING &KEY (START 0) (END (LENGTH STRING)))

Destructive STRING-DOWNCASE.  STRING may be destroyed.
") ((:LAMBDA-LIST) STRING &KEY (SI::START 0) (SI::END (LENGTH STRING))))
NSTRING-UPCASE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING &KEY (START 0) (END (LENGTH STRING)))

Destructive STRING-UPCASE.  STRING may be destroyed.
") ((:LAMBDA-LIST) STRING &KEY (SI::START 0) (SI::END (LENGTH STRING))))
NSUBLIS
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ALIST TREE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT)

Destructive SUBLIS.  TREE may be destroyed.
") ((:LAMBDA-LIST) SI::ALIST SI::TREE &KEY (SI::KEY '#'IDENTITY) (SI::TEST '#'EQL) SI::TEST-NOT))
NSUBST
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NEW OLD TREE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT)

Destructive SUBST.  TREE may be destroyed.
") ((:LAMBDA-LIST) SI::NEW SI::OLD SI::TREE &KEY (SI::KEY '#'IDENTITY) (SI::TEST '#'EQL) SI::TEST-NOT))
NSUBST-IF
(((DOCUMENTATION . FUNCTION) . "Destructive SUBST-IF. TREE may be modified.") ((:LAMBDA-LIST) SI::NEW SI::TEST SI::TREE &KEY SI::KEY) ((SI:LOCATION DEFUN NSUBST-IF) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 6053))
NSUBST-IF-NOT
(((DOCUMENTATION . FUNCTION) . "Destructive SUBST-IF-NOT. TREE may be modified.") ((:LAMBDA-LIST) SI::NEW SI::TEST SI::TREE &KEY SI::KEY) ((SI:LOCATION DEFUN NSUBST-IF-NOT) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 6195))
C::NSUBST-VAR
(((:LAMBDA-LIST) C::VAR C::FORM) ((SI:LOCATION DEFUN C::NSUBST-VAR) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 11805))
NSUBSTITUTE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NEW OLD SEQUENCE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Destructive SUBSTITUTE.  SEQUENCE may be destroyed.
") ((:LAMBDA-LIST) SI::NEW SI::OLD SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::TEST '#'EQL) SI::TEST-NOT (SI::START 0) (SI::END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN NSUBSTITUTE) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 15427))
NSUBSTITUTE-IF
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NEW TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Destructive SUBSTITUTE-IF.  SEQUENCE may be destroyed.
") ((:LAMBDA-LIST) SI::NEW SI::TEST SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::START 0) (SI::END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN NSUBSTITUTE-IF) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 16786))
NSUBSTITUTE-IF-NOT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NEW TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Destructive SUBSTITUTE-IF-NOT.  SEQUENCE may be destroyed.
") ((:LAMBDA-LIST) SI::NEW SI::TEST SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::START 0) (SI::END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN NSUBSTITUTE-IF-NOT) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 17094))
NTH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (N LIST)

Returns the N-th element of LIST, the first element of LIST being the zeroth.
Returns NIL if the length of LIST is less than N.  N must be a non-negative
integer.
") ((:LAMBDA-LIST) SI::N LIST) ((SI:LOCATION DEFINE-COMPILER-MACRO NTH) #P"SRC:CMP;CMPOPT-CONS.LSP.NEWEST" . 2729))
NTH-VALUE
(((:LAMBDA-LIST) SI::N SI::EXPR) ((SI:LOCATION DEFMACRO NTH-VALUE) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 11921))
NTHCDR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (N LIST)

Returns the N-th cdr of LIST.  N must be a non-negative integer.
") ((:LAMBDA-LIST) SI::N LIST) ((SI:LOCATION DEFINE-COMPILER-MACRO NTHCDR) #P"SRC:CMP;CMPOPT-CONS.LSP.NEWEST" . 3257))
NULL
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is NIL; NIL otherwise.
") ((:LAMBDA-LIST) SI::X) ((DOCUMENTATION . TYPE) . "The type to which only NIL belongs."))
FFI:NULL-CHAR-P
(((:LAMBDA-LIST) CHAR) ((SI:LOCATION DEFUN FFI:NULL-CHAR-P) #P"SRC:LSP;FFI.LSP.NEWEST" . 12621))
SI:NULL-POINTER-P
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (PTR)

Return true if PTR is a null pointer.
") ((:LAMBDA-LIST) SI::PTR))
NUMBER
(((DOCUMENTATION . TYPE) . "
A number is an integer, a ratio, a float, or a complex number.  Integers and
ratios are collectively called rationals."))
SI::NUMBER-MEMBER-TYPE
(((:LAMBDA-LIST) SI::OBJECT) ((SI:LOCATION DEFUN SI::NUMBER-MEMBER-TYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 30682))
SI::NUMBER-OF-DAYS-FROM-1900
(((:LAMBDA-LIST) SI::Y) ((SI:LOCATION DEFUN SI::NUMBER-OF-DAYS-FROM-1900) #P"SRC:LSP;MISLIB.LSP.NEWEST" . 3832))
NUMBERP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a number; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
NUMERATOR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (RATIONAL)

Returns the numerator of RATIONAL as an integer, if RATIONAL is a ratio.
Returns RATIONAL if it is an integer.
") ((:LAMBDA-LIST) RATIONAL))
NUNION
(((DOCUMENTATION . FUNCTION) . "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Destructive UNION.  Both LIST1 and LIST2 may be destroyed.") ((:LAMBDA-LIST) SI::LIST1 SI::LIST2 &KEY SI::TEST SI::TEST-NOT SI::KEY) ((SI:LOCATION DEFUN NUNION) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 1048))
C::OBJECT-TYPE
(((:LAMBDA-LIST) C::THING) ((SI:LOCATION DEFUN C::OBJECT-TYPE) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 1476))
ODDP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (INTEGER)

Returns T if INTEGER is an odd number; NIL otherwise.
") ((:LAMBDA-LIST) INTEGER))
SI:OF-CLASS-P
(((:LAMBDA-LIST) SI::OBJECT CLASS) ((SI:LOCATION DEFUN SI:OF-CLASS-P) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 19867))
SI::ONCE-ONLY
(((DOCUMENTATION . FUNCTION) . "Once-Only ({(Var Value-Expression)}*) Form*
  Create a Let* which evaluates each Value-Expression, binding a temporary
  variable to the result, and wrapping the Let* around the result of the
  evaluation of Body.  Within the body, each Var is bound to the corresponding
  temporary variable.") ((:LAMBDA-LIST) SI::SPECS &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::ONCE-ONLY) #P"SRC:LSP;CMUUTIL.LSP.NEWEST" . 382))
OPEN
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC &KEY (DIRECTION INPUT) ELEMENT-TYPE IF-EXISTS IF-DOES-NOT-EXIST)

Opens the specified file and returns a file stream to/from the file.  FILESPEC
may be a symbol, a string, a pathname, or a file stream.  DIRECTION may be
:INPUT, :OUTPUT, :IO, or :PROBE.  ELEMENT-TYPE is simply ignored in ECL.  IF-
EXISTS specifies what to do when DIRECTION is either :OUTPUT or :IO and the
specified file exists already.  It may be :ERROR (the default), :NEW-VERSION,
:RENAME, :RENAME-AND-DELETE, :OVERWRITE, :APPEND, :SUPERSEDE, or NIL.  IF-
DOES-NOT-EXIST specifies what to do when the specified file does not exists.
It may be :ERROR (the default when DIRECTION is :INPUT), :CREATE (the default
when DIRECTION is either :OUTPUT or :IO), or NIL.
File streams are notated in one of the following ways:
	#<input stream f>
	#<output stream f>
	#<io stream f>
	#<probe stream f>
where F is the file name.
") ((:LAMBDA-LIST) SI::FILESPEC &KEY (SI::DIRECTION :INPUT) SI::ELEMENT-TYPE SI::IF-EXISTS SI::IF-DOES-NOT-EXIST))
GRAY:OPEN-STREAM-P
(((SI:LOCATION DEFMETHOD GRAY:OPEN-STREAM-P (STREAM T)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 14086) ((SI:LOCATION DEFMETHOD GRAY:OPEN-STREAM-P (STREAM SI:ANSI-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 14009) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:OPEN-STREAM-P) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 4082))
C::OPTIMIZATION-QUALITY-SWITCHES
(((:LAMBDA-LIST) TYPE C::INDEX) ((SI:LOCATION DEFUN C::OPTIMIZATION-QUALITY-SWITCHES) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 1794))
C::OPTIMIZE-FUNCALL/APPLY-LAMBDA
(((:LAMBDA-LIST) C::LAMBDA-FORM C::ARGUMENTS C::APPLY-P &AUX C::BODY C::APPLY-LIST C::APPLY-VAR C::LET-VARS C::EXTRA-STMTS C::ALL-KEYS) ((SI:LOCATION DEFUN C::OPTIMIZE-FUNCALL/APPLY-LAMBDA) #P"SRC:CMP;CMPLAM.LSP.NEWEST" . 18616))
C::OPTIONAL-TYPE-CHECK
(((:LAMBDA-LIST) &WHOLE C::WHOLE C::VALUE TYPE &ENVIRONMENT C::ENV) ((SI:LOCATION DEFMACRO C::OPTIONAL-TYPE-CHECK) #P"SRC:CMP;CMPTYPE.LSP.NEWEST" . 7111))
OR
(((DOCUMENTATION . FUNCTION) . "Macro in COMMON-LISP package:
Syntax: (or {form}*)

Evaluates FORMs in order from left to right.  If any FORM evaluates to non-
NIL, quits and returns that (single) value.  If the last FORM is reached,
returns whatever values it returns.
") ((:LAMBDA-LIST) . "(or {form}*)"))
SI::ORDINAL-ONES
(((SI:LOCATION DEFCONSTANT SI::ORDINAL-ONES) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 36220) ((DOCUMENTATION . VARIABLE) . "Table of ordinal ones-place digits in English"))
SI::ORDINAL-TENS
(((SI:LOCATION DEFCONSTANT SI::ORDINAL-TENS) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 36385) ((DOCUMENTATION . VARIABLE) . "Table of ordinal tens-place digits in English"))
SI::OUR-PDE-HOOK
(((:LAMBDA-LIST) SI:LOCATION SI::DEFINITION SI::OUTPUT-FORM) ((SI:LOCATION DEFUN SI::OUR-PDE-HOOK) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/src/doc/help.lsp" . 1995))
C::OUTPUT-CFUNS
(((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFUN C::OUTPUT-CFUNS) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 30306))
C::OUTPUT-CLINES
(((:LAMBDA-LIST) C::OUTPUT-STREAM) ((SI:LOCATION DEFUN C::OUTPUT-CLINES) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 13964))
SI::OUTPUT-LINE
(((:LAMBDA-LIST) STREAM SI:UNTIL) ((SI:LOCATION DEFUN SI::OUTPUT-LINE) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 21012))
SI::OUTPUT-PARTIAL-LINE
(((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFUN SI::OUTPUT-PARTIAL-LINE) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 23425))
SI::OUTPUT-SPACES
(((:LAMBDA-LIST) STREAM SI::N) ((SI:LOCATION DEFUN SI::OUTPUT-SPACES) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 57512))
GRAY:OUTPUT-STREAM-P
(((SI:LOCATION DEFMETHOD GRAY:OUTPUT-STREAM-P (STREAM T)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 14403) ((SI:LOCATION DEFMETHOD GRAY:OUTPUT-STREAM-P (STREAM SI:ANSI-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 14321) ((SI:LOCATION DEFMETHOD GRAY:OUTPUT-STREAM-P (STREAM GRAY:FUNDAMENTAL-OUTPUT-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 14251) ((SI:LOCATION DEFMETHOD GRAY:OUTPUT-STREAM-P (STREAM GRAY:FUNDAMENTAL-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 14187) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:OUTPUT-STREAM-P) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 4304))
OUTPUT-STREAM-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STREAM)

Returns T if STREAM can handle output operations; NIL otherwise.
") ((:LAMBDA-LIST) STREAM))
SI::OVERWRITE-SLOT-DESCRIPTIONS
(((:LAMBDA-LIST) SI::NEW-SLOTS SI::OLD-SLOTS) ((SI:LOCATION DEFUN SI::OVERWRITE-SLOT-DESCRIPTIONS) #P"SRC:LSP;DEFSTRUCT.LSP.NEWEST" . 9155))
C::P1BLOCK
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::BLK C::BODY) ((SI:LOCATION DEFUN C::P1BLOCK) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 3573))
C::P1CALL-GLOBAL
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::FNAME C::ARGS &OPTIONAL (C::RETURN-TYPE T)) ((SI:LOCATION DEFUN C::P1CALL-GLOBAL) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 4181))
C::P1CALL-LOCAL
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::FUN C::ARGS &OPTIONAL (C::RETURN-TYPE T)) ((SI:LOCATION DEFUN C::P1CALL-LOCAL) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 4747))
C::P1CATCH
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::TAG C::BODY) ((SI:LOCATION DEFUN C::P1CATCH) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 5072))
C::P1FMLA-AND
(((:LAMBDA-LIST) C::C1FORM C::ORIG-ASSUMPTIONS BUTLAST LAST) ((SI:LOCATION DEFUN C::P1FMLA-AND) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 6076))
C::P1FMLA-NOT
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::FORM) ((SI:LOCATION DEFUN C::P1FMLA-NOT) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 5909))
C::P1FMLA-OR
(((:LAMBDA-LIST) C::C1FORM C::ORIG-ASSUMPTIONS BUTLAST LAST) ((SI:LOCATION DEFUN C::P1FMLA-OR) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 6548))
C::P1FSET
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::FUN C::FNAME SI:MACRO PPRINT C::C1FORMS) ((SI:LOCATION DEFUN C::P1FSET) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 29504))
C::P1GO
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::TAG-VAR C::RETURN-TYPE) ((SI:LOCATION DEFUN C::P1GO) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 9642))
C::P1IF
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::FMLA C::TRUE-BRANCH C::FALSE-BRANCH) ((SI:LOCATION DEFUN C::P1IF) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 5488))
C::P1LAMBDA
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::LAMBDA-LIST C::DOC C::BODY &REST C::NOT-USED) ((SI:LOCATION DEFUN C::P1LAMBDA) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 7093))
C::P1LET*
(((:LAMBDA-LIST) C::C1FORM C::BASE-ASSUMPTIONS C::VARS C::FORMS C::BODY) ((SI:LOCATION DEFUN C::P1LET*) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 7527))
C::P1LOCALS
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::FUNS C::BODY LABELS) ((SI:LOCATION DEFUN C::P1LOCALS) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 8215))
C::P1MERGE-BRANCHES
(((:LAMBDA-LIST) C::ROOT C::CHAINS) ((SI:LOCATION DEFUN C::P1MERGE-BRANCHES) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 2918))
C::P1MULTIPLE-VALUE-BIND
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::VARS-LIST C::INIT-C1FORM C::BODY) ((SI:LOCATION DEFUN C::P1MULTIPLE-VALUE-BIND) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 8372))
C::P1MULTIPLE-VALUE-SETQ
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::VARS-LIST C::VALUE-C1FORM) ((SI:LOCATION DEFUN C::P1MULTIPLE-VALUE-SETQ) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 8905))
C::P1ORDINARY
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::FORM) ((SI:LOCATION DEFUN C::P1ORDINARY) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 18139))
C::P1PROGN
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::FORMS) ((SI:LOCATION DEFUN C::P1PROGN) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 9118))
C::P1PROPAGATE
(((:LAMBDA-LIST) C::FORM C::ASSUMPTIONS) ((SI:LOCATION DEFUN C::P1PROPAGATE) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 840))
C::P1PROPAGATE-FUNCTION
(((:LAMBDA-LIST) C::FUN C::ASSUMPTIONS) ((SI:LOCATION DEFUN C::P1PROPAGATE-FUNCTION) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 7302))
C::P1PROPAGATE-LIST
(((:LAMBDA-LIST) LIST C::ASSUMPTIONS) ((SI:LOCATION DEFUN C::P1PROPAGATE-LIST) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 2688))
C::P1RETURN-FROM
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::BLK C::RETURN-TYPE C::VALUE C::VARIABLE-OR-NIL) ((SI:LOCATION DEFUN C::P1RETURN-FROM) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 3871))
C::P1SETQ
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::VAR C::C1FORM) ((SI:LOCATION DEFUN C::P1SETQ) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 9201))
C::P1TAGBODY
(((:LAMBDA-LIST) C::C1FORM C::ORIG-ASSUMPTIONS C::TAG-LOC C::BODY) ((SI:LOCATION DEFUN C::P1TAGBODY) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 9886))
C::P1TAGBODY-ONE-PASS
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::TAG-LOC C::BODY) ((SI:LOCATION DEFUN C::P1TAGBODY-ONE-PASS) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 10210))
C::P1THROW
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::CATCH-VALUE C::OUTPUT-VALUE) ((SI:LOCATION DEFUN C::P1THROW) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 5262))
C::P1TRIVIAL
(((:LAMBDA-LIST) C::FORM C::ASSUMPTIONS &REST REST) ((SI:LOCATION DEFUN C::P1TRIVIAL) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 1784))
C::P1UNWIND-PROTECT
(((:LAMBDA-LIST) C::C1FORM C::ASSUMPTIONS C::FORM C::BODY) ((SI:LOCATION DEFUN C::P1UNWIND-PROTECT) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 10862))
C::P1VALUES
(((:LAMBDA-LIST) C::FORM C::ASSUMPTIONS VALUES) ((SI:LOCATION DEFUN C::P1VALUES) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 2360))
C::P1VAR
(((:LAMBDA-LIST) C::FORM C::ASSUMPTIONS C::VAR) ((SI:LOCATION DEFUN C::P1VAR) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 1901))
PACKAGE
(((DOCUMENTATION . TYPE) . "
A package object serves as a name space of symbols.  A package is notated as
#<s package> where S is actually the name of the package.  ECL provides five
built-in packages:
	lisp	 standard symbols of Common Lisp.
	user	 the package that the user uses by default.
	keyword	 keyword symbols.
	system	 system internal symbols.  Has nicknames SYS and SI.
	compiler system internal symbols for the ECL compiler."))
SI:PACKAGE-CHILDREN
(((:LAMBDA-LIST) SI::PACKAGE-SPECIFIER &KEY (SI::RECURSE T)) ((SI:LOCATION DEFUN SI:PACKAGE-CHILDREN) #P"SRC:LSP;PACKLIB.LSP.NEWEST" . 8950))
PACKAGE-ERROR
(((SI:LOCATION DEFCLASS PACKAGE-ERROR) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
PACKAGE-NAME
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (PACKAGE)

Returns the name of PACKAGE as a string.
") ((:LAMBDA-LIST) PACKAGE))
PACKAGE-NICKNAMES
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (PACKAGE)

Returns the nicknames of PACKAGE as a list of strings.
") ((:LAMBDA-LIST) PACKAGE))
SI:PACKAGE-PARENT
(((:LAMBDA-LIST) SI::PACKAGE-SPECIFIER) ((SI:LOCATION DEFUN SI:PACKAGE-PARENT) #P"SRC:LSP;PACKLIB.LSP.NEWEST" . 7917))
PACKAGE-SHADOWING-SYMBOLS
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (PACKAGE)

Returns, as a list, those symbols in PACKAGE that are shadowing symbols in
other packages.
") ((:LAMBDA-LIST) PACKAGE))
PACKAGE-USE-LIST
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (PACKAGE)

Returns, as a list, those packages that PACKAGE uses.
") ((:LAMBDA-LIST) PACKAGE))
PACKAGE-USED-BY-LIST
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (PACKAGE)

Returns, as a list, those packages that use PACKAGE.
") ((:LAMBDA-LIST) PACKAGE))
PACKAGEP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a package object; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
SI::PACKAGES-ITERATOR
(((:LAMBDA-LIST) SI::PACKAGES SI::OPTIONS SI::MAYBE-LIST) ((SI:LOCATION DEFUN SI::PACKAGES-ITERATOR) #P"SRC:LSP;PACKLIB.LSP.NEWEST" . 1164))
PAIRLIS
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (KEYS ITEMS &OPTIONAL (ALIST NIL))

Conses each KEY and the corresponding ITEM, adds them to ALIST, and returns
the result.  KEYS and ITEMS must be of the same length.
") ((:LAMBDA-LIST) SI::KEYS SI::ITEMS &OPTIONAL (SI::ALIST NIL)))
SI::PARSE-ARRAY-TYPE
(((:LAMBDA-LIST) SI::INPUT) ((SI:LOCATION DEFUN SI::PARSE-ARRAY-TYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 33973))
SI::PARSE-CONDITIONAL-DIRECTIVE
(((:LAMBDA-LIST) SI::DIRECTIVES) ((SI:LOCATION DEFUN SI::PARSE-CONDITIONAL-DIRECTIVE) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 66256))
C::PARSE-CVSPECS
(((:LAMBDA-LIST) C::X &AUX (C::CVSPECS NIL)) ((SI:LOCATION DEFUN C::PARSE-CVSPECS) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 20294))
CLOS::PARSE-DEFAULT-INITARGS
(((:LAMBDA-LIST) CLOS::DEFAULT-INITARGS) ((SI:LOCATION DEFUN CLOS::PARSE-DEFAULT-INITARGS) #P"SRC:CLOS;DEFCLASS.LSP.NEWEST" . 957))
CLOS::PARSE-DEFGENERIC
(((:LAMBDA-LIST) CLOS::ARGS) ((SI:LOCATION DEFUN CLOS::PARSE-DEFGENERIC) #P"SRC:CLOS;GENERIC.LSP.NEWEST" . 1197))
CLOS::PARSE-DEFMETHOD
(((:LAMBDA-LIST) CLOS::ARGS) ((SI:LOCATION DEFUN CLOS::PARSE-DEFMETHOD) #P"SRC:CLOS;METHOD.LSP.NEWEST" . 6713))
SI::PARSE-DIRECTIVE
(((:LAMBDA-LIST) STRING SI::START) ((SI:LOCATION DEFUN SI::PARSE-DIRECTIVE) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 11215))
PARSE-ERROR
(((SI:LOCATION DEFCLASS PARSE-ERROR) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
SI::PARSE-FORMAT-JUSTIFICATION
(((:LAMBDA-LIST) SI::DIRECTIVES) ((SI:LOCATION DEFUN SI::PARSE-FORMAT-JUSTIFICATION) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 82212))
SI::PARSE-FORMAT-LOGICAL-BLOCK
(((:LAMBDA-LIST) SI::SEGMENTS SI::COLONP SI::FIRST-SEMI CLOSE SI::PARAMS STRING SI::END) ((SI:LOCATION DEFUN SI::PARSE-FORMAT-LOGICAL-BLOCK) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 86722))
C::PARSE-FUNCTION-PROCLAMATION
(((:LAMBDA-LIST) C::NAME C::ARG-TYPES C::RETURN-TYPE &REST C::PROPERTIES) ((SI:LOCATION DEFUN C::PARSE-FUNCTION-PROCLAMATION) #P"SRC:CMP;PROCLAMATIONS.LSP.NEWEST" . 2011))
CLOS::PARSE-GENERIC-OPTIONS
(((:LAMBDA-LIST) CLOS::OPTIONS CLOS::LAMBDA-LIST) ((SI:LOCATION DEFUN CLOS::PARSE-GENERIC-OPTIONS) #P"SRC:CLOS;GENERIC.LSP.NEWEST" . 1634))
C::PARSE-IGNORE-DECLARATION
(((:LAMBDA-LIST) C::DECL-ARGS C::EXPECTED-REF-NUMBER C::TAIL) ((SI:LOCATION DEFUN C::PARSE-IGNORE-DECLARATION) #P"SRC:CMP;CMPENV-DECLARE.LSP.NEWEST" . 1601))
PARSE-INTEGER
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING &KEY (START 0) (END (LENGTH STRING)) (RADIX 10) (JUNK-ALLOWED NIL))

Parses STRING for an integer and returns it.  As the second value, returns the
index to the character next to the last character that is parsed.  If JUNK-
ALLOWED is non-NIL, ignores white spaces before and after the number
representation in STRING and returns NIL even if STRING is not parsed
successfully.
") ((:LAMBDA-LIST) STRING &KEY (SI::START 0) (SI::END (LENGTH STRING)) (SI::RADIX 10) (SI::JUNK-ALLOWED NIL)))
CLOS::PARSE-LAMBDA-LIST
(((:LAMBDA-LIST) CLOS::LAMBDA-LIST &OPTIONAL CLOS::POST-KEYWORD) ((SI:LOCATION DEFUN CLOS::PARSE-LAMBDA-LIST) #P"SRC:CLOS;GENERIC.LSP.NEWEST" . 3087))
PARSE-NAMESTRING
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING &OPTIONAL HOST DEFAULTS &KEY (START 0) END (JUNK-ALLOWED NIL))

Parses STRING and returns a pathname.  As the second value, returns the index
to the character next to the last character that has been parsed.  STRING is
usually a string object but it may be a symbol, a pathname, or a file stream.
START and END are meaningful only when STRING is a string or a symbol.  They
default to 0 and (length (string FILESPEC)) respectively.  When the parsing is
failed, signals an error (if JUNK-ALLOWED is NIL) or simply returns NIL.  HOST
and DEFAULTS are simply ignored in ECL.
") ((:LAMBDA-LIST) STRING &OPTIONAL SI::HOST SI::DEFAULTS &KEY (SI::START 0) SI::END (SI::JUNK-ALLOWED NIL)))
CLOS::PARSE-SLOT
(((:LAMBDA-LIST) CLOS::SLOT &OPTIONAL (CLOS::FULL NIL)) ((SI:LOCATION DEFUN CLOS::PARSE-SLOT) #P"SRC:CLOS;SLOT.LSP.NEWEST" . 4359))
SI::PARSE-SLOT-DESCRIPTION
(((:LAMBDA-LIST) SI::SLOT-DESCRIPTION SI::OFFSET &OPTIONAL SI::READ-ONLY) ((SI:LOCATION DEFUN SI::PARSE-SLOT-DESCRIPTION) #P"SRC:LSP;DEFSTRUCT.LSP.NEWEST" . 7966))
CLOS::PARSE-SLOTS
(((:LAMBDA-LIST) CLOS::SLOTS) ((SI:LOCATION DEFUN CLOS::PARSE-SLOTS) #P"SRC:CLOS;SLOT.LSP.NEWEST" . 5960))
CLOS::PARSE-SPECIALIZED-LAMBDA-LIST
(((DOCUMENTATION . FUNCTION) . "This function takes a method lambda list and outputs the list of required
arguments, the list of specializers and a new lambda list where the specializer
have disappeared.") ((:LAMBDA-LIST) CLOS::SPECIALIZED-LAMBDA-LIST) ((SI:LOCATION DEFUN CLOS::PARSE-SPECIALIZED-LAMBDA-LIST) #P"SRC:CLOS;METHOD.LSP.NEWEST" . 7611))
PATHNAME
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC)

Returns a pathname specified by FILESPEC.  FILESPEC may be a symbol, a string,
a pathname, or a file stream.
") ((:LAMBDA-LIST) SI::FILESPEC) ((DOCUMENTATION . TYPE) . "
A pathname object identifies an external file or a collection of external
files.  A pathname object consists of six slots, HOST, DEVICE, DIRECTORY,
NAME, and TYPE.  HOST, DEVICE, and VERSION slots are meaningless in ECL,
though they are harmless at all.
A pathname is notated as #\\\"...\", where '...' is actually some information
on the pathname.  This depends on the version of ECL.  Refer to the ECL Report
for details."))
PATHNAME-DEVICE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC)

Returns the device slot of the pathname specified by FILESPEC.  FILESPEC may
be a symbol, a string, a pathname, or a file stream.
") ((:LAMBDA-LIST) SI::FILESPEC))
PATHNAME-DIRECTORY
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC)

Returns the directory slot of the pathname specified by FILESPEC.  FILESPEC
may be a symbol, a string, a pathname, or a file stream.
") ((:LAMBDA-LIST) SI::FILESPEC))
PATHNAME-HOST
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC)

Returns the host slot of the pathname specified by FILESPEC.  FILESPEC may be
a symbol, a string, a pathname, or a file stream.
") ((:LAMBDA-LIST) SI::FILESPEC))
PATHNAME-NAME
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC)

Returns the name slot of the pathname specified by FILESPEC.  FILESPEC may be
a symbol, a string, a pathname, or a file stream.
") ((:LAMBDA-LIST) SI::FILESPEC))
PATHNAME-TYPE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC)

Returns the type slot of the pathname specified by FILESPEC.  FILESPEC may be
a symbol, a string, a pathname, or a file stream.
") ((:LAMBDA-LIST) SI::FILESPEC))
PATHNAME-VERSION
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC)

Returns the version slot of the pathname specified by FILESPEC.  FILESPEC may
be a symbol, a string, a pathname, or a file stream.
") ((:LAMBDA-LIST) SI::FILESPEC))
PATHNAMEP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a pathname object; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
PEEK-CHAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&OPTIONAL (CHAR-SPEC NIL) (STREAM *STANDARD-INPUT*) (EOF-ERROR-P T) (EOF-VALUE NIL) (RECURSIVE-P NIL))

Reads characters from STREAM until the specified character is read.  Returns
the last character but leaves it in STREAM.  CHAR-SPEC may be a character
object, T (specifies non-whitespace characters), or NIL (specifies all
characters).
") ((:LAMBDA-LIST) &OPTIONAL (SI::CHAR-SPEC NIL) (STREAM *STANDARD-INPUT*) (SI::EOF-ERROR-P T) (SI::EOF-VALUE NIL) (SI::RECURSIVE-P NIL)))
PHASE
(((DOCUMENTATION . FUNCTION) . "Args: (number)
Returns the angle part (in radians) of the polar representation of NUMBER.
Returns zero for non-complex numbers.") ((:LAMBDA-LIST) SI::X) ((SI:LOCATION DEFUN PHASE) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 4329))
PI
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The float that is approximately equal to the ratio of the circumference of the
circle to the diameter.
"))
PLUSP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER)

Returns T if NUMBER is positive; NIL otherwise.
") ((:LAMBDA-LIST) NUMBER))
SI:POINTER
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (OBJECT)

ECL specific.
Returns the address of the OBJECT as a fixnum.
") ((:LAMBDA-LIST) SI::OBJECT))
FFI:POINTER-ADDRESS
(((:LAMBDA-LIST) FFI::PTR) ((SI:LOCATION DEFUN FFI:POINTER-ADDRESS) #P"SRC:LSP;FFI.LSP.NEWEST" . 11191))
C::POLICY-ARRAY-BOUNDS-CHECK
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-ARRAY-BOUNDS-CHECK) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-ASSUME-NO-ERRORS
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-ASSUME-NO-ERRORS) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-ASSUME-RIGHT-TYPE
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-ASSUME-RIGHT-TYPE) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-ASSUME-TYPES-DONT-CHANGE
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-ASSUME-TYPES-DONT-CHANGE) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-CHECK-ARGUMENTS-TYPE
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-CHECK-ARGUMENTS-TYPE) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-CHECK-NARGS
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-CHECK-NARGS) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-CHECK-STACK-OVERFLOW
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-CHECK-STACK-OVERFLOW) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-DEBUG-IHS-FRAME
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-DEBUG-IHS-FRAME) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-DEBUG-VARIABLE-BINDINGS
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-DEBUG-VARIABLE-BINDINGS) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-DECLARATION-NAME
(((:LAMBDA-LIST) C::BASE) ((SI:LOCATION DEFUN C::POLICY-DECLARATION-NAME) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 4555))
C::POLICY-DECLARATION-NAME-P
(((:LAMBDA-LIST) C::NAME) ((SI:LOCATION DEFUN C::POLICY-DECLARATION-NAME-P) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 3395))
C::POLICY-EVALUATE-FORMS
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-EVALUATE-FORMS) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-FUNCTION-NAME
(((:LAMBDA-LIST) C::BASE) ((SI:LOCATION DEFUN C::POLICY-FUNCTION-NAME) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 4555))
C::POLICY-GLOBAL-FUNCTION-CHECKING
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-GLOBAL-FUNCTION-CHECKING) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-GLOBAL-VAR-CHECKING
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-GLOBAL-VAR-CHECKING) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-INLINE-ACCESSORS
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-INLINE-ACCESSORS) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-INLINE-SEQUENCE-FUNCTIONS
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-INLINE-SEQUENCE-FUNCTIONS) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-INLINE-SLOT-ACCESS
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-INLINE-SLOT-ACCESS) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-INLINE-TYPE-CHECKS
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-INLINE-TYPE-CHECKS) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-NO-CHECK-ARGUMENTS-TYPE
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-NO-CHECK-ARGUMENTS-TYPE) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-OPEN-CODE-AREF/ASET
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-OPEN-CODE-AREF/ASET) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-TO-DEBUG-LEVEL
(((:LAMBDA-LIST) C::POLICY) ((SI:LOCATION DEFUN C::POLICY-TO-DEBUG-LEVEL) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 1275))
C::POLICY-TO-SAFETY-LEVEL
(((:LAMBDA-LIST) C::POLICY) ((SI:LOCATION DEFUN C::POLICY-TO-SAFETY-LEVEL) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 1275))
C::POLICY-TO-SPACE-LEVEL
(((:LAMBDA-LIST) C::POLICY) ((SI:LOCATION DEFUN C::POLICY-TO-SPACE-LEVEL) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 1275))
C::POLICY-TO-SPEED-LEVEL
(((:LAMBDA-LIST) C::POLICY) ((SI:LOCATION DEFUN C::POLICY-TO-SPEED-LEVEL) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 1275))
C::POLICY-TYPE-ASSERTIONS
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-TYPE-ASSERTIONS) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
C::POLICY-USE-DIRECT-C-CALL
(((:LAMBDA-LIST) &OPTIONAL (C::ENV C::*CMP-ENV*)) ((SI:LOCATION DEFUN C::POLICY-USE-DIRECT-C-CALL) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 9533))
POP
(((DOCUMENTATION . FUNCTION) . "Syntax: (pop place)
Gets the cdr of the value stored in PLACE and makes it the new value of PLACE.
Returns the car of the old value in PLACE.") ((:LAMBDA-LIST) &ENVIRONMENT SI::ENV SI::PLACE) ((SI:LOCATION DEFMACRO POP) #P"SRC:LSP;SETF.LSP.NEWEST" . 25667))
C::POP-DEBUG-LEXICAL-ENV
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::POP-DEBUG-LEXICAL-ENV) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 23451))
POSITION
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ITEM SEQUENCE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT (START 0) (END (LENGTH SEQUENCE)) (FROM-END NIL))

Returns the index to the first element in SEQUENCE that is equal to ITEM in
the sense of TEST.  Returns NIL if no such element exists.
") ((:LAMBDA-LIST) SI::ITEM SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::TEST '#'EQL) SI::TEST-NOT (SI::START 0) (SI::END (LENGTH SEQUENCE)) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN POSITION) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 18303))
POSITION-IF
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (FROM-END NIL))

Returns the index to the first element in SEQUENCE that satisfies TEST.
Returns NIL if no such element exists.
") ((:LAMBDA-LIST) SI::TEST SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::START 0) (SI::END (LENGTH SEQUENCE)) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN POSITION-IF) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 18788))
POSITION-IF-NOT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (FROM-END NIL))

Returns the index to the first element in SEQUENCE that does not satisfy TEST.
Returns NIL if no such element exists.
") ((:LAMBDA-LIST) SI::TEST SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::START 0) (SI::END (LENGTH SEQUENCE)) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN POSITION-IF-NOT) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 19017))
SI::POSN-COLUMN
(((:LAMBDA-LIST) SI::POSN STREAM) ((SI:LOCATION DEFUN SI::POSN-COLUMN) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 5071))
SI::POSN-INDEX
(((:LAMBDA-LIST) SI::POSN STREAM) ((SI:LOCATION DEFUN SI::POSN-INDEX) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 4914))
PPRINT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (OBJECT &OPTIONAL (STREAM *STANDARD-OUTPUT*))

Pretty-prints OBJECT.  Returns no values.  Equivalent to
	(PROGN (WRITE OBJECT :STREAM STREAM :PRETTY T :ESCAPE T)
	       (VALUES))
The SI::PRETTY-PRINT-FORMAT property N (which must be a non-negative integer)
of a symbol SYMBOL controls the pretty-printing of form
	(SYMBOL f1 ... fN fN+1 ... fM)
in such a way that the subforms fN+1, ..., fM are regarded as the 'body' of
the entire form.  For instance, the property value of 2 is initially given to
the symbol DO.
") ((:LAMBDA-LIST) SI::OBJECT &OPTIONAL (STREAM *STANDARD-OUTPUT*)))
SI::PPRINT-ARRAY
(((:LAMBDA-LIST) STREAM ARRAY) ((SI:LOCATION DEFUN SI::PPRINT-ARRAY) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 43016))
SI::PPRINT-ARRAY-CONTENTS
(((:LAMBDA-LIST) STREAM ARRAY) ((SI:LOCATION DEFUN SI::PPRINT-ARRAY-CONTENTS) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 43636))
SI::PPRINT-BLOCK
(((:LAMBDA-LIST) STREAM LIST &REST SI::NOISE) ((SI:LOCATION DEFUN SI::PPRINT-BLOCK) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 46902))
SI::PPRINT-CASE
(((:LAMBDA-LIST) STREAM LIST &REST SI::NOISE) ((SI:LOCATION DEFUN SI::PPRINT-CASE) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 49698))
SI::PPRINT-DEFUN
(((:LAMBDA-LIST) STREAM LIST &REST SI::NOISE) ((SI:LOCATION DEFUN SI::PPRINT-DEFUN) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 49894))
SI::PPRINT-DESTRUCTURING-BIND
(((:LAMBDA-LIST) STREAM LIST &REST SI::NOISE) ((SI:LOCATION DEFUN SI::PPRINT-DESTRUCTURING-BIND) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 50085))
PPRINT-DISPATCH
(((:LAMBDA-LIST) SI::OBJECT &OPTIONAL (SI::TABLE *PRINT-PPRINT-DISPATCH*)) ((SI:LOCATION DEFUN PPRINT-DISPATCH) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 40540))
SI::PPRINT-DISPATCH-ENTRY
(((SI:LOCATION DEFCLASS SI::PPRINT-DISPATCH-ENTRY) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 37751))
SI::PPRINT-DISPATCH-TABLE
(((SI:LOCATION DEFCLASS SI::PPRINT-DISPATCH-TABLE) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 38530))
SI::PPRINT-DO
(((:LAMBDA-LIST) STREAM LIST &REST SI::NOISE) ((SI:LOCATION DEFUN SI::PPRINT-DO) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 50286))
SI::PPRINT-DOLIST
(((:LAMBDA-LIST) STREAM LIST &REST SI::NOISE) ((SI:LOCATION DEFUN SI::PPRINT-DOLIST) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 50888))
PPRINT-EXIT-IF-LIST-EXHAUSTED
(((DOCUMENTATION . FUNCTION) . "Cause the closest enclosing use of PPRINT-LOGICAL-BLOCK to return
   if it's list argument is exhausted.  Can only be used inside
   PPRINT-LOGICAL-BLOCK, and only when the LIST argument to
   PPRINT-LOGICAL-BLOCK is supplied.") ((:LAMBDA-LIST)) ((SI:LOCATION DEFMACRO PPRINT-EXIT-IF-LIST-EXHAUSTED) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 30662))
PPRINT-FILL
(((DOCUMENTATION . FUNCTION) . "Output LIST to STREAM putting :FILL conditional newlines between each
   element.  If COLON? is NIL (defaults to T), then no parens are printed
   around the output.  ATSIGN? is ignored (but allowed so that PPRINT-FILL
   can be used with the ~/.../ format directive.") ((:LAMBDA-LIST) STREAM LIST &OPTIONAL (SI::COLON? T) SI::ATSIGN?) ((SI:LOCATION DEFUN PPRINT-FILL) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 35141))
SI::PPRINT-FLET
(((:LAMBDA-LIST) STREAM LIST &REST SI::NOISE) ((SI:LOCATION DEFUN SI::PPRINT-FLET) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 47050))
SI::PPRINT-FUNCTION-CALL
(((:LAMBDA-LIST) STREAM LIST &REST SI::NOISE) ((SI:LOCATION DEFUN SI::PPRINT-FUNCTION-CALL) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 51935))
PPRINT-INDENT
(((DOCUMENTATION . FUNCTION) . "Specify the indentation to use in the current logical block if STREAM
   (which defaults to *STANDARD-OUTPUT*) is it is a pretty-printing stream
   and do nothing if not.  (See PPRINT-LOGICAL-BLOCK.)  N is the indention
   to use (in ems, the width of an ``m'') and RELATIVE-TO can be either:
     :BLOCK - Indent relative to the column the current logical block
        started on.
     :CURRENT - Indent relative to the current column.
   The new indention value does not take effect until the following line
   break.") ((:LAMBDA-LIST) SI::RELATIVE-TO SI::N &OPTIONAL STREAM) ((SI:LOCATION DEFUN PPRINT-INDENT) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 33031))
SI::PPRINT-LAMBDA
(((:LAMBDA-LIST) STREAM LIST &REST SI::NOISE) ((SI:LOCATION DEFUN SI::PPRINT-LAMBDA) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 46722))
SI::PPRINT-LAMBDA-LIST
(((:LAMBDA-LIST) STREAM SI::LAMBDA-LIST &REST SI::NOISE) ((SI:LOCATION DEFUN SI::PPRINT-LAMBDA-LIST) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 45018))
SI::PPRINT-LET
(((:LAMBDA-LIST) STREAM LIST &REST SI::NOISE) ((SI:LOCATION DEFUN SI::PPRINT-LET) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 47289))
PPRINT-LINEAR
(((DOCUMENTATION . FUNCTION) . "Output LIST to STREAM putting :LINEAR conditional newlines between each
   element.  If COLON? is NIL (defaults to T), then no parens are printed
   around the output.  ATSIGN? is ignored (but allowed so that PPRINT-LINEAR
   can be used with the ~/.../ format directive.") ((:LAMBDA-LIST) STREAM LIST &OPTIONAL (SI::COLON? T) SI::ATSIGN?) ((SI:LOCATION DEFUN PPRINT-LINEAR) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 35916))
PPRINT-LOGICAL-BLOCK
(((DOCUMENTATION . FUNCTION) . "Group some output into a logical block.  STREAM-SYMBOL should be either a
   stream, T (for *TERMINAL-IO*), or NIL (for *STANDARD-OUTPUT*).  The printer
   control variable *PRINT-LEVEL* is automatically handled.") ((:LAMBDA-LIST) (SI::STREAM-SYMBOL SI::OBJECT &KEY (SI::PREFIX "" SI::PREFIX-P) (SI::PER-LINE-PREFIX "" SI::PER-LINE-PREFIX-P) (SI::SUFFIX "" SI::SUFFIX-P)) &BODY SI::BODY) ((SI:LOCATION DEFMACRO PPRINT-LOGICAL-BLOCK) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 29109))
SI::PPRINT-LOGICAL-BLOCK-HELPER
(((:LAMBDA-LIST) FUNCTION SI::OBJECT STREAM SI::PREFIX SI::PER-LINE-PREFIX-P SI::SUFFIX) ((SI:LOCATION DEFUN SI::PPRINT-LOGICAL-BLOCK-HELPER) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 28560))
SI::PPRINT-MULTI-DIM-ARRAY
(((:LAMBDA-LIST) STREAM ARRAY) ((SI:LOCATION DEFUN SI::PPRINT-MULTI-DIM-ARRAY) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 44414))
PPRINT-NEWLINE
(((DOCUMENTATION . FUNCTION) . "Output a conditional newline to STREAM (which defaults to
   *STANDARD-OUTPUT*) if it is a pretty-printing stream, and do
   nothing if not.  KIND can be one of:
     :LINEAR - A line break is inserted if and only if the immediatly
        containing section cannot be printed on one line.
     :MISER - Same as LINEAR, but only if ``miser-style'' is in effect.
        (See *PRINT-MISER-WIDTH*.)
     :FILL - A line break is inserted if and only if either:
       (a) the following section cannot be printed on the end of the
           current line,
       (b) the preceding section was not printed on a single line, or
       (c) the immediately containing section cannot be printed on one
           line and miser-style is in effect.
     :MANDATORY - A line break is always inserted.
   When a line break is inserted by any type of conditional newline, any
   blanks that immediately precede the conditional newline are ommitted
   from the output and indentation is introduced at the beginning of the
   next line.  (See PPRINT-INDENT.)") ((:LAMBDA-LIST) SI::KIND &OPTIONAL STREAM) ((SI:LOCATION DEFUN PPRINT-NEWLINE) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 31545))
PPRINT-POP
(((DOCUMENTATION . FUNCTION) . "Return the next element from LIST argument to the closest enclosing
   use of PPRINT-LOGICAL-BLOCK, automatically handling *PRINT-LENGTH*
   and *PRINT-CIRCLE*.  Can only be used inside PPRINT-LOGICAL-BLOCK.
   If the LIST argument to PPRINT-LOGICAL-BLOCK was NIL, then nothing
   is poped, but the *PRINT-LENGTH* testing still happens.") ((:LAMBDA-LIST)) ((SI:LOCATION DEFMACRO PPRINT-POP) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 31070))
SI::PPRINT-POP-HELPER
(((:LAMBDA-LIST) SI::OBJECT COUNT STREAM &AUX SI::CODE) ((SI:LOCATION DEFUN SI::PPRINT-POP-HELPER) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 24533))
SI::PPRINT-PROG
(((:LAMBDA-LIST) STREAM LIST &REST SI::NOISE) ((SI:LOCATION DEFUN SI::PPRINT-PROG) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 51549))
SI::PPRINT-PROGN
(((:LAMBDA-LIST) STREAM LIST &REST SI::NOISE) ((SI:LOCATION DEFUN SI::PPRINT-PROGN) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 47480))
SI::PPRINT-PROGV
(((:LAMBDA-LIST) STREAM LIST &REST SI::NOISE) ((SI:LOCATION DEFUN SI::PPRINT-PROGV) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 47614))
SI::PPRINT-QUOTE
(((:LAMBDA-LIST) STREAM LIST &REST SI::NOISE) ((SI:LOCATION DEFUN SI::PPRINT-QUOTE) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 47774))
SI::PPRINT-RAW-ARRAY
(((:LAMBDA-LIST) STREAM ARRAY) ((SI:LOCATION DEFUN SI::PPRINT-RAW-ARRAY) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 44583))
SI::PPRINT-SETQ
(((:LAMBDA-LIST) STREAM LIST &REST SI::NOISE) ((SI:LOCATION DEFUN SI::PPRINT-SETQ) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 48158))
PPRINT-TAB
(((DOCUMENTATION . FUNCTION) . "If STREAM (which defaults to *STANDARD-OUTPUT*) is a pretty-printing
   stream, perform tabbing based on KIND, otherwise do nothing.  KIND can
   be one of:
     :LINE - Tab to column COLNUM.  If already past COLNUM tab to the next
       multiple of COLINC.
     :SECTION - Same as :LINE, but count from the start of the current
       section, not the start of the line.
     :LINE-RELATIVE - Output COLNUM spaces, then tab to the next multiple of
       COLINC.
     :SECTION-RELATIVE - Same as :LINE-RELATIVE, but count from the start
       of the current section, not the start of the line.") ((:LAMBDA-LIST) SI::KIND SI::COLNUM SI::COLINC &OPTIONAL STREAM) ((SI:LOCATION DEFUN PPRINT-TAB) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 34027))
PPRINT-TABULAR
(((DOCUMENTATION . FUNCTION) . "Output LIST to STREAM tabbing to the next column that is an even multiple
   of TABSIZE (which defaults to 16) between each element.  :FILL style
   conditional newlines are also output between each element.  If COLON? is
   NIL (defaults to T), then no parens are printed around the output.
   ATSIGN? is ignored (but allowed so that PPRINT-TABULAR can be used with
   the ~/.../ format directive.") ((:LAMBDA-LIST) STREAM LIST &OPTIONAL (SI::COLON? T) SI::ATSIGN? (SI::TABSIZE 16)) ((SI:LOCATION DEFUN PPRINT-TABULAR) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 36699))
SI::PPRINT-TAGBODY
(((:LAMBDA-LIST) STREAM LIST &REST SI::NOISE) ((SI:LOCATION DEFUN SI::PPRINT-TAGBODY) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 49450))
SI::PPRINT-TAGBODY-GUTS
(((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFMACRO SI::PPRINT-TAGBODY-GUTS) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 49111))
SI::PPRINT-TYPECASE
(((:LAMBDA-LIST) STREAM LIST &REST SI::NOISE) ((SI:LOCATION DEFUN SI::PPRINT-TYPECASE) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 51365))
SI::PPRINT-VECTOR
(((:LAMBDA-LIST) STREAM VECTOR) ((SI:LOCATION DEFUN SI::PPRINT-VECTOR) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 43352))
C::PRECOMPUTE-APPLICABLE-METHODS
(((:LAMBDA-LIST) C::METHODS C::C-ARGS) ((SI:LOCATION DEFUN C::PRECOMPUTE-APPLICABLE-METHODS) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 1127))
CLOS::PRECOMPUTE-VALID-INITARG-KEYWORDS
(((:LAMBDA-LIST) CLASS) ((SI:LOCATION DEFUN CLOS::PRECOMPUTE-VALID-INITARG-KEYWORDS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 6983))
SI::PRETTY-OUT
(((:LAMBDA-LIST) STREAM CHAR) ((SI:LOCATION DEFUN SI::PRETTY-OUT) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 5606))
SI::PRETTY-SOUT
(((:LAMBDA-LIST) STREAM STRING SI::START SI::END) ((SI:LOCATION DEFUN SI::PRETTY-SOUT) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 6045))
SI::PRETTY-STREAM
(((SI:LOCATION DEFCLASS SI::PRETTY-STREAM) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 1027))
SI::PRETTY-STREAM-P
(((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFUN SI::PRETTY-STREAM-P) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 4256))
PRIN1
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (OBJECT &OPTIONAL (STREAM *STANDARD-OUTPUT*))

Prints OBJECT in the way that the output can be reread later if possible.
Returns OBJECT.  Equivalent to (WRITE OBJECT :STREAM STREAM :ESCAPE T).
") ((:LAMBDA-LIST) SI::OBJECT &OPTIONAL (STREAM *STANDARD-OUTPUT*)))
PRIN1-TO-STRING
(((DOCUMENTATION . FUNCTION) . "Args: (object)
PRIN1s OBJECT to a new string and returns the result.  Equivalent to
(WRITE-TO-STRING OBJECT :ESCAPE T).") ((:LAMBDA-LIST) SI::OBJECT &AUX (STREAM (MAKE-STRING-OUTPUT-STREAM))) ((SI:LOCATION DEFUN PRIN1-TO-STRING) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 4253))
PRINC
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (OBJECT &OPTIONAL (STREAM *STANDARD-OUTPUT*))

Prints OBJECT without escape characters.  Returns OBJECT.  Equivalent to
(WRITE OBJECT :STREAM STREAM :ESCAPE NIL).
") ((:LAMBDA-LIST) SI::OBJECT &OPTIONAL (STREAM *STANDARD-OUTPUT*)))
C::PRINC-H
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::PRINC-H) #P"SRC:CMP;CMPC-WT.LSP.NEWEST" . 1165))
PRINC-TO-STRING
(((DOCUMENTATION . FUNCTION) . "Args: (object)
PRINCs OBJECT to a new string and returns the result.  Equivalent to
(WRITE-TO-STRING OBJECT :ESCAPE NIL).") ((:LAMBDA-LIST) SI::OBJECT &AUX (STREAM (MAKE-STRING-OUTPUT-STREAM))) ((SI:LOCATION DEFUN PRINC-TO-STRING) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 4539))
PRINT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (OBJECT &OPTIONAL (STREAM *STANDARD-OUTPUT*))

Outputs a newline character, and then PRIN1s OBJECT.  Returns OBJECT.
Equivalent to
	(PROGN (TERPRI STREAM)
	       (WRITE OBJECT :STREAM STREAM :ESCAPE T))
") ((:LAMBDA-LIST) SI::OBJECT &OPTIONAL (STREAM *STANDARD-OUTPUT*)))
C::PRINT-C1FORM
(((:LAMBDA-LIST) C::FORM STREAM) ((SI:LOCATION DEFUN C::PRINT-C1FORM) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 3777))
C::PRINT-C1FORMS
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::PRINT-C1FORMS) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 7318))
C::PRINT-COMPILER-INFO
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::PRINT-COMPILER-INFO) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 33913))
C::PRINT-COMPILER-MESSAGE
(((:LAMBDA-LIST) C::C STREAM) ((SI:LOCATION DEFUN C::PRINT-COMPILER-MESSAGE) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 4833))
C::PRINT-CURRENT-FORM
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::PRINT-CURRENT-FORM) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 10109))
SI::PRINT-DOC
(((:LAMBDA-LIST) SYMBOL &OPTIONAL (SI::CALLED-FROM-APROPOS-DOC-P NIL) &AUX (SI::F NIL) SI::X) ((SI:LOCATION DEFUN SI::PRINT-DOC) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 16832))
C::PRINT-EMITTING
(((:LAMBDA-LIST) C::F) ((SI:LOCATION DEFUN C::PRINT-EMITTING) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 10332))
SI::PRINT-FRS
(((:LAMBDA-LIST) SI::I) ((SI:LOCATION DEFUN SI::PRINT-FRS) #P"SRC:LSP;TOP.LSP.NEWEST" . 39540))
C::PRINT-FUNCTION
(((:LAMBDA-LIST) C::X) ((SI:LOCATION DEFUN C::PRINT-FUNCTION) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 10842))
PRINT-NOT-READABLE
(((SI:LOCATION DEFCLASS PRINT-NOT-READABLE) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
PRINT-OBJECT
(((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::X C:COMPILER-UNDEFINED-VARIABLE) STREAM) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 4461) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::X C:COMPILER-MESSAGE) STREAM) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 2899) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::OBJ C::C1FORM) STREAM) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 9763) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::OBJ C::VAR) STREAM) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 1460) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::OBJ C::REF) STREAM) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 937) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::X SI:INTERACTIVE-INTERRUPT) STREAM) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::X SI:FORMAT-ERROR) STREAM) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::X PRINT-NOT-READABLE) STREAM) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::X SI::ABORT-FAILURE) STREAM) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::X UNDEFINED-FUNCTION) STREAM) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::X UNBOUND-SLOT) STREAM) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::X UNBOUND-VARIABLE) STREAM) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::X FILE-ERROR) STREAM) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::X END-OF-FILE) STREAM) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::X SI::CASE-FAILURE) STREAM) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::X TYPE-ERROR) STREAM) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::X SI:UNIX-SIGNAL-RECEIVED) STREAM) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::X SI:STORAGE-EXHAUSTED) STREAM) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::X SI:STACK-OVERFLOW) STREAM) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::X SI:SEGMENTATION-VIOLATION) STREAM) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::X SIMPLE-CONDITION) STREAM) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::OBJ RESTART) STREAM) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 2088) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::OBJ SI::PPRINT-DISPATCH-TABLE) STREAM) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 38530) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::OBJ SI::PPRINT-DISPATCH-ENTRY) STREAM) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 37751) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (SI::PRETTY-STREAM SI::PRETTY-STREAM) STREAM) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 4463) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (CLOS::M STANDARD-METHOD) STREAM) #P"SRC:CLOS;PRINT.LSP.NEWEST" . 5464) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (CLOS::GF STANDARD-GENERIC-FUNCTION) STREAM) #P"SRC:CLOS;PRINT.LSP.NEWEST" . 5299) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (CLASS CLASS) STREAM) #P"SRC:CLOS;PRINT.LSP.NEWEST" . 5110) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (CLOS::INSTANCE T) STREAM) #P"SRC:CLOS;PRINT.LSP.NEWEST" . 4938) ((SI:LOCATION DEFMETHOD PRINT-OBJECT (CLOS::OBJ STRUCTURE-OBJECT) STREAM) #P"SRC:CLOS;BUILTIN.LSP.NEWEST" . 5724) ((:LAMBDA-LIST) CLOS::OBJECT STREAM) ((SI:LOCATION DEFUN PRINT-OBJECT) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 15653))
C::PRINT-REF
(((:LAMBDA-LIST) C::REF-OBJECT STREAM) ((SI:LOCATION DEFUN C::PRINT-REF) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 7594))
SI::PRINT-SYMBOL-APROPOS
(((:LAMBDA-LIST) SYMBOL) ((SI:LOCATION DEFUN SI::PRINT-SYMBOL-APROPOS) #P"SRC:LSP;PACKLIB.LSP.NEWEST" . 5223))
PRINT-UNREADABLE-OBJECT
(((:LAMBDA-LIST) (SI::OBJECT STREAM &KEY TYPE IDENTITY) &BODY SI::BODY) ((SI:LOCATION DEFMACRO PRINT-UNREADABLE-OBJECT) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 11156))
C::PRINT-VAR
(((:LAMBDA-LIST) C::VAR-OBJECT STREAM) ((SI:LOCATION DEFUN C::PRINT-VAR) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 7791))
PROBE-FILE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC)

Returns the full pathname of the specified file if it exists.  Returns NIL
otherwise.  FILESPEC may be a symbol, a string, a pathname, or a file stream.
") ((:LAMBDA-LIST) SI::FILESPEC))
SI::PROCESS-BOA-LAMBDA-LIST
(((:LAMBDA-LIST) SI::SLOT-NAMES SI::SLOT-DESCRIPTIONS SI::BOA-LIST SI::ASSERTIONS) ((SI:LOCATION DEFUN SI::PROCESS-BOA-LAMBDA-LIST) #P"SRC:LSP;DEFSTRUCT.LSP.NEWEST" . 2226))
SI:PROCESS-COMMAND-ARGS
(((DOCUMENTATION . FUNCTION) . "PROCESS-COMMAND-ARGS takes a list of arguments and processes according
to a set of rules. These rules are of the format

	(option-name nargs template [ :stop | :noloadrc | :loadrc ] )

OPTION-NAME is a string containing the command line option. NARGS is
the number of arguments that this option takes. TEMPLATE is a lisp
form where numbers from 0 to NARGS will be substituted by the
arguments, and which will be evaluated afterwards. The flags :STOP,
:NOLOADRC and :LOADRC denote whether to stop processing the command
line after this option and whether the initialization file will be
loaded before evaluating all forms.

An excerpt of the rules used by ECL:
'((\"--help\" 0 #0=(progn (princ *help-message* *standard-output*) (quit))
               :noloadrc)
  (\"-?\" 0 #0# :noloadrc)
  (\"-h\" 0 #0# :noloadrc)
  (\"-norc\" 0 nil :noloadrc)
  (\"--\" 0 nil :stop)
  (\"-eval\" 1 (eval (read-from-string 1))))
") ((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI:PROCESS-COMMAND-ARGS) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/build/bare.lsp" . 2640))
C::PROCESS-DECLAIM-ARGS
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::PROCESS-DECLAIM-ARGS) #P"SRC:CMP;CMPENV-DECLAIM.LSP.NEWEST" . 840))
C::PROCESS-LET-BINDINGS
(((:LAMBDA-LIST) C::LET/LET* C::BINDINGS C::BODY) ((SI:LOCATION DEFUN C::PROCESS-LET-BINDINGS) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 2568))
PROCLAIM
(((DOCUMENTATION . FUNCTION) . "Args: (decl-spec)
Gives a global declaration.  See DECLARE for possible DECL-SPECs.") ((:LAMBDA-LIST) C::DECL &AUX C::DECL-NAME) ((SI:LOCATION DEFUN PROCLAIM) #P"SRC:CMP;CMPENV-PROCLAIM.LSP.NEWEST" . 957))
C::PROCLAIM-FUNCTION
(((:LAMBDA-LIST) C::FNAME C::DECL) ((SI:LOCATION DEFUN C::PROCLAIM-FUNCTION) #P"SRC:CMP;CMPENV-FUN.LSP.NEWEST" . 1435))
C::PROCLAIM-VAR
(((:LAMBDA-LIST) TYPE C::VL) ((SI:LOCATION DEFUN C::PROCLAIM-VAR) #P"SRC:CMP;CMPENV-PROCLAIM.LSP.NEWEST" . 4832))
FFI::PRODUCE-FUNCTION-CALL
(((:LAMBDA-LIST) FFI::C-NAME FFI::NARGS) ((SI:LOCATION DEFUN FFI::PRODUCE-FUNCTION-CALL) #P"SRC:LSP;FFI.LSP.NEWEST" . 17459))
SI::PRODUCE-INIT-CODE
(((:LAMBDA-LIST) SI::OPTION-LIST SI::RULES) ((SI:LOCATION DEFUN SI::PRODUCE-INIT-CODE) #P"SRC:LSP;CMDLINE.LSP.NEWEST" . 4305))
C::PRODUCE-INLINE-LOC
(((:LAMBDA-LIST) C::INLINED-ARGUMENTS C::ARG-TYPES C::OUTPUT-REP-TYPE C::C-EXPRESSION C::SIDE-EFFECTS C::ONE-LINER) ((SI:LOCATION DEFUN C::PRODUCE-INLINE-LOC) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 17666))
PROG
(((DOCUMENTATION . FUNCTION) . "Syntax: (prog ({var | (var [init])}*) {decl}* {tag | statement}*)
Establishes a NIL block, binds each VAR to the value of INIT (which defaults
to NIL) in parallel, and executes STATEMENTs.  Returns NIL.") ((:LAMBDA-LIST) SI::VL &REST SI::BODY &AUX (SI::DECL NIL)) ((SI:LOCATION DEFMACRO PROG) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 7159))
PROG*
(((DOCUMENTATION . FUNCTION) . "Syntax: (prog* ({var | (var [init])}*) {decl}* {tag | statement}*)
Establishes a NIL block, binds each VAR to the value of INIT (which defaults
to NIL) sequentially, and executes STATEMENTs.  Returns NIL.") ((:LAMBDA-LIST) SI::VL &REST SI::BODY &AUX (SI::DECL NIL)) ((SI:LOCATION DEFMACRO PROG*) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 7531))
PROG1
(((DOCUMENTATION . FUNCTION) . "Syntax: (prog1 first-form {form}*)
Evaluates FIRST-FORM and FORMs in order.  Returns the value of FIRST-FORM.") ((:LAMBDA-LIST) FIRST &REST SI::BODY &AUX (SI::SYM (GENSYM))) ((SI:LOCATION DEFMACRO PROG1) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 7923))
PROG2
(((DOCUMENTATION . FUNCTION) . "Syntax: (prog2 first-form second-form {forms}*)
Evaluates FIRST-FORM, SECOND-FORM, and FORMs in order.  Returns the value of
SECOND-FORM.") ((:LAMBDA-LIST) FIRST SECOND &REST SI::BODY &AUX (SI::SYM (GENSYM))) ((SI:LOCATION DEFMACRO PROG2) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 8200))
PROGN
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (progn {form}*)

Evaluates FORMs in order, and returns all values of the last FORM.  Returns
NIL if no FORM is given.
") ((:LAMBDA-LIST) . "(progn {form}*)"))
PROGRAM-ERROR
(((SI:LOCATION DEFCLASS PROGRAM-ERROR) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
PROGV
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (progv symbols-form values-form {form}*)

Evaluates SYMBOLS-FORM and VALUES-FORM.  The value of SYMBOLS-FORM must be a
list of symbols (S1 ... Sn) and the value of VALUES-FORM must be a list
(V1 ... Vm).  Binds each Si to Vi or to NIL if i > m.  Then evaluates FORMs
and returns all values of the last FORM.  Returns NIL if no FORM is given.
") ((:LAMBDA-LIST) . "(progv symbols-form values-form {form}*)"))
C::PROP-MESSAGE
(((:LAMBDA-LIST) STRING &REST C::ARGS) ((SI:LOCATION DEFMACRO C::PROP-MESSAGE) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 616))
C::PROPAGATE-TYPES
(((:LAMBDA-LIST) C::FNAME C::FORMS) ((SI:LOCATION DEFUN C::PROPAGATE-TYPES) #P"SRC:CMP;CMPTYPE-PROP.LSP.NEWEST" . 2528))
C::PROPER-LIST-P
(((:LAMBDA-LIST) C::X &OPTIONAL C::TEST) ((SI:LOCATION DEFUN C::PROPER-LIST-P) #P"SRC:CMP;CMPENV-DECLARE.LSP.NEWEST" . 764))
PROVIDE
(((DOCUMENTATION . FUNCTION) . "Adds a new module name to *MODULES* indicating that it has been loaded.
Module-name is a string designator") ((:LAMBDA-LIST) SI::MODULE-NAME) ((SI:LOCATION DEFUN PROVIDE) #P"SRC:LSP;MODULE.LSP.NEWEST" . 905))
PSETF
(((DOCUMENTATION . FUNCTION) . "Syntax: (psetf {place form}*)
Similar to SETF, but evaluates all FORMs first, and then assigns each value to
the corresponding PLACE.  Returns NIL.") ((:LAMBDA-LIST) &ENVIRONMENT SI::ENV &REST REST) ((SI:LOCATION DEFMACRO PSETF) #P"SRC:LSP;SETF.LSP.NEWEST" . 15708))
PSETQ
(((DOCUMENTATION . FUNCTION) . "Syntax: (psetq {var form}*)
Similar to SETQ, but evaluates all FORMs first, and then assigns each value to
the corresponding VAR.  Returns NIL.") ((:LAMBDA-LIST) &REST SI::ARGS) ((SI:LOCATION DEFMACRO PSETQ) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 5817))
PUSH
(((DOCUMENTATION . FUNCTION) . "Syntax: (push form place)
Evaluates FORM, conses the value of FORM to the value stored in PLACE, and
makes it the new value of PLACE.  Returns the new value of PLACE.") ((:LAMBDA-LIST) &ENVIRONMENT SI::ENV SI::ITEM SI::PLACE) ((SI:LOCATION DEFMACRO PUSH) #P"SRC:LSP;SETF.LSP.NEWEST" . 23833))
SI::PUSH-TYPE
(((:LAMBDA-LIST) TYPE SI::TAG) ((SI:LOCATION DEFUN SI::PUSH-TYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 30896))
C::PUSH-VARS
(((:LAMBDA-LIST) C::V) ((SI:LOCATION DEFUN C::PUSH-VARS) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 8045))
PUSHNEW
(((DOCUMENTATION . FUNCTION) . "Syntax: (pushnew form place {keyword-form value-form}*)
Evaluates FORM first.  If the value is already in the list stored in PLACE,
does nothing.  Else, conses the value onto the list and makes the result the
new value of PLACE.  Returns NIL.  KEYWORD-FORMs and VALUE-FORMs are used to
check if the value of FORM is already in PLACE as if their values are passed
to MEMBER.") ((:LAMBDA-LIST) &ENVIRONMENT SI::ENV SI::ITEM SI::PLACE &REST REST) ((SI:LOCATION DEFMACRO PUSHNEW) #P"SRC:LSP;SETF.LSP.NEWEST" . 24626))
SI::QUEUED-OP
(((SI:LOCATION DEFCLASS SI::QUEUED-OP) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 10646))
SI::QUICK-SORT
(((:LAMBDA-LIST) SI::SEQ SI::START SI::END SI::PRED SI::KEY) ((SI:LOCATION DEFUN SI::QUICK-SORT) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 34774))
QUOTE
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (quote x) | 'x

Simply returns X without evaluating it.
") ((:LAMBDA-LIST) . "(quote x) | 'x"))
RANDOM
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER &OPTIONAL (RANDOM-STATE *RANDOM-STATE*))

Creates and returns a random number by using RANDOM-STATE.  NUMBER must be
either a positive integer or a positive float.  If NUMBER is a positive
integer, returns a positive integer less than NUMBER.  If NUMBER is a positive
float, returns a positive float less than NUMBER in the same float format as
NUMBER.
") ((:LAMBDA-LIST) NUMBER &OPTIONAL (RANDOM-STATE *RANDOM-STATE*)))
RANDOM-STATE
(((DOCUMENTATION . TYPE) . "
A random-state object stores information used to generate random numbers.  A
random-state is notated as '#$' followed by a certain number."))
RANDOM-STATE-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a random-state object; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
RASSOC
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ITEM ALIST &KEY (TEST '#'EQL) TEST-NOT (KEY '#'IDENTITY))

Returns the first pair in ALIST whose cdr is equal (in the sense of TEST) to
ITEM.  Returns NIL if no such pair exists.
The function KEY is applied to extract the key for comparison.
") ((:LAMBDA-LIST) SI::ITEM SI::ALIST &KEY (SI::TEST '#'EQL) SI::TEST-NOT (SI::KEY '#'IDENTITY)))
RASSOC-IF
(((DOCUMENTATION . FUNCTION) . "Returns the first pair in ALIST whose cdr satisfies TEST. Returns NIL if no
such pair exists.") ((:LAMBDA-LIST) SI::TEST SI::ALIST &KEY SI::KEY) ((SI:LOCATION DEFUN RASSOC-IF) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 4357))
RASSOC-IF-NOT
(((DOCUMENTATION . FUNCTION) . "Returns the first pair in ALIST whose cdr does not satisfy TEST.  Returns NIL
if no such pair exists.") ((:LAMBDA-LIST) SI::TEST SI::ALIST &KEY SI::KEY) ((SI:LOCATION DEFUN RASSOC-IF-NOT) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 4543))
RATIO
(((DOCUMENTATION . TYPE) . "
A ratio is notated by its numerator and denominator, separated by a slash '/'.
Normally, a ratio is notated in radix 10 (see *PRINT-BASE* and *READ-BASE*) as
	[sign] {digit}+ / {digit}+
where DIGIT is a decimal digit ('0', ..., '9') and SIGN is either '+' or '-'.
Also, the following syntax is used to notate the radix explicitly.
	# radix {r | R} [sign] {digit}+ / {digit}+
where RADIX is one of '2', '3', ..., '36' and DIGIT is a digit in radix RADIX:
	Digits in radix 2 are '0' and '1'
	Digits in radix 8 are '0', ..., '7'
	Digits in radix 16 are '0', ..., '9', 'a', ..., 'f', and 'A', ..., 'F'
The following syntax is also available for radix 2, 8, 10, and 16.
	# {b | B} [sign] {digit}+ / {digit}+
	# {o | O} [sign] {digit}+ / {digit}+
	# {x | X} [sign] {digit}+ / {digit}+"))
RATIONAL
(((DOCUMENTATION . TYPE) . "
A ratio is either an integer or a ratio.") ((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (REAL)

Converts REAL into rational accurately and returns the result.
") ((:LAMBDA-LIST) REAL))
RATIONALIZE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (REAL)

Converts REAL into rational approximately and returns the result.
") ((:LAMBDA-LIST) REAL))
RATIONALP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is an integer or a ratio; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
READ
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&OPTIONAL (STREAM *STANDARD-INPUT*) (EOF-ERROR-P T) (EOF-VALUE NIL) (RECURSIVEP NIL))

Reads an object from STREAM and returns the object.
") ((:LAMBDA-LIST) &OPTIONAL (STREAM *STANDARD-INPUT*) (SI::EOF-ERROR-P T) (SI::EOF-VALUE NIL) (SI::RECURSIVEP NIL)))
READ-BYTE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STREAM &OPTIONAL (EOF-ERROR-P T) (EOF-VALUE NIL))

Reads one byte from STREAM and returns it as an integer.
") ((:LAMBDA-LIST) STREAM &OPTIONAL (SI::EOF-ERROR-P T) (SI::EOF-VALUE NIL)))
READ-CHAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&OPTIONAL (STREAM *STANDARD-INPUT*) (EOF-ERROR-P T) (EOF-VALUE NIL) (RECURSIVE-P NIL))

Reads a character from STREAM and returns it.
") ((:LAMBDA-LIST) &OPTIONAL (STREAM *STANDARD-INPUT*) (SI::EOF-ERROR-P T) (SI::EOF-VALUE NIL) (SI::RECURSIVE-P NIL)))
READ-CHAR-NO-HANG
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&OPTIONAL (STREAM *STANDARD-INPUT*) (EOF-ERROR-P T) (EOF-VALUE NIL) (RECURSIVE-P NIL))

Returns the next character from STREAM if one is available; NIL otherwise.
") ((:LAMBDA-LIST) &OPTIONAL (STREAM *STANDARD-INPUT*) (SI::EOF-ERROR-P T) (SI::EOF-VALUE NIL) (SI::RECURSIVE-P NIL)))
READ-DELIMITED-LIST
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR &OPTIONAL (STREAM *STANDARD-INPUT*) (RECURSIVE-P NIL))

Reads objects from STREAM until the next character after an object's
representation is CHAR.  Returns all objects read, as a list.
") ((:LAMBDA-LIST) CHAR &OPTIONAL (STREAM *STANDARD-INPUT*) (SI::RECURSIVE-P NIL)))
SI::READ-EVALUATED-FORM
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::READ-EVALUATED-FORM) #P"SRC:LSP;ASSERT.LSP.NEWEST" . 533))
READ-FROM-STRING
(((DOCUMENTATION . FUNCTION) . "Args: (string &optional (eof-error-p t) (eof-value nil)
              &key (start 0) (end (length string)) (preserve-whitespace nil))
Reads an object from STRING and returns the object.  As the second value,
returns the index to the character next to the object's representation.
PRESERVE-WHITESPACE specifies whether to leave the character next to the
object's representation.") ((:LAMBDA-LIST) STRING &OPTIONAL (SI::EOF-ERROR-P T) SI::EOF-VALUE &KEY (SI::START 0) (SI::END (LENGTH STRING)) SI::PRESERVE-WHITESPACE) ((SI:LOCATION DEFUN READ-FROM-STRING) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 2501))
SI::READ-INSPECT-COMMAND
(((:LAMBDA-LIST) SI::LABEL SI::OBJECT SI::ALLOW-RECURSIVE) ((SI:LOCATION DEFUN SI::READ-INSPECT-COMMAND) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 2326))
READ-LINE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&OPTIONAL (STREAM *STANDARD-INPUT*) (EOF-ERROR-P T) (EOF-VALUE NIL) (RECURSIVE-P NIL))

Reads a line of characters from STREAM and returns them as a string.  The
newline character at the end of the line will be discarded.
") ((:LAMBDA-LIST) &OPTIONAL (STREAM *STANDARD-INPUT*) (SI::EOF-ERROR-P T) (SI::EOF-VALUE NIL) (SI::RECURSIVE-P NIL)))
C::READ-NAME
(((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFUN C::READ-NAME) #P"SRC:CMP;CMPNAME.LSP.NEWEST" . 2577))
C::READ-ONLY-VARIABLE-P
(((:LAMBDA-LIST) C::V C::OTHER-DECLS) ((SI:LOCATION DEFUN C::READ-ONLY-VARIABLE-P) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 8366))
READ-PRESERVING-WHITESPACE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&OPTIONAL (STREAM *STANDARD-INPUT*) (EOF-ERROR-P T) (EOF-VALUE NIL) (RECURSIVE-P NIL))

Reads an object from STREAM and returns the object.  Unlike READ, always
leaves the character next to the object's representation.
") ((:LAMBDA-LIST) &OPTIONAL (STREAM *STANDARD-INPUT*) (SI::EOF-ERROR-P T) (SI::EOF-VALUE NIL) (SI::RECURSIVE-P NIL)))
READER-ERROR
(((SI:LOCATION DEFCLASS READER-ERROR) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
CLOS:READER-METHOD-CLASS
(((SI:LOCATION DEFMETHOD CLOS:READER-METHOD-CLASS (CLASS CLOS::STD-CLASS) (CLOS::DIRECT-SLOT CLOS:DIRECT-SLOT-DEFINITION) &REST CLOS::INITARGS) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 2557))
READTABLE
(((DOCUMENTATION . TYPE) . "
A readtable defines the syntax used to read objects.
Each readtable object remembers the syntactic class of each character.  The
following syntactic classes are supported.  The characters in parenthesis
below are those standard characters that belong to each syntactic class as
defined in the standard readtable.
	white-space (space and newline)
	single-escape ( \\ )
	multiple-escape ( | )
	macro-character ( \"  #  '  (  )  ,  ;  ` )
	constituent (the others)
For each macro-character, the readtable remembers the definition of the
associated read macro and the non-terminating-p flag.  In the standard
readtable, only single-quote is non-terminating.  Dispatch macro characters
are classified to macro-characters.  A readtable is notated as
	#<readtable n>
where N is actually a number that identifies the readtable."))
READTABLEP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a readtable object; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
SI::REALLY-END-LOGICAL-BLOCK
(((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFUN SI::REALLY-END-LOGICAL-BLOCK) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 10179))
SI::REALLY-START-LOGICAL-BLOCK
(((:LAMBDA-LIST) STREAM SI::COLUMN SI::PREFIX SI::SUFFIX) ((SI:LOCATION DEFUN SI::REALLY-START-LOGICAL-BLOCK) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 7642))
REALPART
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER)

Returns the realpart of NUMBER if it is a complex.  Otherwise, returns NUMBER.
") ((:LAMBDA-LIST) NUMBER))
SI::RECKLESS
(((:LAMBDA-LIST) &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::RECKLESS) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/src/lsp/seqmacros.lsp" . 2381))
C::RECKLESS
(((:LAMBDA-LIST) &REST C::BODY) ((SI:LOCATION DEFMACRO C::RECKLESS) #P"SRC:CMP;CMPMAC.LSP.NEWEST" . 3302))
SI::RECODE-UNIVERSAL-TIME
(((:LAMBDA-LIST) SI::SEC MIN SI::HOUR SI::DAY SI::MONTH SI::YEAR SI::TZ SI::DST) ((SI:LOCATION DEFUN SI::RECODE-UNIVERSAL-TIME) #P"SRC:LSP;MISLIB.LSP.NEWEST" . 4787))
SI::RECONSTRUCT-BYTECODES-LAMBDA-LIST
(((:LAMBDA-LIST) SI::DATA) ((SI:LOCATION DEFUN SI::RECONSTRUCT-BYTECODES-LAMBDA-LIST) #P"SRC:LSP;TOP.LSP.NEWEST" . 27777))
CLOS::RECURSIVELY-UPDATE-CLASSES
(((:LAMBDA-LIST) CLOS::A-CLASS) ((SI:LOCATION DEFUN CLOS::RECURSIVELY-UPDATE-CLASSES) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 10463))
GRAY::REDEFINE-CL-FUNCTIONS
(((DOCUMENTATION . FUNCTION) . "Some functions in CL package are expected to be generic. We make them so.") ((:LAMBDA-LIST)) ((SI:LOCATION DEFUN GRAY::REDEFINE-CL-FUNCTIONS) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 21768))
REDUCE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FUNCTION SEQUENCE &KEY (FROM-END NIL) (START 0) (END (LENGTH SEQUENCE)) INITIAL-VALUE)

Combines all the elements of SEQUENCE using the binary operation FUNCTION.
") ((:LAMBDA-LIST) FUNCTION SEQUENCE &KEY (SI::FROM-END NIL) (SI::START 0) (SI::END (LENGTH SEQUENCE)) SI::INITIAL-VALUE) ((SI:LOCATION DEFUN REDUCE) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 1950))
C::REF
(((SI:LOCATION DEFCLASS C::REF) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 937))
SI::REGISTER-ARRAY-TYPE
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN SI::REGISTER-ARRAY-TYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 32408))
SI::REGISTER-CLASS
(((:LAMBDA-LIST) CLASS) ((SI:LOCATION DEFUN SI::REGISTER-CLASS) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 31549))
SI::REGISTER-CONS-TYPE
(((:LAMBDA-LIST) &OPTIONAL (SI::CAR-TYPE '*) (SI::CDR-TYPE '*)) ((SI:LOCATION DEFUN SI::REGISTER-CONS-TYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 39552))
SI::REGISTER-ELEMENTARY-INTERVAL
(((:LAMBDA-LIST) TYPE SI::B) ((SI:LOCATION DEFUN SI::REGISTER-ELEMENTARY-INTERVAL) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 35837))
SI::REGISTER-GLOBAL
(((:LAMBDA-LIST) C::NAME) ((SI:LOCATION DEFUN SI::REGISTER-GLOBAL) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 10414))
SI::REGISTER-INTERVAL-TYPE
(((:LAMBDA-LIST) SI::INTERVAL) ((SI:LOCATION DEFUN SI::REGISTER-INTERVAL-TYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 36413))
SI::REGISTER-MEMBER-TYPE
(((:LAMBDA-LIST) SI::OBJECT) ((SI:LOCATION DEFUN SI::REGISTER-MEMBER-TYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 29710))
SI::REGISTER-SATISFIES-TYPE
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN SI::REGISTER-SATISFIES-TYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 31328))
SI::REGISTER-TYPE
(((:LAMBDA-LIST) TYPE SI::IN-OUR-FAMILY-P SI::TYPE-<=) ((SI:LOCATION DEFUN SI::REGISTER-TYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 28667))
REINITIALIZE-INSTANCE
(((SI:LOCATION DEFMETHOD REINITIALIZE-INSTANCE (CLASS CLASS) &REST CLOS::INITARGS &KEY (CLOS::DIRECT-SUPERCLASSES NIL CLOS::DIRECT-SUPERCLASSES-P) (CLOS::DIRECT-SLOTS NIL CLOS::DIRECT-SLOTS-P)) #P"SRC:CLOS;CHANGE.LSP.NEWEST" . 7468) ((SI:LOCATION DEFMETHOD REINITIALIZE-INSTANCE (CLOS::INSTANCE T) &REST CLOS::INITARGS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 714))
C::RELOCATE-PARENTS-LIST
(((:LAMBDA-LIST) C::DEST C::NEW-FIELDS) ((SI:LOCATION DEFUN C::RELOCATE-PARENTS-LIST) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 10162))
REM
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER DIVISOR)

Returns the second value of (TRUNCATE NUMBER DIVISOR), i.e. the value of
	(- NUMBER (* (TRUNCATE NUMBER DIVISOR) DIVISOR))
") ((:LAMBDA-LIST) NUMBER SI::DIVISOR))
REMF
(((DOCUMENTATION . FUNCTION) . "Syntax: (remf place form)
Removes the property specified by FORM from the property list stored in PLACE.
Returns T if the property list had the specified property; NIL otherwise.") ((:LAMBDA-LIST) &ENVIRONMENT SI::ENV SI::PLACE SI::INDICATOR) ((SI:LOCATION DEFMACRO REMF) #P"SRC:LSP;SETF.LSP.NEWEST" . 22918))
REMHASH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (KEY HASH-TABLE)

Removes the entry for KEY in HASH-TABLE.  Returns T if such an entry existed;
NIL otherwise.
") ((:LAMBDA-LIST) SI::KEY HASH-TABLE))
REMOVE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ITEM SEQUENCE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Returns a copy of SEQUENCE with those elements equal to ITEM (in the sense of
TEST) removed.
") ((:LAMBDA-LIST) SI::ITEM SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::TEST '#'EQL) SI::TEST-NOT (SI::START 0) (SI::END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN REMOVE) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 9557))
CLOS::REMOVE-ACCESSORS
(((:LAMBDA-LIST) CLOS::SLOTDS) ((SI:LOCATION DEFUN CLOS::REMOVE-ACCESSORS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 1201))
CLOS:REMOVE-DEPENDENT
(((SI:LOCATION DEFMETHOD CLOS:REMOVE-DEPENDENT (CLOS::C CLASS) CLOS::DEP) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 10241) ((SI:LOCATION DEFMETHOD CLOS:REMOVE-DEPENDENT (CLOS::C STANDARD-GENERIC-FUNCTION) CLOS::DEP) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 10081))
CLOS:REMOVE-DIRECT-SUBCLASS
(((SI:LOCATION DEFMETHOD CLOS:REMOVE-DIRECT-SUBCLASS (CLOS::PARENT CLASS) CLOS::CHILD) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 8127))
REMOVE-DUPLICATES
(((DOCUMENTATION . FUNCTION) . "Args: (sequence
       &key key (test '#'eql) test-not
            (start 0) (end (length sequence)) (from-end nil))
Returns a copy of SEQUENCE without duplicated elements.") ((:LAMBDA-LIST) SEQUENCE &KEY SI::TEST SI::TEST-NOT SI::FROM-END (SI::START 0) SI::END SI::KEY) ((SI:LOCATION DEFUN REMOVE-DUPLICATES) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 21258))
SI::REMOVE-DUPLICATES-LIST
(((:LAMBDA-LIST) SEQUENCE SI::START SI::END SI::FROM-END SI::TEST SI::TEST-NOT SI::KEY) ((SI:LOCATION DEFUN SI::REMOVE-DUPLICATES-LIST) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 19254))
REMOVE-IF
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Returns a copy of SEQUENCE with elements satisfying TEST removed.
") ((:LAMBDA-LIST) SI::TEST SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::START 0) (SI::END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN REMOVE-IF) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 10278))
REMOVE-IF-NOT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Returns a copy of SEQUENCE with elements not satisfying TEST removed.
") ((:LAMBDA-LIST) SI::TEST SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::START 0) (SI::END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN REMOVE-IF-NOT) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 10504))
SI::REMOVE-LIST
(((:LAMBDA-LIST) SI::WHICH SEQUENCE SI::START SI::END COUNT SI::TEST SI::TEST-NOT SI::KEY) ((SI:LOCATION DEFUN SI::REMOVE-LIST) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 8681))
REMOVE-METHOD
(((:LAMBDA-LIST) CLOS::GF METHOD) ((SI:LOCATION DEFUN REMOVE-METHOD) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 8095))
CLOS::REMOVE-OPTIONAL-SLOT-ACCESSORS
(((:LAMBDA-LIST) CLASS) ((SI:LOCATION DEFUN CLOS::REMOVE-OPTIONAL-SLOT-ACCESSORS) #P"SRC:CLOS;CHANGE.LSP.NEWEST" . 9035))
SI::REMOVE-OTHERWISE-FROM-CLAUSES
(((:LAMBDA-LIST) SI::CLAUSES) ((SI:LOCATION DEFUN SI::REMOVE-OTHERWISE-FROM-CLAUSES) #P"SRC:LSP;ASSERT.LSP.NEWEST" . 4819))
C::REMOVE-PREFIX
(((:LAMBDA-LIST) C::PREFIX C::NAME) ((SI:LOCATION DEFUN C::REMOVE-PREFIX) #P"SRC:CMP;CMPNAME.LSP.NEWEST" . 3348))
REMPROP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL INDICATOR)

Removes the specified property from the property list associated with SYMBOL.
Returns T if the property list had the specified property; NIL otherwise.
") ((:LAMBDA-LIST) SYMBOL SI::INDICATOR))
RENAME-FILE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC NEW-FILESPEC &KEY (IF-EXISTS ERROR))

Renames the file specified by FILESPEC as specified by NEW-FILESPEC.  Returns
as three values the new pathname, the old full pathname, and the new full
pathname.  FILESPEC and NEW-FILESPEC may be a symbol, a string, a pathname, or
a file stream.

:IF-EXISTS is an ECL-specific extension that modifies the behavior of rename-file
if new-filespec already exists. It may be :ERROR (the default), NIL, :SUPERSEDE,
or T.
") ((:LAMBDA-LIST) SI::FILESPEC SI::NEW-FILESPEC &KEY (SI::IF-EXISTS :ERROR)))
RENAME-PACKAGE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (PACKAGE NEW-NAME &OPTIONAL (NEW-NICKNAMES NIL))

Renames PACKAGE to NEW-NAME and replaces the nicknames with NEW-NICKNAMES.
See MAKE-PACKAGE.
") ((:LAMBDA-LIST) PACKAGE SI::NEW-NAME &OPTIONAL (SI::NEW-NICKNAMES NIL)))
C::REP-TYPE
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN C::REP-TYPE) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 17751))
C::REP-TYPE->LISP-TYPE
(((:LAMBDA-LIST) C::REP-TYPE) ((SI:LOCATION DEFUN C::REP-TYPE->LISP-TYPE) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 5766))
C::REP-TYPE-NAME
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN C::REP-TYPE-NAME) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 6505))
C::REP-TYPE-RECORD
(((:LAMBDA-LIST) C::REP-TYPE) ((SI:LOCATION DEFUN C::REP-TYPE-RECORD) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 5682))
REPLACE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SEQUENCE1 SEQUENCE2 &KEY (START1 0) (END1 (LENGTH SEQUENCE1)) (START2 0) (END2 (LENGTH SEQUENCE2)))

Replaces elements of SEQUENCE1 with the corresponding elements of SEQUENCE2.
SEQUENCE1 may be destroyed and is returned.
") ((:LAMBDA-LIST) SI::SEQUENCE1 SI::SEQUENCE2 &KEY (SI::START1 0) (SI::END1 (LENGTH SI::SEQUENCE1)) (SI::START2 0) (SI::END2 (LENGTH SI::SEQUENCE2))) ((SI:LOCATION DEFUN REPLACE) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 4578))
C::REPLACEABLE
(((:LAMBDA-LIST) C::VAR C::FORM) ((SI:LOCATION DEFUN C::REPLACEABLE) #P"SRC:CMP;CMPLET.LSP.NEWEST" . 8935))
REQUIRE
(((DOCUMENTATION . FUNCTION) . "Loads a module, unless it already has been loaded. PATHNAMES, if supplied,
is a designator for a list of pathnames to be loaded if the module
needs to be. If PATHNAMES is not supplied, functions from the list
*MODULE-PROVIDER-FUNCTIONS* are called in order with MODULE-NAME
as an argument, until one of them returns non-NIL.  User code is
responsible for calling PROVIDE to indicate a successful load of the
module.") ((:LAMBDA-LIST) SI::MODULE-NAME &OPTIONAL SI::PATHNAMES) ((SI:LOCATION DEFUN REQUIRE) #P"SRC:LSP;MODULE.LSP.NEWEST" . 1231))
SI::REQUIRE-ERROR
(((:LAMBDA-LIST) SI::CONTROL &REST SI::ARGUMENTS) ((SI:LOCATION DEFUN SI::REQUIRE-ERROR) #P"SRC:LSP;MODULE.LSP.NEWEST" . 1135))
REST
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to CDR.
") ((:LAMBDA-LIST) SI::X))
RESTART
(((SI:LOCATION DEFCLASS RESTART) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 2088))
RESTART-BIND
(((:LAMBDA-LIST) SI::BINDINGS &BODY SI::FORMS) ((SI:LOCATION DEFMACRO RESTART-BIND) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 2442))
RESTART-CASE
(((:LAMBDA-LIST) SI::EXPRESSION &BODY SI::CLAUSES &ENVIRONMENT SI::ENV) ((SI:LOCATION DEFMACRO RESTART-CASE) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 3644))
SI::RESTART-PRINT
(((:LAMBDA-LIST) RESTART STREAM SI::DEPTH) ((SI:LOCATION DEFUN SI::RESTART-PRINT) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 1874))
SI::RESTART-REPORT
(((:LAMBDA-LIST) RESTART STREAM) ((SI:LOCATION DEFUN SI::RESTART-REPORT) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 2235))
C::RESULT-TYPE
(((:LAMBDA-LIST) C::X) ((SI:LOCATION DEFUN C::RESULT-TYPE) #P"SRC:CMP;CMPFUN.LSP.NEWEST" . 4594))
RETURN
(((DOCUMENTATION . FUNCTION) . "Macro in COMMON-LISP package:
Syntax: (return [result])

Terminates execution of the lexically surrounding NIL block and returns all
values of RESULT (which defaults to NIL) as the values of the terminated
block.
") ((:LAMBDA-LIST) . "(return [result])") ((SI:LOCATION DEFMACRO RETURN) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 10603))
RETURN-FROM
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (return-from symbol [result])

Terminates execution of the lexically surrounding block named SYMBOL and
returns all values of RESULT (which defaults to NIL) as the values of the
terminated block.
") ((:LAMBDA-LIST) . "(return-from symbol [result])"))
REVAPPEND
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X Y)

Equivalent to (APPEND (REVERSE X) Y)
") ((:LAMBDA-LIST) SI::X SI::Y))
REVERSE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SEQUENCE)

Returns a new sequence containing the same elements as SEQUENCE but in the
reverse order.
") ((:LAMBDA-LIST) SEQUENCE))
C::REVISE-VAR-TYPE
(((:LAMBDA-LIST) VARIABLE C::ASSUMPTIONS C::WHERE-TO-STOP) ((SI:LOCATION DEFUN C::REVISE-VAR-TYPE) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 3371))
ROOM
(((DOCUMENTATION . FUNCTION) . "Args: (&optional (x t))
Displays information about storage allocation in the following format.
	* for each type class
		* number of pages so-far allocated for the type class
		* maximum number of pages for the type class
		* percentage of used cells to cells so-far allocated
		* number of times the garbage collector has been called to
		  collect cells of the type class
		* implementation types that belongs to the type class
	* number of pages actually allocated for contiguous blocks
	* maximum number of pages for contiguous blocks
	* number of times the garbage collector has been called to collect
	  contiguous blocks
	* number of pages in the hole
	* total number of pages allocated for cells
	* total number of pages allocated
	* number of available pages
	* number of pages ECL can use.
The number of times the garbage collector has been called is not shown, if the
number is zero.  The optional X is simply ignored.") ((:LAMBDA-LIST) &OPTIONAL SI::X) ((SI:LOCATION DEFUN ROOM) #P"SRC:LSP;AUTOLOAD.LSP.NEWEST" . 1518))
ROTATEF
(((DOCUMENTATION . FUNCTION) . "Syntax: (rotatef {place}*)
Saves the values of PLACEs, and then assigns to each PLACE the saved value of
the PLACE to its right.  The rightmost PLACE gets the value of the leftmost
PLACE.  Returns NIL.") ((:LAMBDA-LIST) &ENVIRONMENT SI::ENV &REST REST) ((SI:LOCATION DEFMACRO ROTATEF) #P"SRC:LSP;SETF.LSP.NEWEST" . 17819))
ROUND
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER &OPTIONAL (DIVISOR 1))

Returns the integer nearest to NUMBER/DIVISOR.  Returns the value of (- NUMBER
(* first-value DIVISOR)) as the second value.
") ((:LAMBDA-LIST) NUMBER &OPTIONAL (SI::DIVISOR 1)))
SI::ROW-MAJOR-INDEX-INNER
(((:LAMBDA-LIST) ARRAY SI::INDICES) ((SI:LOCATION DEFUN SI::ROW-MAJOR-INDEX-INNER) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 5048))
RPLACA
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CONS X)

Replaces the car of CONS with X, and returns the modified CONS.
") ((:LAMBDA-LIST) CONS SI::X))
RPLACD
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CONS X)

Replaces the cdr of CONS with X, and returns the modified CONS.
") ((:LAMBDA-LIST) CONS SI::X))
SI::SAFE-CANONICAL-TYPE
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN SI::SAFE-CANONICAL-TYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 47819))
C::SAFE-COMPILE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::SAFE-COMPILE) #P"SRC:CMP;CMPPOLICY.LSP.NEWEST" . 12038))
SI:SAFE-EVAL
(((DOCUMENTATION . FUNCTION) . "Args: (FORM ENV &optional ERR-VALUE)
Evaluates FORM in the given environment, which may be NIL. If the form
signals an error, or tries to jump to an outer point, the function has two
choices: by default, it will invoke a debugger, but if a third value is
supplied, then SAFE-EVAL will not use a debugger but rather return that
value.") ((:LAMBDA-LIST) SI::FORM SI::ENV &OPTIONAL (SI::ERR-VALUE NIL SI::ERR-VALUE-P)) ((SI:LOCATION DEFUN SI:SAFE-EVAL) #P"SRC:LSP;TOP.LSP.NEWEST" . 51096))
CLOS::SAFE-INSTANCE-REF
(((:LAMBDA-LIST) CLOS::OBJECT CLOS::INDEX) ((SI:LOCATION DEFUN CLOS::SAFE-INSTANCE-REF) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 22695))
C::SAFE-LIST-LENGTH
(((:LAMBDA-LIST) C::L) ((SI:LOCATION DEFUN C::SAFE-LIST-LENGTH) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 8396))
C::SAFE-MKSTEMP
(((:LAMBDA-LIST) C::TEMPLATE) ((SI:LOCATION DEFUN C::SAFE-MKSTEMP) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 688))
C::SAFE-RUN-PROGRAM
(((:LAMBDA-LIST) C::PROGRAM C::ARGS) ((SI:LOCATION DEFUN C::SAFE-RUN-PROGRAM) #P"SRC:CMP;CMPOS-RUN.LSP.NEWEST" . 1318))
CLOS::SAFE-SLOT-DEFINITION-LOCATION
(((:LAMBDA-LIST) CLOS::SLOTD &OPTIONAL CLOS::DEFAULT) ((SI:LOCATION DEFUN CLOS::SAFE-SLOT-DEFINITION-LOCATION) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 15238))
C::SAFE-SYSTEM
(((:LAMBDA-LIST) STRING) ((SI:LOCATION DEFUN C::SAFE-SYSTEM) #P"SRC:CMP;CMPOS-RUN.LSP.NEWEST" . 523))
C::SAFE-TYPE<=
(((:LAMBDA-LIST) C::T1 C::T2) ((SI:LOCATION DEFUN C::SAFE-TYPE<=) #P"SRC:CMP;CMPOPT-TYPE.LSP.NEWEST" . 687))
C::SAME-FNAME-P
(((:LAMBDA-LIST) C::NAME1 C::NAME2) ((SI:LOCATION DEFUN C::SAME-FNAME-P) #P"SRC:CMP;CMPMAC.LSP.NEWEST" . 2186))
SI::SAVE
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (FILESPEC)

ECL specific.
Saves the current ECL core image into a program file specified by PATHNAME.
FILESPEC may be a symbol, a string, a pathname, or a file stream.  This
function depends on the version of ECL.  See ECL Report for details.
") ((:LAMBDA-LIST) SI::FILESPEC))
C::SAVE-DIRECTORY
(((:LAMBDA-LIST) C::FORMS) ((SI:LOCATION DEFUN C::SAVE-DIRECTORY) #P"SRC:CMP;CMPOS-RUN.LSP.NEWEST" . 790))
C::SAVE-INLINE-LOC
(((:LAMBDA-LIST) C::LOC) ((SI:LOCATION DEFUN C::SAVE-INLINE-LOC) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 1827))
SBIT
(((DOCUMENTATION . FUNCTION) . "Args: (simple-bit-array &rest subscripts)
Returns the specified bit in SIMPLE-BIT-ARRAY.") ((:LAMBDA-LIST) SI::BIT-ARRAY &REST SI::INDICES) ((SI:LOCATION DEFUN SBIT) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 6616))
SI::SCALE-EXPONENT
(((:LAMBDA-LIST) SI::ORIGINAL-X) ((SI:LOCATION DEFUN SI::SCALE-EXPONENT) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 8514))
SCALE-FLOAT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FLOAT INTEGER)

Returns the value of (* FLOAT (expt (float-radix FLOAT) INTEGER)).
") ((:LAMBDA-LIST) FLOAT INTEGER))
C::SCH-GLOBAL
(((:LAMBDA-LIST) C::NAME) ((SI:LOCATION DEFUN C::SCH-GLOBAL) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 4668))
SCHAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SIMPLE-STRING N)

Returns the character object representing the N-th character in SIMPLE-STRING.
This is faster than CHAR.
") ((:LAMBDA-LIST) SIMPLE-STRING SI::N))
SEARCH
(((DOCUMENTATION . FUNCTION) . "Args: (sequence1 sequence2
       &key key (test '#'eql) test-not
            (start1 0) (end1 (length sequence1))
            (start2 0) (end2 (length sequence2))
            (from-end nil))
Searches SEQUENCE2 for a subsequence that element-wise matches SEQUENCE1.
Returns the index to the first element of the subsequence if such a
subsequence is found.  Returns NIL otherwise.") ((:LAMBDA-LIST) SI::SEQUENCE1 SI::SEQUENCE2 &KEY SI::FROM-END SI::TEST SI::TEST-NOT SI::KEY (SI::START1 0) (SI::START2 0) SI::END1 SI::END2) ((SI:LOCATION DEFUN SEARCH) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 28095))
SI::SEARCH-GENERIC
(((:LAMBDA-LIST) SI::SEQUENCE1 SI::START1 SI::END1 SI::SEQUENCE2 SI::START2 SI::END2 SI::TEST SI::TEST-NOT SI::KEY SI::FROM-END) ((SI:LOCATION DEFUN SI::SEARCH-GENERIC) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 30572))
SI::SEARCH-PRINT-CIRCLE
(((:LAMBDA-LIST) SI::OBJECT) ((SI:LOCATION DEFUN SI::SEARCH-PRINT-CIRCLE) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 25870))
C::SEARCH-TAG
(((:LAMBDA-LIST) STREAM C::TAG) ((SI:LOCATION DEFUN C::SEARCH-TAG) #P"SRC:CMP;CMPNAME.LSP.NEWEST" . 2250))
SI::SEARCH-VECTOR
(((:LAMBDA-LIST) SI::SEQUENCE1 SI::START1 SI::END1 SI::SEQUENCE2 SI::START2 SI::END2 SI::TEST SI::TEST-NOT SI::KEY SI::FROM-END) ((SI:LOCATION DEFUN SI::SEARCH-VECTOR) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 29009))
SECOND
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to CADR.
") ((:LAMBDA-LIST) SI::X))
SI::SECTION-START
(((SI:LOCATION DEFCLASS SI::SECTION-START) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 11371))
SI:SEGMENTATION-VIOLATION
(((SI:LOCATION DEFCLASS SI:SEGMENTATION-VIOLATION) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
SI::SELECT-?
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::SELECT-?) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 1589))
CLOS::SELECT-CLOS-?
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN CLOS::SELECT-CLOS-?) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 6957))
CLOS::SELECT-CLOS-J
(((SI:LOCATION DEFMETHOD CLOS::SELECT-CLOS-J (CLOS::INSTANCE T)) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 6876) ((SI:LOCATION DEFMETHOD CLOS::SELECT-CLOS-J (CLOS::INSTANCE CLOS::STD-CLASS)) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 6787) ((SI:LOCATION DEFMETHOD CLOS::SELECT-CLOS-J (CLOS::INSTANCE STANDARD-OBJECT)) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 4638))
CLOS::SELECT-CLOS-J-INNER-CLASS
(((:LAMBDA-LIST) CLOS::INSTANCE) ((SI:LOCATION DEFUN CLOS::SELECT-CLOS-J-INNER-CLASS) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 5741))
CLOS::SELECT-CLOS-L
(((SI:LOCATION DEFMETHOD CLOS::SELECT-CLOS-L (CLOS::INSTANCE T)) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 4557) ((SI:LOCATION DEFMETHOD CLOS::SELECT-CLOS-L (CLOS::INSTANCE CLOS::STD-CLASS)) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 4468) ((SI:LOCATION DEFMETHOD CLOS::SELECT-CLOS-L (CLOS::INSTANCE STANDARD-OBJECT)) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 3347))
CLOS::SELECT-CLOS-L-INNER-CLASS
(((:LAMBDA-LIST) CLOS::INSTANCE) ((SI:LOCATION DEFUN CLOS::SELECT-CLOS-L-INNER-CLASS) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 4054))
CLOS::SELECT-CLOS-N
(((SI:LOCATION DEFMETHOD CLOS::SELECT-CLOS-N (CLOS::INSTANCE T)) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 3266) ((SI:LOCATION DEFMETHOD CLOS::SELECT-CLOS-N (CLOS::INSTANCE CLOS::STD-CLASS)) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 3177) ((SI:LOCATION DEFMETHOD CLOS::SELECT-CLOS-N (CLOS::INSTANCE STANDARD-OBJECT)) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 594))
CLOS::SELECT-CLOS-N-INNER-CLASS
(((:LAMBDA-LIST) CLOS::INSTANCE) ((SI:LOCATION DEFUN CLOS::SELECT-CLOS-N-INNER-CLASS) #P"SRC:CLOS;INSPECT.LSP.NEWEST" . 2268))
SI::SELECT-E
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::SELECT-E) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 1238))
SI::SELECT-HT-?
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::SELECT-HT-?) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 12200))
SI::SELECT-HT-J
(((:LAMBDA-LIST) SI::HASHTABLE) ((SI:LOCATION DEFUN SI::SELECT-HT-J) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 11661))
SI::SELECT-HT-L
(((:LAMBDA-LIST) SI::HASHTABLE) ((SI:LOCATION DEFUN SI::SELECT-HT-L) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 11421))
SI::SELECT-HT-N
(((:LAMBDA-LIST) SI::HASHTABLE) ((SI:LOCATION DEFUN SI::SELECT-HT-N) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 11136))
SI::SELECT-P
(((:LAMBDA-LIST) SI::OBJECT) ((SI:LOCATION DEFUN SI::SELECT-P) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 1102))
SI::SELECT-U
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::SELECT-U) #P"SRC:LSP;DESCRIBE.LSP.NEWEST" . 1483))
CLOS::SELF-EVALUATING-P
(((:LAMBDA-LIST) CLOS::FORM) ((SI:LOCATION DEFUN CLOS::SELF-EVALUATING-P) #P"SRC:CLOS;DEFCLASS.LSP.NEWEST" . 560))
SI::SEQ-ITERATOR-LIST-POP
(((:LAMBDA-LIST) VALUES-LIST SI::SEQ-LIST SI::ITERATOR-LIST) ((SI:LOCATION DEFUN SI::SEQ-ITERATOR-LIST-POP) #P"SRC:LSP;SEQ.LSP.NEWEST" . 6825))
SI::SEQ-ITERATOR-NEXT
(((:LAMBDA-LIST) SEQUENCE SI::ITERATOR) ((SI:LOCATION DEFUN SI::SEQ-ITERATOR-NEXT) #P"SRC:LSP;SEQ.LSP.NEWEST" . 6341))
SI::SEQ-ITERATOR-REF
(((:LAMBDA-LIST) SEQUENCE SI::ITERATOR) ((SI:LOCATION DEFUN SI::SEQ-ITERATOR-REF) #P"SRC:LSP;SEQ.LSP.NEWEST" . 5937))
SI::SEQ-ITERATOR-SET
(((:LAMBDA-LIST) SEQUENCE SI::ITERATOR SI::VALUE) ((SI:LOCATION DEFUN SI::SEQ-ITERATOR-SET) #P"SRC:LSP;SEQ.LSP.NEWEST" . 6123))
C::SEQ-OPT-KEY-FUNCTION
(((:LAMBDA-LIST) C::KEY) ((SI:LOCATION DEFUN C::SEQ-OPT-KEY-FUNCTION) #P"SRC:CMP;CMPOPT-SEQUENCE.LSP.NEWEST" . 1336))
C::SEQ-OPT-PARSE-ARGS
(((:LAMBDA-LIST) FUNCTION C::ARGS &KEY (C::START-END T)) ((SI:LOCATION DEFUN C::SEQ-OPT-PARSE-ARGS) #P"SRC:CMP;CMPOPT-SEQUENCE.LSP.NEWEST" . 1775))
C::SEQ-OPT-TEST-FUNCTION
(((:LAMBDA-LIST) C::TEST-FLAG C::TEST) ((SI:LOCATION DEFUN C::SEQ-OPT-TEST-FUNCTION) #P"SRC:CMP;CMPOPT-SEQUENCE.LSP.NEWEST" . 660))
SI::SEQTYPE
(((:LAMBDA-LIST) SEQUENCE) ((SI:LOCATION DEFUN SI::SEQTYPE) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 926))
SEQUENCE
(((DOCUMENTATION . TYPE) . "A sequence is either a list or a vector."))
SI:SEQUENCE-COUNT
(((:LAMBDA-LIST) COUNT) ((SI:LOCATION DEFUN SI:SEQUENCE-COUNT) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 1265))
SERIOUS-CONDITION
(((SI:LOCATION DEFCLASS SERIOUS-CONDITION) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
SET
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL OBJECT)

Assigns OBJECT to the global variable named SYMBOL.  Returns OBJECT.
") ((:LAMBDA-LIST) SYMBOL SI::OBJECT))
SI::SET-BREAK-ENV
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::SET-BREAK-ENV) #P"SRC:LSP;TOP.LSP.NEWEST" . 42143))
SI::SET-CHAR-BIT
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (CHAR BIT-NAME FLAG)

Returns a character with the same code and attributes as CHAR except the
bit specified by BIT-NAME is on (if FLAG is non-NIL) or off. In ECL, the
bit-attributes handled are :control :meta :super and :hyper
") ((:LAMBDA-LIST) CHAR SI::BIT-NAME SI::FLAG))
SI::SET-CURRENT-IHS
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::SET-CURRENT-IHS) #P"SRC:LSP;TOP.LSP.NEWEST" . 41973))
SET-DIFFERENCE
(((DOCUMENTATION . FUNCTION) . "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns, as a list, those elements of LIST1 that are not elements of LIST2.") ((:LAMBDA-LIST) SI::LIST1 SI::LIST2 &KEY SI::TEST SI::TEST-NOT SI::KEY) ((SI:LOCATION DEFUN SET-DIFFERENCE) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 2325))
SET-DISPATCH-MACRO-CHARACTER
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR SUBCHAR FUNCTION &OPTIONAL (READTABLE *READTABLE*))

Replaces FUNCTION for the read macro of SUBCHAR associated with the dispatch
macro character CHAR in READTABLE.  When the ECL reader reads an object that
begins with CHAR followed by SUBCHAR, it calls FUNCTION with the input stream,
SUBCHAR, and NIL as arguments.  When the ECL reader reads an object that
begins with CHAR, followed by a decimal representation of a number N, followed
by SUB-CHAR, it calls FUNCTION with N as the third argument.  In both cases,
if FUNCTION returns a single value, then that value is returned as the value
of the reader.  If FUNCTION returns no value, then the reader tries to read an
object again.  See MAKE-DISPATCH-MACRO-CHARACTER and GET-DISPATCH-MACRO-
CHARACTER.
") ((:LAMBDA-LIST) CHAR SI::SUBCHAR FUNCTION &OPTIONAL (READTABLE *READTABLE*)))
SET-EXCLUSIVE-OR
(((DOCUMENTATION . FUNCTION) . "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns, as a list, those elements of LIST1 that are not elements of LIST2 and
those elements of LIST2 that are not elements of LIST1.") ((:LAMBDA-LIST) SI::LIST1 SI::LIST2 &KEY SI::TEST SI::TEST-NOT SI::KEY) ((SI:LOCATION DEFUN SET-EXCLUSIVE-OR) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 3206))
SI::SET-HOLE-SIZE
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (FIXNUM)

ECL specific.
Sets the size of the memory hole (in pages).
") ((:LAMBDA-LIST) FIXNUM))
SI::SET-INDENTATION
(((:LAMBDA-LIST) STREAM SI::COLUMN) ((SI:LOCATION DEFUN SI::SET-INDENTATION) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 9412))
C::SET-JUMP-FALSE
(((:LAMBDA-LIST) C::LOC C::LABEL) ((SI:LOCATION DEFUN C::SET-JUMP-FALSE) #P"SRC:CMP;CMPIF.LSP.NEWEST" . 6166))
C::SET-JUMP-TRUE
(((:LAMBDA-LIST) C::LOC C::LABEL) ((SI:LOCATION DEFUN C::SET-JUMP-TRUE) #P"SRC:CMP;CMPIF.LSP.NEWEST" . 5596))
C::SET-LOC
(((:LAMBDA-LIST) C::LOC &AUX C::FD) ((SI:LOCATION DEFUN C::SET-LOC) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 5505))
SET-MACRO-CHARACTER
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR FUNCTION &OPTIONAL (NON-TERMINATING-P NIL) (READTABLE *READTABLE*))

Registers CHAR as a macro character in READTABLE and makes FUNCTION the read
macro associated with CHAR.  When the ECL reader reads an object that begins
with CHAR, it calls FUNCTION with the input stream and CHAR as arguments.  If
FUNCTION returns a single value, it is returned as the value of the reader.
If FUNCTION returns no value, then the reader tries to read an object again.
NON-TERMINATING-P specifies whether CHAR is non-terminating or not (see
READTABLE).
Use GET-MACRO-CHARACTER to get the read macro associated with a character.
") ((:LAMBDA-LIST) CHAR FUNCTION &OPTIONAL (SI::NON-TERMINATING-P NIL) (READTABLE *READTABLE*)))
SET-PPRINT-DISPATCH
(((:LAMBDA-LIST) TYPE FUNCTION &OPTIONAL (SI::PRIORITY 0) (SI::TABLE *PRINT-PPRINT-DISPATCH*)) ((SI:LOCATION DEFUN SET-PPRINT-DISPATCH) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 41266))
C::SET-RETURN-LOC
(((:LAMBDA-LIST) C::LOC) ((SI:LOCATION DEFUN C::SET-RETURN-LOC) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 6748))
SET-SYNTAX-FROM-CHAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (TO-CHAR FROM-CHAR &OPTIONAL (TO-READTABLE *READTABLE*) (FROM-READTABLE NIL))

Replaces the information for TO-CHAR in TO-READTABLE with the information for
FROM-CHAR in FROM-READTABLE.  If FROM-READTABLE is NIL, then the standard
readtable is used.  TO-CHAR belongs to the same syntactic class as FROM-CHAR,
and if FROM-CHAR is a macro character, TO-CHAR inherits the read macro and
non-terminating-p flag of FROM-CHAR.  See READTABLE.
") ((:LAMBDA-LIST) SI::TO-CHAR SI::FROM-CHAR &OPTIONAL (SI::TO-READTABLE *READTABLE*) (SI::FROM-READTABLE NIL)))
C::SET-TRASH-LOC
(((:LAMBDA-LIST) C::LOC) ((SI:LOCATION DEFUN C::SET-TRASH-LOC) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 7099))
C::SET-UNKNOWN-LOC
(((:LAMBDA-LIST) C::LOC) ((SI:LOCATION DEFUN C::SET-UNKNOWN-LOC) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 5431))
C::SET-VALUE0-LOC
(((:LAMBDA-LIST) C::LOC) ((SI:LOCATION DEFUN C::SET-VALUE0-LOC) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 6661))
C::SET-VALUES-LOC
(((:LAMBDA-LIST) C::LOC) ((SI:LOCATION DEFUN C::SET-VALUES-LOC) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 6353))
C::SET-VAR
(((:LAMBDA-LIST) C::LOC C::VAR &AUX (C::VAR-LOC (C::VAR-LOC C::VAR))) ((SI:LOCATION DEFUN C::SET-VAR) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 8975))
C::SET-VV
(((:LAMBDA-LIST) C::LOC C::VV-LOC) ((SI:LOCATION DEFUN C::SET-VV) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 11771))
C::SET-VV-INDEX
(((:LAMBDA-LIST) C::LOC C::INDEX C::PERMANENT-P) ((SI:LOCATION DEFUN C::SET-VV-INDEX) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 11517))
SETF
(((DOCUMENTATION . FUNCTION) . "Syntax: (setf {place form}*)
Evaluates each FORM and assigns the value to the corresponding PLACE in order.
Returns the value of the last FORM.
Each PLACE may be any one of the following:
  * A symbol that names a variable.
  * A function call form whose first element is the name of the following
    functions:
	nth	elt	subseq	rest	first ... tenth
	c?r	c??r	c???r	c????r
	aref	svref	char	schar	bit	sbit	fill-pointer
	get	getf	documentation	symbol-value	symbol-function
	symbol-plist	macro-function	gethash		fdefinition
	char-bit	ldb	mask-field
	apply	slot-value
    where '?' stands for either 'a' or 'd'.
  * A function call form whose first element is:
        1. an access function for a structure slot
        1. an accessor method for a CLOS object
  * the form (THE type place) with PLACE being a place recognized by SETF.
  * a macro call which expands to a place recognized by SETF.
  * any form for which a DEFSETF or DEFINE-SETF-EXPANDER declaration has been
    made.") ((:LAMBDA-LIST) &ENVIRONMENT SI::ENV &REST REST) ((SI:LOCATION DEFMACRO SETF) #P"SRC:LSP;SETF.LSP.NEWEST" . 14440))
SI::SETF-EXPAND
(((:LAMBDA-LIST) SI::L SI::ENV) ((SI:LOCATION DEFUN SI::SETF-EXPAND) #P"SRC:LSP;SETF.LSP.NEWEST" . 14171))
SI::SETF-EXPAND-1
(((:LAMBDA-LIST) SI::PLACE SI::NEWVALUE SI::ENV) ((SI:LOCATION DEFUN SI::SETF-EXPAND-1) #P"SRC:LSP;SETF.LSP.NEWEST" . 12695))
CLOS::SETF-FIND-CLASS
(((:LAMBDA-LIST) CLOS::NEW-VALUE CLOS::NAME &OPTIONAL CLOS::ERRORP CLOS::ENV) ((SI:LOCATION DEFUN CLOS::SETF-FIND-CLASS) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 6127))
SI::SETF-STRUCTURE-ACCESS
(((:LAMBDA-LIST) SI::STRUCT TYPE SI::INDEX SI::NEWVALUE) ((SI:LOCATION DEFUN SI::SETF-STRUCTURE-ACCESS) #P"SRC:LSP;SETF.LSP.NEWEST" . 13851))
SETQ
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (setq {var form}*)

Evaluates each FORM and assigns the value to VAR in order.  Returns the value
of the last FORM.
") ((:LAMBDA-LIST) . "(setq {var form}*)"))
SEVENTH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CADDR (CDDDDR X)).
") ((:LAMBDA-LIST) SI::X))
SHADOW
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL &OPTIONAL (PACKAGE *PACKAGE*))

If no symbol is registered in PACKAGE with the same name as SYMBOL, then
creates an internal symbol with the same name and registers it into PACKAGE.
The created symbol shadows external symbols of the same name in those packages
that PACKAGE uses.  SYMBOL may be a list of symbols.
") ((:LAMBDA-LIST) SYMBOL &OPTIONAL (PACKAGE *PACKAGE*)))
SHADOWING-IMPORT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL &OPTIONAL (PACKAGE *PACKAGE*))

Registers SYMBOL as an internal symbol of PACKAGE.  Does nothing if SYMBOL is
already registered in PACKAGE.  If there exists already a symbol in PACKAGE
with the same name, then uninterns the symbol first.  SYMBOL shadows external
symbols of the same name in those packages that PACKAGE uses.  SYMBOL may be a
list of symbols.
") ((:LAMBDA-LIST) SYMBOL &OPTIONAL (PACKAGE *PACKAGE*)))
C::SHARED-CC
(((:LAMBDA-LIST) C::O-PATHNAME C::OBJECT-FILES) ((SI:LOCATION DEFUN C::SHARED-CC) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 5556))
SHARED-INITIALIZE
(((SI:LOCATION DEFMETHOD SHARED-INITIALIZE (CLOS::GFUN STANDARD-GENERIC-FUNCTION) CLOS::SLOT-NAMES &REST CLOS::INITARGS) #P"SRC:CLOS;GENERIC.LSP.NEWEST" . 6737) ((SI:LOCATION DEFMETHOD SHARED-INITIALIZE (CLOS::GFUN GENERIC-FUNCTION) CLOS::SLOT-NAMES &REST CLOS::INITARGS &KEY (CLOS::LAMBDA-LIST NIL CLOS::L-L-P) (CLOS::ARGUMENT-PRECEDENCE-ORDER NIL CLOS::A-O-P) (DOCUMENTATION NIL) (CLOS::DECLARATIONS NIL) METHOD-COMBINATION (CLOS::METHOD-CLASS (FIND-CLASS 'METHOD))) #P"SRC:CLOS;GENERIC.LSP.NEWEST" . 4388) ((SI:LOCATION DEFMETHOD SHARED-INITIALIZE (METHOD STANDARD-METHOD) CLOS::SLOT-NAMES &REST CLOS::INITARGS) #P"SRC:CLOS;STDMETHOD.LSP.NEWEST" . 2025) ((SI:LOCATION DEFMETHOD SHARED-INITIALIZE (CLASS CLOS::STD-CLASS) CLOS::SLOT-NAMES &REST CLOS::INITARGS &KEY (CLOS::OPTIMIZE-SLOT-ACCESS (LIST CLOS:*OPTIMIZE-SLOT-ACCESS*)) CLOS::SEALEDP) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 7651) ((SI:LOCATION DEFMETHOD SHARED-INITIALIZE (CLOS::INSTANCE T) CLOS::SLOT-NAMES &REST CLOS::INITARGS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 1127))
SI::SHARP-!-READER
(((:LAMBDA-LIST) STREAM SI::SUBCHAR SI::ARG) ((SI:LOCATION DEFUN SI::SHARP-!-READER) #P"SRC:LSP;MISLIB.LSP.NEWEST" . 10670))
SI:SHARP-A-READER
(((:LAMBDA-LIST) STREAM SI::SUBCHAR SI::ARG) ((SI:LOCATION DEFUN SI:SHARP-A-READER) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 6662))
SI:SHARP-S-READER
(((:LAMBDA-LIST) STREAM SI::SUBCHAR SI::ARG) ((SI:LOCATION DEFUN SI:SHARP-S-READER) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 7515))
SHIFTF
(((DOCUMENTATION . FUNCTION) . "Syntax: (shiftf {place}+ form)
Saves the values of PLACE and FORM, and then assigns the value of each PLACE
to the PLACE on its left.  The rightmost PLACE gets the value of FORM.
Returns the original value of the leftmost PLACE.") ((:LAMBDA-LIST) &ENVIRONMENT SI::ENV &REST REST) ((SI:LOCATION DEFMACRO SHIFTF) #P"SRC:LSP;SETF.LSP.NEWEST" . 16696))
SHORT-FLOAT
(((DOCUMENTATION . TYPE) . "
A short-float is a short-precision floating point number."))
SHORT-FLOAT-EPSILON
(((SI:LOCATION DEFCONSTANT SHORT-FLOAT-EPSILON) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 625) ((DOCUMENTATION . VARIABLE) . "The smallest postive short-float E that satisfies
	(not (= (float 1 E) (+ (float 1 E) E)))"))
SHORT-FLOAT-NEGATIVE-EPSILON
(((SI:LOCATION DEFCONSTANT SHORT-FLOAT-NEGATIVE-EPSILON) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 625) ((DOCUMENTATION . VARIABLE) . "The smallest positive short-float E that satisfies
	(not (= (float 1 E) (- (float 1 E) E)))"))
SI:SHORT-FLOAT-NEGATIVE-INFINITY
(((SI:LOCATION DEFCONSTANT SI:SHORT-FLOAT-NEGATIVE-INFINITY) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 2925))
SI:SHORT-FLOAT-POSITIVE-INFINITY
(((SI:LOCATION DEFCONSTANT SI:SHORT-FLOAT-POSITIVE-INFINITY) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 2925))
SHORT-SITE-NAME
(((DOCUMENTATION . FUNCTION) . "Args: ()
Returns, as a string, the location of the machine on which ECL runs.") ((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SHORT-SITE-NAME) #P"BUILD:LSP;CONFIG.LSP.NEWEST" . 729))
SI:SHRINK-VECTOR
(((DOCUMENTATION . FUNCTION) . "Shrinks a vector.") ((:LAMBDA-LIST) SI::VEC SI::LEN) ((SI:LOCATION DEFUN SI:SHRINK-VECTOR) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 16289))
SIGNAL
(((:LAMBDA-LIST) SI::DATUM &REST SI::ARGUMENTS) ((SI:LOCATION DEFUN SIGNAL) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 11658))
SI:SIGNAL-SIMPLE-ERROR
(((:LAMBDA-LIST) SI::BASE-CONDITION SI::CONTINUE-MESSAGE SI::FORMAT-CONTROL SI::FORMAT-ARGS &REST SI::ARGS) ((SI:LOCATION DEFUN SI:SIGNAL-SIMPLE-ERROR) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21863))
SIGNED-BYTE
(((DOCUMENTATION . TYPE) . "As a type specifier, (SIGNED-BYTE n) specifies those integers that can be
represented with N bits in 2's complement representation."))
SIGNUM
(((DOCUMENTATION . FUNCTION) . "Args: (number)
Returns a number that represents the sign of NUMBER.  Returns NUMBER If it is
zero.  Otherwise, returns the value of (/ NUMBER (ABS NUMBER))") ((:LAMBDA-LIST) SI::X) ((SI:LOCATION DEFUN SIGNUM) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 4579))
SIMPLE-ARRAY
(((DOCUMENTATION . TYPE) . "
A simple-array is an array that is not displaced to another array, has no
fill-pointer, and is not adjustable."))
SI::SIMPLE-ARRAY-P
(((:LAMBDA-LIST) SI::X) ((SI:LOCATION DEFUN SI::SIMPLE-ARRAY-P) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 10440))
SIMPLE-BASE-STRING
(((DOCUMENTATION . TYPE) . "A base-string which cannot be adjusted nor displaced."))
SIMPLE-BIT-VECTOR
(((DOCUMENTATION . TYPE) . "A bit-vector that is not displaced to another array, has no fill-pointer,
and is not adjustable."))
SIMPLE-BIT-VECTOR-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a simple-bit-vector; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
SIMPLE-CONDITION
(((SI:LOCATION DEFCLASS SIMPLE-CONDITION) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
SIMPLE-ERROR
(((SI:LOCATION DEFCLASS SIMPLE-ERROR) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
SI::SIMPLE-MEMBER-TYPE
(((:LAMBDA-LIST) SI::OBJECT) ((SI:LOCATION DEFUN SI::SIMPLE-MEMBER-TYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 30219))
C::SIMPLE-OPTIMIZER-FUNCTION
(((:LAMBDA-LIST) C::NAME C::ARGS C::INLINE-FORM) ((SI:LOCATION DEFUN C::SIMPLE-OPTIMIZER-FUNCTION) #P"SRC:CMP;CMPOPT-CONS.LSP.NEWEST" . 1006))
SI:SIMPLE-PROGRAM-ERROR
(((:LAMBDA-LIST) SI::MESSAGE &REST SI::DATUM) ((SI:LOCATION DEFUN SI:SIMPLE-PROGRAM-ERROR) #P"SRC:LSP;MISLIB.LSP.NEWEST" . 10803))
SIMPLE-STRING
(((DOCUMENTATION . TYPE) . "A simple-string is a string that is not displaced to another array, has no
fill-pointer, and is not adjustable."))
SIMPLE-STRING-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a simple-string; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
SI::SIMPLE-STYLE-WARNING
(((SI:LOCATION DEFCLASS SI::SIMPLE-STYLE-WARNING) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
SI::SIMPLE-TERMINAL-INTERRUPT
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::SIMPLE-TERMINAL-INTERRUPT) #P"SRC:LSP;TOP.LSP.NEWEST" . 17618))
SIMPLE-TYPE-ERROR
(((SI:LOCATION DEFCLASS SIMPLE-TYPE-ERROR) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
SIMPLE-VECTOR
(((DOCUMENTATION . TYPE) . "A simple-vector is a vector that is not displaced to another array, has no
fill-pointer, and is not adjustable."))
SIMPLE-VECTOR-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a simple-vector; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
SIMPLE-WARNING
(((SI:LOCATION DEFCLASS SIMPLE-WARNING) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
C::SIMPLIFY-ARITHMETIC
(((:LAMBDA-LIST) C::OPERATOR C::ARGS C::WHOLE) ((SI:LOCATION DEFUN C::SIMPLIFY-ARITHMETIC) #P"SRC:CMP;CMPNUM.LSP.NEWEST" . 525))
SIN
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (RADIANS)

Returns the sine of RADIANS.
") ((:LAMBDA-LIST) SI::RADIANS))
SINGLE-FLOAT
(((DOCUMENTATION . TYPE) . "
A single-float is a single-precision floating point number.
SINGLE-FLOAT as a type specifier is equivalent to LONG-FLOAT in ECL."))
SINGLE-FLOAT-EPSILON
(((SI:LOCATION DEFCONSTANT SINGLE-FLOAT-EPSILON) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 625) ((DOCUMENTATION . VARIABLE) . "The smallest postive single-float E that satisfies
	(not (= (float 1 E) (+ (float 1 E) E)))"))
SINGLE-FLOAT-NEGATIVE-EPSILON
(((SI:LOCATION DEFCONSTANT SINGLE-FLOAT-NEGATIVE-EPSILON) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 625) ((DOCUMENTATION . VARIABLE) . "The smallest positive single-float E that satisfies
	(not (= (float 1 E) (- (float 1 E) E)))"))
SI:SINGLE-FLOAT-NEGATIVE-INFINITY
(((SI:LOCATION DEFCONSTANT SI:SINGLE-FLOAT-NEGATIVE-INFINITY) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 2925))
SI:SINGLE-FLOAT-POSITIVE-INFINITY
(((SI:LOCATION DEFCONSTANT SI:SINGLE-FLOAT-POSITIVE-INFINITY) #P"SRC:LSP;NUMLIB.LSP.NEWEST" . 2925))
SI::SINGLE-THREADED-TERMINAL-INTERRUPT
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::SINGLE-THREADED-TERMINAL-INTERRUPT) #P"SRC:LSP;TOP.LSP.NEWEST" . 18509))
SINH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER)

Returns the hyperbolic sine of NUMBER.
") ((:LAMBDA-LIST) NUMBER))
SIXTH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CADR (CDDDDR X)).
") ((:LAMBDA-LIST) SI::X))
FFI:SIZE-OF-FOREIGN-TYPE
(((:LAMBDA-LIST) FFI::NAME) ((SI:LOCATION DEFUN FFI:SIZE-OF-FOREIGN-TYPE) #P"SRC:LSP;FFI.LSP.NEWEST" . 2992))
SI:SL-BOUNDP
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (OBJECT)

ECL/CLOS specific.
Returns nil if the OBJECT is not null.
") ((:LAMBDA-LIST) SI::OBJECT))
SI:SL-MAKUNBOUND
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (INSTANCE INDEX)

ECL/CLOS specific.
Removes the value associated with the INDEX-th slot of INSTANCE.
") ((:LAMBDA-LIST) SI:INSTANCE SI::INDEX))
SLEEP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (N)

Suspends execution for N seconds.  N may be any non-negative, non-complex
number.
") ((:LAMBDA-LIST) SI::N))
SLOT-BOUNDP
(((:LAMBDA-LIST) CLOS::SELF CLOS::SLOT-NAME) ((SI:LOCATION DEFUN SLOT-BOUNDP) #P"SRC:CLOS;BOOT.LSP.NEWEST" . 6870))
CLOS:SLOT-BOUNDP-USING-CLASS
(((SI:LOCATION DEFMETHOD CLOS:SLOT-BOUNDP-USING-CLASS (CLASS BUILT-IN-CLASS) CLOS::SELF CLOS::SLOTD) #P"SRC:CLOS;BUILTIN.LSP.NEWEST" . 4115) ((SI:LOCATION DEFMETHOD CLOS:SLOT-BOUNDP-USING-CLASS (CLASS CLASS) CLOS::SELF CLOS::SLOTD) #P"SRC:CLOS;BOOT.LSP.NEWEST" . 8933))
CLOS:SLOT-DEFINITION
(((SI:LOCATION DEFCLASS CLOS:SLOT-DEFINITION) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 1919))
CLOS::SLOT-DEFINITION-TO-PLIST
(((:LAMBDA-LIST) CLOS::SLOTD) ((SI:LOCATION DEFUN CLOS::SLOT-DEFINITION-TO-PLIST) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 14746))
SLOT-EXISTS-P
(((:LAMBDA-LIST) CLOS::SELF CLOS::SLOT-NAME) ((SI:LOCATION DEFUN SLOT-EXISTS-P) #P"SRC:CLOS;BOOT.LSP.NEWEST" . 7636))
CLOS::SLOT-EXISTS-P-USING-CLASS
(((SI:LOCATION DEFMETHOD CLOS::SLOT-EXISTS-P-USING-CLASS (CLASS BUILT-IN-CLASS) CLOS::SELF CLOS::SLOTD) #P"SRC:CLOS;BUILTIN.LSP.NEWEST" . 4563))
SLOT-MAKUNBOUND
(((:LAMBDA-LIST) CLOS::SELF CLOS::SLOT-NAME) ((SI:LOCATION DEFUN SLOT-MAKUNBOUND) #P"SRC:CLOS;BOOT.LSP.NEWEST" . 7384))
CLOS:SLOT-MAKUNBOUND-USING-CLASS
(((SI:LOCATION DEFMETHOD CLOS:SLOT-MAKUNBOUND-USING-CLASS (CLASS BUILT-IN-CLASS) CLOS::SELF CLOS::SLOTD) #P"SRC:CLOS;BUILTIN.LSP.NEWEST" . 3960) ((SI:LOCATION DEFMETHOD CLOS:SLOT-MAKUNBOUND-USING-CLASS (CLASS CLASS) CLOS::INSTANCE CLOS::SLOTD) #P"SRC:CLOS;BOOT.LSP.NEWEST" . 9165))
SLOT-MISSING
(((SI:LOCATION DEFMETHOD SLOT-MISSING (CLASS T) CLOS::OBJECT CLOS::SLOT-NAME CLOS::OPERATION &OPTIONAL CLOS::NEW-VALUE) #P"SRC:CLOS;BOOT.LSP.NEWEST" . 9667))
FFI::SLOT-POSITION
(((:LAMBDA-LIST) TYPE FFI::FIELD) ((SI:LOCATION DEFUN FFI::SLOT-POSITION) #P"SRC:LSP;FFI.LSP.NEWEST" . 6832))
CLOS::SLOT-TABLE
(((SI:LOCATION DEFINE-COMPILER-MACRO CLOS::SLOT-TABLE) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 4457) ((:LAMBDA-LIST) CLOS::OBJ) ((SI:LOCATION DEFUN CLOS::SLOT-TABLE) #P"SRC:CLOS;KERNEL.LSP.NEWEST" . 3373))
SLOT-UNBOUND
(((SI:LOCATION DEFMETHOD SLOT-UNBOUND (CLASS T) CLOS::OBJECT CLOS::SLOT-NAME) #P"SRC:CLOS;BOOT.LSP.NEWEST" . 9849))
SLOT-VALUE
(((:LAMBDA-LIST) CLOS::SELF CLOS::SLOT-NAME) ((SI:LOCATION DEFUN SLOT-VALUE) #P"SRC:CLOS;BOOT.LSP.NEWEST" . 6633))
CLOS:SLOT-VALUE-USING-CLASS
(((SI:LOCATION DEFMETHOD CLOS:SLOT-VALUE-USING-CLASS (CLASS BUILT-IN-CLASS) CLOS::SELF CLOS::SLOTD) #P"SRC:CLOS;BUILTIN.LSP.NEWEST" . 4262) ((SI:LOCATION DEFMETHOD CLOS:SLOT-VALUE-USING-CLASS (CLASS CLASS) CLOS::SELF CLOS::SLOTD) #P"SRC:CLOS;BOOT.LSP.NEWEST" . 8715))
SOFTWARE-TYPE
(((DOCUMENTATION . FUNCTION) . "Args: ()
Returns, as a string, the type of the software under which ECL runs.") ((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SOFTWARE-TYPE) #P"BUILD:LSP;CONFIG.LSP.NEWEST" . 1947))
SOFTWARE-VERSION
(((DOCUMENTATION . FUNCTION) . "Args: ()
Returns, as a string, the version of the software under which ECL runs.") ((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SOFTWARE-VERSION) #P"BUILD:LSP;CONFIG.LSP.NEWEST" . 2100))
SOME
(((DOCUMENTATION . FUNCTION) . "Args: (predicate sequence &rest more-sequences)
Returns T if at least one of the elements in SEQUENCEs satisfies PREDICATE;
NIL otherwise.") ((:LAMBDA-LIST) SI::PREDICATE SEQUENCE &REST SI::MORE-SEQUENCES) ((SI:LOCATION DEFUN SOME) #P"SRC:LSP;SEQ.LSP.NEWEST" . 10374))
SORT
(((DOCUMENTATION . FUNCTION) . "Args: (sequence test &key key)
Destructively sorts SEQUENCE and returns the result.  TEST should return non-
NIL if its first argument is to precede its second argument.  The order of two
elements X and Y is arbitrary if both
	(FUNCALL TEST X Y)
	(FUNCALL TEST Y X)
evaluates to NIL.  See STABLE-SORT.") ((:LAMBDA-LIST) SEQUENCE SI::PREDICATE &KEY SI::KEY) ((SI:LOCATION DEFUN SORT) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 32560))
SPECIAL-OPERATOR-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL)

Returns T if SYMBOL names a special form; NIL otherwise.
The special forms defined in Common Lisp are:
	block		if			progv
	catch		labels			quote
	compiler-let	let			return-from
	declare		let*			setq
	eval-when	macrolet		tagbody
	flet		multiple-value-call	the
	function	multiple-value-prog1	throw
	go		progn			unwind-protect
In addition, ECL implements the following macros as special forms, though of
course macro-expanding functions such as MACROEXPAND work correctly for these
macros.
	and		incf			prog1
	case		locally			prog2
	cond		loop			psetq
	decf		multiple-value-bind	push
	defmacro	multiple-value-list	return
	defun		multiple-value-set	setf
	do		or			unless
	do*		pop			when
	dolist		prog
	dotimes		prog*
") ((:LAMBDA-LIST) SYMBOL))
C::SPECIAL-VARIABLE-P
(((:LAMBDA-LIST) C::NAME) ((SI:LOCATION DEFUN C::SPECIAL-VARIABLE-P) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 5011))
SI:SPECIALP
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (SYMBOL)

ECL specific.
Returns T if the SYMBOL names a globally special variable; NIL otherwise.
") ((:LAMBDA-LIST) SYMBOL))
C::SPLIT-PROGRAM-OPTIONS
(((:LAMBDA-LIST) STRING) ((SI:LOCATION DEFUN C::SPLIT-PROGRAM-OPTIONS) #P"SRC:CMP;CMPOS-RUN.LSP.NEWEST" . 2072))
C::SPLIT-VALUES-TYPE
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN C::SPLIT-VALUES-TYPE) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 5414))
SQRT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER)

Returns the square root of the arg.
") ((:LAMBDA-LIST) NUMBER))
STABLE-SORT
(((DOCUMENTATION . FUNCTION) . "Args: (sequence test &key key)
Destructively sorts SEQUENCE and returns the result.  TEST should return non-
NIL if its first argument is to precede its second argument.  For two elements
X and Y, if both
	(FUNCALL TEST X Y)
	(FUNCALL TEST Y X)
evaluates to NIL, then the order of X and Y are the same as in the original
SEQUENCE.  See SORT.") ((:LAMBDA-LIST) SEQUENCE SI::PREDICATE &KEY SI::KEY) ((SI:LOCATION DEFUN STABLE-SORT) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 35813))
SI:STACK-OVERFLOW
(((SI:LOCATION DEFCLASS SI:STACK-OVERFLOW) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
CLOS:STANDARD-ACCESSOR-METHOD
(((SI:LOCATION DEFCLASS CLOS:STANDARD-ACCESSOR-METHOD) #P"SRC:CLOS;STDMETHOD.LSP.NEWEST" . 1725))
STANDARD-CHAR
(((DOCUMENTATION . TYPE) . "
A standard-char is a space character (#\\Space), a newline character
(#\\Newline,) or a character that represents one of the following letters.
	!  \"  #  $  %  &  '  (  )  *  +  ,  -  .  /  0  1  2  3  4
	5  6  7  8  9  :  ;  <  =  >  ?  @  A  B  C  D  E  F  G  H
	I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  [  \\
	]  ^  _  `  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p
	q  r  s  t  u  v  w  x  y  z  {  |  }  ~~"))
STANDARD-CHAR-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR)

Returns T if CHAR is a standard-char; NIL otherwise.
") ((:LAMBDA-LIST) CHAR))
CLOS::STANDARD-COMPUTE-EFFECTIVE-METHOD
(((:LAMBDA-LIST) CLOS::GF CLOS::METHODS) ((SI:LOCATION DEFUN CLOS::STANDARD-COMPUTE-EFFECTIVE-METHOD) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 5426))
CLOS:STANDARD-DIRECT-SLOT-DEFINITION
(((SI:LOCATION DEFCLASS CLOS:STANDARD-DIRECT-SLOT-DEFINITION) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 1919))
CLOS:STANDARD-EFFECTIVE-SLOT-DEFINITION
(((SI:LOCATION DEFCLASS CLOS:STANDARD-EFFECTIVE-SLOT-DEFINITION) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 1919))
STANDARD-GENERIC-FUNCTION
(((SI:LOCATION DEFCLASS STANDARD-GENERIC-FUNCTION) #P"SRC:CLOS;STDMETHOD.LSP.NEWEST" . 989))
CLOS::STANDARD-INSTANCE-GET
(((:LAMBDA-LIST) CLOS::INSTANCE CLOS::SLOTD) ((SI:LOCATION DEFUN CLOS::STANDARD-INSTANCE-GET) #P"SRC:CLOS;BOOT.LSP.NEWEST" . 7822))
CLOS::STANDARD-INSTANCE-SET
(((:LAMBDA-LIST) CLOS::VAL CLOS::INSTANCE CLOS::SLOTD) ((SI:LOCATION DEFUN CLOS::STANDARD-INSTANCE-SET) #P"SRC:CLOS;BOOT.LSP.NEWEST" . 8255))
CLOS::STANDARD-MAIN-EFFECTIVE-METHOD
(((:LAMBDA-LIST) CLOS::BEFORE CLOS::PRIMARY CLOS::AFTER) ((SI:LOCATION DEFUN CLOS::STANDARD-MAIN-EFFECTIVE-METHOD) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 4931))
STANDARD-METHOD
(((SI:LOCATION DEFCLASS STANDARD-METHOD) #P"SRC:CLOS;STDMETHOD.LSP.NEWEST" . 1332))
CLOS:STANDARD-READER-METHOD
(((SI:LOCATION DEFCLASS CLOS:STANDARD-READER-METHOD) #P"SRC:CLOS;STDMETHOD.LSP.NEWEST" . 1895))
CLOS:STANDARD-SLOT-DEFINITION
(((SI:LOCATION DEFCLASS CLOS:STANDARD-SLOT-DEFINITION) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 1919))
CLOS:STANDARD-WRITER-METHOD
(((SI:LOCATION DEFCLASS CLOS:STANDARD-WRITER-METHOD) #P"SRC:CLOS;STDMETHOD.LSP.NEWEST" . 1960))
SI::START-LOGICAL-BLOCK
(((:LAMBDA-LIST) STREAM SI::PREFIX SI::PER-LINE-P SI::SUFFIX) ((SI:LOCATION DEFUN SI::START-LOGICAL-BLOCK) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 12642))
C::STATIC-BASE-STRING-BUILDER
(((:LAMBDA-LIST) C::NAME C::VALUE STREAM) ((SI:LOCATION DEFUN C::STATIC-BASE-STRING-BUILDER) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 7584))
C::STATIC-COMPLEX-BUILDER
(((:LAMBDA-LIST) C::NAME C::VALUE STREAM) ((SI:LOCATION DEFUN C::STATIC-COMPLEX-BUILDER) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 8860))
C::STATIC-CONSTANT-BUILDER
(((:LAMBDA-LIST) FORMAT C::VALUE) ((SI:LOCATION DEFUN C::STATIC-CONSTANT-BUILDER) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 9664))
C::STATIC-CONSTANT-DELEGATE
(((:LAMBDA-LIST) C::NAME C::VALUE STREAM) ((SI:LOCATION DEFUN C::STATIC-CONSTANT-DELEGATE) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 8737))
C::STATIC-CONSTANT-EXPRESSION
(((:LAMBDA-LIST) FFI:OBJECT) ((SI:LOCATION DEFUN C::STATIC-CONSTANT-EXPRESSION) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 9775))
C::STATIC-DOUBLE-FLOAT-BUILDER
(((:LAMBDA-LIST) C::NAME C::VALUE STREAM) ((SI:LOCATION DEFUN C::STATIC-DOUBLE-FLOAT-BUILDER) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 8006))
C::STATIC-LIB-AR
(((:LAMBDA-LIST) C::LIB C::OBJECT-FILES) ((SI:LOCATION DEFUN C::STATIC-LIB-AR) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 5346))
C::STATIC-LONG-FLOAT-BUILDER
(((:LAMBDA-LIST) C::NAME C::VALUE STREAM) ((SI:LOCATION DEFUN C::STATIC-LONG-FLOAT-BUILDER) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 8231))
C::STATIC-RATIONAL-BUILDER
(((:LAMBDA-LIST) C::NAME C::VALUE STREAM) ((SI:LOCATION DEFUN C::STATIC-RATIONAL-BUILDER) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 8464))
C::STATIC-SINGLE-FLOAT-BUILDER
(((:LAMBDA-LIST) C::NAME C::VALUE STREAM) ((SI:LOCATION DEFUN C::STATIC-SINGLE-FLOAT-BUILDER) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 7781))
CLOS::STD-CLASS-ACCESSORS
(((:LAMBDA-LIST) CLOS::SLOT-NAME) ((SI:LOCATION DEFUN CLOS::STD-CLASS-ACCESSORS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 25589))
CLOS::STD-CLASS-COMPUTE-SLOTS
(((:LAMBDA-LIST) CLASS CLOS::SLOTS) ((SI:LOCATION DEFUN CLOS::STD-CLASS-COMPUTE-SLOTS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 21122))
CLOS::STD-CLASS-GENERATE-ACCESSORS
(((:LAMBDA-LIST) STANDARD-CLASS &AUX CLOS::OPTIMIZABLE) ((SI:LOCATION DEFUN CLOS::STD-CLASS-GENERATE-ACCESSORS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 25871))
CLOS::STD-CLASS-OPTIMIZED-ACCESSORS
(((:LAMBDA-LIST) CLOS::SLOT-NAME) ((SI:LOCATION DEFUN CLOS::STD-CLASS-OPTIMIZED-ACCESSORS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 23585))
CLOS::STD-CLASS-SEALED-ACCESSORS
(((:LAMBDA-LIST) CLOS::INDEX) ((SI:LOCATION DEFUN CLOS::STD-CLASS-SEALED-ACCESSORS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 25039))
CLOS::STD-CREATE-SLOTS-TABLE
(((:LAMBDA-LIST) CLASS) ((SI:LOCATION DEFUN CLOS::STD-CREATE-SLOTS-TABLE) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 13313))
STEP
(((DOCUMENTATION . FUNCTION) . "Syntax: (step form)
Evaluates FORM in the Stepper mode and returns all its values.  See ECL Report
for Stepper mode commands.") ((:LAMBDA-LIST) SI::FORM) ((SI:LOCATION DEFMACRO STEP) #P"SRC:LSP;TRACE.LSP.NEWEST" . 8899))
SI::STEP*
(((:LAMBDA-LIST) SI::FORM) ((SI:LOCATION DEFUN SI::STEP*) #P"SRC:LSP;TRACE.LSP.NEWEST" . 9069))
SI::STEP-COMMANDS
(((SI:LOCATION DEFCONSTANT SI::STEP-COMMANDS) #P"SRC:LSP;TRACE.LSP.NEWEST" . 7449))
SI::STEP-NEXT
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::STEP-NEXT) #P"SRC:LSP;TRACE.LSP.NEWEST" . 10259))
SI::STEP-PRINT
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::STEP-PRINT) #P"SRC:LSP;TRACE.LSP.NEWEST" . 10396))
SI::STEP-QUIT
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::STEP-QUIT) #P"SRC:LSP;TRACE.LSP.NEWEST" . 10515))
SI::STEP-SKIP
(((:LAMBDA-LIST) &OPTIONAL (WHEN 0)) ((SI:LOCATION DEFUN SI::STEP-SKIP) #P"SRC:LSP;TRACE.LSP.NEWEST" . 10306))
SI::STEPPABLE-FUNCTION
(((:LAMBDA-LIST) SI::FORM) ((SI:LOCATION DEFUN SI::STEPPABLE-FUNCTION) #P"SRC:LSP;TRACE.LSP.NEWEST" . 9269))
SI:STEPPER
(((:LAMBDA-LIST) SI::FORM) ((SI:LOCATION DEFUN SI:STEPPER) #P"SRC:LSP;TRACE.LSP.NEWEST" . 9600))
STORAGE-CONDITION
(((SI:LOCATION DEFCLASS STORAGE-CONDITION) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
SI:STORAGE-EXHAUSTED
(((SI:LOCATION DEFCLASS SI:STORAGE-EXHAUSTED) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
STORE-VALUE
(((:LAMBDA-LIST) SI::VALUE &OPTIONAL SI::C) ((SI:LOCATION DEFUN STORE-VALUE) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 24387))
STREAM
(((DOCUMENTATION . TYPE) . "
A stream is a source of input or a destination of output.  The following kinds
of streams are supported.
	file streams
	string-input streams
	string-output streams
	two-way streams
	echo streams
	synonym streams
	concatenated streams
	broadcast streams
Basically, file streams are created by OPEN and other kinds of streams are
created by MAKE-...-STREAM.  See these functions."))
GRAY:STREAM-ADVANCE-TO-COLUMN
(((SI:LOCATION DEFMETHOD GRAY:STREAM-ADVANCE-TO-COLUMN (STREAM GRAY:FUNDAMENTAL-CHARACTER-OUTPUT-STREAM) GRAY::COLUMN) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 10790) ((:LAMBDA-LIST) STREAM GRAY::COLUMN) ((SI:LOCATION DEFGENERIC GRAY:STREAM-ADVANCE-TO-COLUMN) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 955))
SI::STREAM-CLEAR-INPUT
(((DOCUMENTATION . FUNCTION) . "Generic function in SI package:
Args: ((OBJ STREAM-CLASS))

Clears any buffered characters received from the CLOS stream OBJ.
Returns NIL.
") ((:LAMBDA-LIST) (SI::OBJ SI::STREAM-CLASS)))
GRAY:STREAM-CLEAR-INPUT
(((SI:LOCATION DEFMETHOD GRAY:STREAM-CLEAR-INPUT (STREAM T)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 11266) ((SI:LOCATION DEFMETHOD GRAY:STREAM-CLEAR-INPUT (STREAM SI:ANSI-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 11185) ((SI:LOCATION DEFMETHOD GRAY:STREAM-CLEAR-INPUT (STREAM GRAY:FUNDAMENTAL-CHARACTER-INPUT-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 11102) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:STREAM-CLEAR-INPUT) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 1440))
GRAY:STREAM-CLEAR-OUTPUT
(((SI:LOCATION DEFMETHOD GRAY:STREAM-CLEAR-OUTPUT (STREAM SI::PRETTY-STREAM)) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 5455) ((SI:LOCATION DEFMETHOD GRAY:STREAM-CLEAR-OUTPUT (STREAM T)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 11532) ((SI:LOCATION DEFMETHOD GRAY:STREAM-CLEAR-OUTPUT (STREAM SI:ANSI-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 11449) ((SI:LOCATION DEFMETHOD GRAY:STREAM-CLEAR-OUTPUT (STREAM GRAY:FUNDAMENTAL-OUTPUT-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 11374) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:STREAM-CLEAR-OUTPUT) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 1607))
SI::STREAM-CLEAR-OUTPUT
(((DOCUMENTATION . FUNCTION) . "Generic function in SI package:
Args: ((OBJ STREAM-CLASS))

Aborts any outstanding output operation on the CLOS stream OBJ
and returns NIL .
") ((:LAMBDA-LIST) (SI::OBJ SI::STREAM-CLASS)))
GRAY:STREAM-ELEMENT-TYPE
(((SI:LOCATION DEFMETHOD GRAY:STREAM-ELEMENT-TYPE (STREAM T)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 12122) ((SI:LOCATION DEFMETHOD GRAY:STREAM-ELEMENT-TYPE (STREAM SI:ANSI-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 12032) ((SI:LOCATION DEFMETHOD GRAY:STREAM-ELEMENT-TYPE (STREAM GRAY:FUNDAMENTAL-CHARACTER-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 11947) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:STREAM-ELEMENT-TYPE) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 2044))
STREAM-ELEMENT-TYPE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STREAM)

Returns the type specifier for the io unit of STREAM.
") ((:LAMBDA-LIST) STREAM))
STREAM-ERROR
(((SI:LOCATION DEFCLASS STREAM-ERROR) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
GRAY:STREAM-FILE-DESCRIPTOR
(((SI:LOCATION DEFMETHOD GRAY:STREAM-FILE-DESCRIPTOR (STREAM FILE-STREAM) &OPTIONAL (GRAY::DIRECTION :INPUT)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 21201) ((SI:LOCATION DEFMETHOD GRAY:STREAM-FILE-DESCRIPTOR (STREAM TWO-WAY-STREAM) &OPTIONAL (GRAY::DIRECTION :INPUT)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 20875) ((SI:LOCATION DEFMETHOD GRAY:STREAM-FILE-DESCRIPTOR STREAM &OPTIONAL GRAY::DIRECTION) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 20731) ((SI:LOCATION DEFMETHOD GRAY:STREAM-FILE-DESCRIPTOR :BEFORE STREAM &OPTIONAL (GRAY::DIRECTION :INPUT)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 19822) ((:LAMBDA-LIST) STREAM &OPTIONAL GRAY::DIRECTION) ((SI:LOCATION DEFGENERIC GRAY:STREAM-FILE-DESCRIPTOR) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 8319))
GRAY:STREAM-FILE-POSITION
(((SI:LOCATION DEFMETHOD GRAY:STREAM-FILE-POSITION (STREAM T) &OPTIONAL POSITION) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 17455) ((SI:LOCATION DEFMETHOD GRAY:STREAM-FILE-POSITION (STREAM SI:ANSI-STREAM) &OPTIONAL POSITION) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 17346) ((:LAMBDA-LIST) STREAM &OPTIONAL POSITION) ((SI:LOCATION DEFGENERIC GRAY:STREAM-FILE-POSITION) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 8179))
GRAY:STREAM-FINISH-OUTPUT
(((SI:LOCATION DEFMETHOD GRAY:STREAM-FINISH-OUTPUT (STREAM T)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 12393) ((SI:LOCATION DEFMETHOD GRAY:STREAM-FINISH-OUTPUT (STREAM SI:ANSI-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 12308) ((SI:LOCATION DEFMETHOD GRAY:STREAM-FINISH-OUTPUT (STREAM GRAY:FUNDAMENTAL-OUTPUT-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 12232) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:STREAM-FINISH-OUTPUT) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 2276))
GRAY:STREAM-FORCE-OUTPUT
(((SI:LOCATION DEFMETHOD GRAY:STREAM-FORCE-OUTPUT (STREAM SI::PRETTY-STREAM)) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 5358) ((SI:LOCATION DEFMETHOD GRAY:STREAM-FORCE-OUTPUT (STREAM T)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 12663) ((SI:LOCATION DEFMETHOD GRAY:STREAM-FORCE-OUTPUT (STREAM SI:ANSI-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 12580) ((SI:LOCATION DEFMETHOD GRAY:STREAM-FORCE-OUTPUT (STREAM GRAY:FUNDAMENTAL-OUTPUT-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 12505) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:STREAM-FORCE-OUTPUT) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 2519))
SI::STREAM-FORCE-OUTPUT
(((DOCUMENTATION . FUNCTION) . "Generic function in SI package:
Args: ((OBJ STREAM-CLASS))

Initiates the emptying of internal buffers on the CLOS stream OBJ
and returns NIL.
") ((:LAMBDA-LIST) (SI::OBJ SI::STREAM-CLASS)))
SI::STREAM-FRESH-LINE
(((DOCUMENTATION . FUNCTION) . "Generic function in SI package:
Args: ((OBJ STREAM-CLASS))

Outputs a newline to the CLOS stream if and only if the CLOS stream OBJ
is not already at the beginning of a new line. Returns non-NIL if a
newline was output and NIL otherwise.
") ((:LAMBDA-LIST) (SI::OBJ SI::STREAM-CLASS)))
GRAY:STREAM-FRESH-LINE
(((SI:LOCATION DEFMETHOD GRAY:STREAM-FRESH-LINE (STREAM SI:ANSI-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 12921) ((SI:LOCATION DEFMETHOD GRAY:STREAM-FRESH-LINE (STREAM GRAY:FUNDAMENTAL-CHARACTER-OUTPUT-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 12771) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:STREAM-FRESH-LINE) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 2696))
GRAY:STREAM-INTERACTIVE-P
(((SI:LOCATION DEFMETHOD GRAY:STREAM-INTERACTIVE-P (STREAM T)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 13431) ((SI:LOCATION DEFMETHOD GRAY:STREAM-INTERACTIVE-P (STREAM SI:ANSI-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 13340) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:STREAM-INTERACTIVE-P) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 3158))
GRAY:STREAM-LINE-COLUMN
(((SI:LOCATION DEFMETHOD GRAY:STREAM-LINE-COLUMN (STREAM GRAY:FUNDAMENTAL-CHARACTER-OUTPUT-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 13542) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:STREAM-LINE-COLUMN) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 3268))
SI::STREAM-LISTEN
(((DOCUMENTATION . FUNCTION) . "Generic function in SI package:
Args: ((OBJ STREAM-CLASS))

Returns NIL if no character is immediately available from the CLOS stream.
Otherwise, the next character is returned, as if stream-peek-char
had been called.
") ((:LAMBDA-LIST) (SI::OBJ SI::STREAM-CLASS)))
GRAY:STREAM-LISTEN
(((SI:LOCATION DEFMETHOD GRAY:STREAM-LISTEN (STREAM T)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 13910) ((SI:LOCATION DEFMETHOD GRAY:STREAM-LISTEN (STREAM SI:ANSI-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 13839) ((SI:LOCATION DEFMETHOD GRAY:STREAM-LISTEN (STREAM GRAY:FUNDAMENTAL-CHARACTER-INPUT-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 13640) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:STREAM-LISTEN) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 3745))
GRAY::STREAM-P
(((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY::STREAM-P) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 3080))
SI::STREAM-PEEK-CHAR
(((DOCUMENTATION . FUNCTION) . "Generic function in SI package:
Args: ((OBJ STREAM-CLASS) PEEK-TYPE)

Returns the character object which would be returned by STREAM-READ-CHAR
but does not remove it from the input buffer.
If PEEK-TYPE is T, stream-peek-char skips over any whitespace characters,
removing them from the input buffer, and returns the next character.
") ((:LAMBDA-LIST) (SI::OBJ SI::STREAM-CLASS) SI::PEEK-TYPE))
GRAY:STREAM-PEEK-CHAR
(((SI:LOCATION DEFMETHOD GRAY:STREAM-PEEK-CHAR (STREAM T)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 14773) ((SI:LOCATION DEFMETHOD GRAY:STREAM-PEEK-CHAR (STREAM SI:ANSI-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 14696) ((SI:LOCATION DEFMETHOD GRAY:STREAM-PEEK-CHAR (STREAM GRAY:FUNDAMENTAL-CHARACTER-INPUT-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 14502) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:STREAM-PEEK-CHAR) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 4402))
GRAY:STREAM-READ-BYTE
(((SI:LOCATION DEFMETHOD GRAY:STREAM-READ-BYTE (STREAM T)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 14950) ((SI:LOCATION DEFMETHOD GRAY:STREAM-READ-BYTE (STREAM SI:ANSI-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 14874) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:STREAM-READ-BYTE) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 4650))
SI::STREAM-READ-CHAR
(((DOCUMENTATION . FUNCTION) . "Generic function in SI package:
Args: ((OBJ STREAM-CLASS))

Reads the next character object from the CLOS stream OBJ.
") ((:LAMBDA-LIST) (SI::OBJ SI::STREAM-CLASS)))
GRAY:STREAM-READ-CHAR
(((SI:LOCATION DEFMETHOD GRAY:STREAM-READ-CHAR (STREAM T)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 15127) ((SI:LOCATION DEFMETHOD GRAY:STREAM-READ-CHAR (STREAM SI:ANSI-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 15051) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:STREAM-READ-CHAR) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 4814))
GRAY:STREAM-READ-CHAR-NO-HANG
(((SI:LOCATION DEFMETHOD GRAY:STREAM-READ-CHAR-NO-HANG (STREAM T)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 15667) ((SI:LOCATION DEFMETHOD GRAY:STREAM-READ-CHAR-NO-HANG (STREAM SI:ANSI-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 15574) ((SI:LOCATION DEFMETHOD GRAY:STREAM-READ-CHAR-NO-HANG (STREAM GRAY:FUNDAMENTAL-CHARACTER-INPUT-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 15463) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:STREAM-READ-CHAR-NO-HANG) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 5099))
GRAY:STREAM-READ-LINE
(((SI:LOCATION DEFMETHOD GRAY:STREAM-READ-LINE (STREAM T)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 16411) ((SI:LOCATION DEFMETHOD GRAY:STREAM-READ-LINE (STREAM SI:ANSI-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 16334) ((SI:LOCATION DEFMETHOD GRAY:STREAM-READ-LINE (STREAM GRAY:FUNDAMENTAL-CHARACTER-INPUT-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 15784) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:STREAM-READ-LINE) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 5525))
SI::STREAM-READ-LINE
(((DOCUMENTATION . FUNCTION) . "Generic function in SI package:
Args: ((OBJ STREAM-CLASS) &REST MAKE-ARRAY-OPTIONS)

Reads character objects from the CLOS stream OBJ, up to and including the
next newline character, and returns them as a string (without the newline).
If given, the MAKE-ARRAY-OPTIONS arguments are passed to make-array
when the returned string is created.
") ((:LAMBDA-LIST) (SI::OBJ SI::STREAM-CLASS) &REST SI::MAKE-ARRAY-OPTIONS))
GRAY:STREAM-READ-SEQUENCE
(((SI:LOCATION DEFMETHOD GRAY:STREAM-READ-SEQUENCE (STREAM T) SEQUENCE &OPTIONAL GRAY::START GRAY::END) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 17069) ((SI:LOCATION DEFMETHOD GRAY:STREAM-READ-SEQUENCE (STREAM SI:ANSI-STREAM) SEQUENCE &OPTIONAL (GRAY::START 0) (GRAY::END NIL)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 16918) ((SI:LOCATION DEFMETHOD GRAY:STREAM-READ-SEQUENCE (STREAM GRAY:FUNDAMENTAL-BINARY-INPUT-STREAM) SEQUENCE &OPTIONAL (GRAY::START 0) (GRAY::END NIL)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 16718) ((SI:LOCATION DEFMETHOD GRAY:STREAM-READ-SEQUENCE (STREAM GRAY:FUNDAMENTAL-CHARACTER-INPUT-STREAM) SEQUENCE &OPTIONAL (GRAY::START 0) (GRAY::END NIL)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 16516) ((:LAMBDA-LIST) STREAM SEQUENCE &OPTIONAL GRAY::START GRAY::END) ((SI:LOCATION DEFGENERIC GRAY:STREAM-READ-SEQUENCE) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 5822))
GRAY:STREAM-START-LINE-P
(((SI:LOCATION DEFMETHOD GRAY:STREAM-START-LINE-P (STREAM GRAY:FUNDAMENTAL-CHARACTER-OUTPUT-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 17210) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:STREAM-START-LINE-P) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 5972))
GRAY:STREAM-TERPRI
(((SI:LOCATION DEFMETHOD GRAY:STREAM-TERPRI (STREAM T)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 19720) ((SI:LOCATION DEFMETHOD GRAY:STREAM-TERPRI (STREAM SI:ANSI-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 19649) ((SI:LOCATION DEFMETHOD GRAY:STREAM-TERPRI (STREAM GRAY:FUNDAMENTAL-CHARACTER-OUTPUT-STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 19537) ((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFGENERIC GRAY:STREAM-TERPRI) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 6832))
SI::STREAM-UNREAD-CHAR
(((DOCUMENTATION . FUNCTION) . "Generic function in SI package:
Args: ((OBJ STREAM-CLASS) CHARACTER)

Unreads the character object.
CHARACTER will be the next character read by STREAM-READ-CHAR .
") ((:LAMBDA-LIST) (SI::OBJ SI::STREAM-CLASS) CHARACTER))
GRAY:STREAM-UNREAD-CHAR
(((SI:LOCATION DEFMETHOD GRAY:STREAM-UNREAD-CHAR (STREAM SI:ANSI-STREAM) CHARACTER) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 15330) ((:LAMBDA-LIST) STREAM CHARACTER) ((SI:LOCATION DEFGENERIC GRAY:STREAM-UNREAD-CHAR) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 7008))
GRAY:STREAM-WRITE-BYTE
(((SI:LOCATION DEFMETHOD GRAY:STREAM-WRITE-BYTE (STREAM T) INTEGER) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 17771) ((SI:LOCATION DEFMETHOD GRAY:STREAM-WRITE-BYTE (STREAM SI:ANSI-STREAM) INTEGER) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 17677) ((:LAMBDA-LIST) STREAM INTEGER) ((SI:LOCATION DEFGENERIC GRAY:STREAM-WRITE-BYTE) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 7253))
SI::STREAM-WRITE-CHAR
(((DOCUMENTATION . FUNCTION) . "Generic function in SI package:
Args: ((OBJ STREAM-CLASS) CHARACTER)

Outputs the CHARACTER to the CLOS stream OBJ and returns the CHARACTER.
") ((:LAMBDA-LIST) (SI::OBJ SI::STREAM-CLASS) CHARACTER))
GRAY:STREAM-WRITE-CHAR
(((SI:LOCATION DEFMETHOD GRAY:STREAM-WRITE-CHAR (STREAM SI::PRETTY-STREAM) CHAR) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 5265) ((SI:LOCATION DEFMETHOD GRAY:STREAM-WRITE-CHAR (STREAM T) CHARACTER) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 17981) ((SI:LOCATION DEFMETHOD GRAY:STREAM-WRITE-CHAR (STREAM SI:ANSI-STREAM) CHARACTER) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 17883) ((:LAMBDA-LIST) STREAM CHARACTER) ((SI:LOCATION DEFGENERIC GRAY:STREAM-WRITE-CHAR) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 7423))
GRAY:STREAM-WRITE-SEQUENCE
(((SI:LOCATION DEFMETHOD GRAY:STREAM-WRITE-SEQUENCE (STREAM T) SEQUENCE &OPTIONAL GRAY::START GRAY::END) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 18640) ((SI:LOCATION DEFMETHOD GRAY:STREAM-WRITE-SEQUENCE (STREAM SI:ANSI-STREAM) SEQUENCE &OPTIONAL (GRAY::START 0) GRAY::END) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 18497) ((SI:LOCATION DEFMETHOD GRAY:STREAM-WRITE-SEQUENCE (STREAM GRAY:FUNDAMENTAL-BINARY-OUTPUT-STREAM) SEQUENCE &OPTIONAL (GRAY::START 0) GRAY::END) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 18299) ((SI:LOCATION DEFMETHOD GRAY:STREAM-WRITE-SEQUENCE (STREAM GRAY:FUNDAMENTAL-CHARACTER-OUTPUT-STREAM) SEQUENCE &OPTIONAL (GRAY::START 0) GRAY::END) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 18099) ((:LAMBDA-LIST) STREAM SEQUENCE &OPTIONAL GRAY::START GRAY::END) ((SI:LOCATION DEFGENERIC GRAY:STREAM-WRITE-SEQUENCE) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 8027))
SI::STREAM-WRITE-STRING
(((DOCUMENTATION . FUNCTION) . "Generic function in SI package:
Args: ((OBJ STREAM-CLASS) STRING &OPTIONAL START END)

Outputs characters in the STRING to the CLOS stream OBJ and returns the
STRING. The START and END arguments, if given, indicate a substring that
is to be output.
") ((:LAMBDA-LIST) (SI::OBJ SI::STREAM-CLASS) STRING &OPTIONAL SI::START SI::END))
GRAY:STREAM-WRITE-STRING
(((SI:LOCATION DEFMETHOD GRAY:STREAM-WRITE-STRING (STREAM T) STRING &OPTIONAL GRAY::START GRAY::END) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 19406) ((SI:LOCATION DEFMETHOD GRAY:STREAM-WRITE-STRING (STREAM SI:ANSI-STREAM) STRING &OPTIONAL (GRAY::START 0) GRAY::END) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 19263) ((SI:LOCATION DEFMETHOD GRAY:STREAM-WRITE-STRING (STREAM GRAY:FUNDAMENTAL-CHARACTER-OUTPUT-STREAM) STRING &OPTIONAL (GRAY::START 0) GRAY::END) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 18783) ((:LAMBDA-LIST) STREAM STRING &OPTIONAL GRAY::START GRAY::END) ((SI:LOCATION DEFGENERIC GRAY:STREAM-WRITE-STRING) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 7650))
GRAY:STREAMP
(((SI:LOCATION DEFMETHOD GRAY:STREAMP (STREAM T)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 17620) ((SI:LOCATION DEFMETHOD GRAY:STREAMP (STREAM STREAM)) #P"SRC:CLOS;STREAMS.LSP.NEWEST" . 17578))
STREAMP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a stream object; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
STRING
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Coerces X into a string.  If X is a string, then returns X itself.  If X is a
symbol, then returns its print name.  If X is a character, then returns a one
element string containing that character.  Signals an error if X cannot be
coerced into a string.
") ((:LAMBDA-LIST) SI::X) ((DOCUMENTATION . TYPE) . "A string is a vector of characters.  A string is notated by surrounding the
characters with double quotes.  Some strings may be displaced to another
string, may have a fill-pointer, or may be adjustable.  Other strings are
called simple-strings."))
STRING-CAPITALIZE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING &KEY (START 0) (END (LENGTH STRING)))

Returns a copy of STRING with the first character of each word converted to
upper case, and remaining characters converted to lower case.  Its destructive
version is NSTRING-CAPITALIZE.
") ((:LAMBDA-LIST) STRING &KEY (SI::START 0) (SI::END (LENGTH STRING))))
SI::STRING-CHAR
(((DOCUMENTATION . TYPE) . "
A string-char is a character that can be stored in strings.  In ECL, every
character is a string-character."))
SI::STRING-CHAR-P
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (CHAR)

Returns T if CHAR is a string-char, i.e. can be stored in strings; NIL
otherwise.  In ECL, this function always returns T.
") ((:LAMBDA-LIST) CHAR))
SI::STRING-CONCATENATE
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (&REST STRINGS)

ECL specific.
Concatenates STRINGs and returns the result.
") ((:LAMBDA-LIST) &REST SI::STRINGS))
STRING-DOWNCASE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING &KEY (START 0) (END (LENGTH STRING)))

Returns a copy of STRING with all upper case characters converted to lower
case.  Its destructive version is NSTRING-DOWNCASE.
") ((:LAMBDA-LIST) STRING &KEY (SI::START 0) (SI::END (LENGTH STRING))))
STRING-EQUAL
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

Returns T if STRING1 and STRING2 are character-wise CHAR-EQUAL; NIL otherwise.
") ((:LAMBDA-LIST) SI::STRING1 SI::STRING2 &KEY (SI::START1 0) (SI::END1 (LENGTH SI::STRING1)) (SI::START2 0) (SI::END2 (LENGTH SI::STRING2))))
STRING-GREATERP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

Similar to STRING>, but ignores cases.
") ((:LAMBDA-LIST) SI::STRING1 SI::STRING2 &KEY (SI::START1 0) (SI::END1 (LENGTH SI::STRING1)) (SI::START2 0) (SI::END2 (LENGTH SI::STRING2))))
STRING-LEFT-TRIM
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR-BAG STRING)

Returns a copy of STRING with the specified characters removed from the left
end.  CHAR-SPEC must be a sequence of characters.
") ((:LAMBDA-LIST) SI::CHAR-BAG STRING))
STRING-LESSP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

Similar to STRING<, but ignores cases.
") ((:LAMBDA-LIST) SI::STRING1 SI::STRING2 &KEY (SI::START1 0) (SI::END1 (LENGTH SI::STRING1)) (SI::START2 0) (SI::END2 (LENGTH SI::STRING2))))
STRING-NOT-EQUAL
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

Returns NIL if the strings are character-wise CHAR-EQUAL.  Otherwise, returns
the number of characters in the longest common prefix of the strings.
") ((:LAMBDA-LIST) SI::STRING1 SI::STRING2 &KEY (SI::START1 0) (SI::END1 (LENGTH SI::STRING1)) (SI::START2 0) (SI::END2 (LENGTH SI::STRING2))))
STRING-NOT-GREATERP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

Similar to STRING<=, but ignores cases.
") ((:LAMBDA-LIST) SI::STRING1 SI::STRING2 &KEY (SI::START1 0) (SI::END1 (LENGTH SI::STRING1)) (SI::START2 0) (SI::END2 (LENGTH SI::STRING2))))
STRING-NOT-LESSP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

Similar to STRING>=, but ignores cases.
") ((:LAMBDA-LIST) SI::STRING1 SI::STRING2 &KEY (SI::START1 0) (SI::END1 (LENGTH SI::STRING1)) (SI::START2 0) (SI::END2 (LENGTH SI::STRING2))))
STRING-RIGHT-TRIM
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR-BAG STRING)

Returns a copy of STRING with the specified characters removed from the right
end.  CHAR-SPEC must be a sequence of characters.
") ((:LAMBDA-LIST) SI::CHAR-BAG STRING))
SI:STRING-TO-OBJECT
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (STRING)

ECL specific.
Equivalent to (READ-FROM-STRING STRING), but is much faster.
") ((:LAMBDA-LIST) STRING) ((SI:LOCATION DEFUN SI:STRING-TO-OBJECT) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 3389))
STRING-TRIM
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR-SPEC STRING)

Returns a copy of STRING with the specified characters removed from both ends.
CHAR-SPEC must be a sequence of characters.
") ((:LAMBDA-LIST) SI::CHAR-SPEC STRING))
STRING-UPCASE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING &KEY (START 0) (END (LENGTH STRING)))

Returns a copy of STRING with all lower case characters converted to upper
cases.  Its destructive version is NSTRING-UPCASE.
") ((:LAMBDA-LIST) STRING &KEY (SI::START 0) (SI::END (LENGTH STRING))))
STRING/=
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

Returns NIL if the strings are character-wise CHAR=.  Otherwise, returns the
number of characters in the longest common prefix of the strings.
") ((:LAMBDA-LIST) SI::STRING1 SI::STRING2 &KEY (SI::START1 0) (SI::END1 (LENGTH SI::STRING1)) (SI::START2 0) (SI::END2 (LENGTH SI::STRING2))))
STRING<
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

If STRING1 comes before STRING2 in lexicographic order, then returns the
number of characters in the longest common prefix of the strings.  Otherwise,
returns NIL.
") ((:LAMBDA-LIST) SI::STRING1 SI::STRING2 &KEY (SI::START1 0) (SI::END1 (LENGTH SI::STRING1)) (SI::START2 0) (SI::END2 (LENGTH SI::STRING2))))
STRING<=
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

If STRING1 comes before STRING2 in lexicographic order or if the strings are
character-wise CHAR=, then returns the number of characters in the longest
common prefix of the strings.  Otherwise, returns NIL.
") ((:LAMBDA-LIST) SI::STRING1 SI::STRING2 &KEY (SI::START1 0) (SI::END1 (LENGTH SI::STRING1)) (SI::START2 0) (SI::END2 (LENGTH SI::STRING2))))
STRING=
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

Returns T if STRING1 and STRING2 are character-wise CHAR=; NIL otherwise.
") ((:LAMBDA-LIST) SI::STRING1 SI::STRING2 &KEY (SI::START1 0) (SI::END1 (LENGTH SI::STRING1)) (SI::START2 0) (SI::END2 (LENGTH SI::STRING2))))
STRING>
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

If STRING1 comes after STRING2 in lexicographic order or if the strings are
character-wise CHAR=, then returns the number of characters in the longest
common prefix of the strings.  Otherwise, returns NIL.
") ((:LAMBDA-LIST) SI::STRING1 SI::STRING2 &KEY (SI::START1 0) (SI::END1 (LENGTH SI::STRING1)) (SI::START2 0) (SI::END2 (LENGTH SI::STRING2))))
STRING>=
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING1 STRING2 &KEY (START1 0) (END1 (LENGTH STRING1)) (START2 0) (END2 (LENGTH STRING2)))

If STRING1 comes after STRING2 in lexicographic order or if the strings are
character-wise CHAR=, then returns the number of characters in the longest
common prefix of the strings.  Otherwise, returns NIL.
") ((:LAMBDA-LIST) SI::STRING1 SI::STRING2 &KEY (SI::START1 0) (SI::END1 (LENGTH SI::STRING1)) (SI::START2 0) (SI::END2 (LENGTH SI::STRING2))))
STRINGP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a string object; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
STRUCTURE-CLASS
(((SI:LOCATION DEFCLASS STRUCTURE-CLASS) #P"SRC:CLOS;BUILTIN.LSP.NEWEST" . 4740))
STRUCTURE-OBJECT
(((SI:LOCATION DEFCLASS STRUCTURE-OBJECT) #P"SRC:CLOS;BUILTIN.LSP.NEWEST" . 5541))
SI::STRUCTURE-TYPE-ERROR
(((:LAMBDA-LIST) SI::VALUE SI::SLOT-TYPE SI::STRUCT-NAME SI::SLOT-NAME) ((SI:LOCATION DEFUN SI::STRUCTURE-TYPE-ERROR) #P"SRC:LSP;DEFSTRUCT.LSP.NEWEST" . 569))
SI:STRUCTUREP
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (X)

ECL specific.
Returns T if X is a structure object defined by DEFSTRUCT; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
STYLE-WARNING
(((SI:LOCATION DEFCLASS STYLE-WARNING) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
SI:SUBCLASSP
(((:LAMBDA-LIST) SI::LOW SI::HIGH) ((SI:LOCATION DEFUN SI:SUBCLASSP) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 19575))
SUBLIS
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (ALIST TREE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT)

Substitutes subtrees of TREE by using ALIST and returns the result.  The
original TREE is not destroyed.
") ((:LAMBDA-LIST) SI::ALIST SI::TREE &KEY (SI::KEY '#'IDENTITY) (SI::TEST '#'EQL) SI::TEST-NOT))
SUBSEQ
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SEQUENCE START &OPTIONAL (END (LENGTH SEQUENCE)))

Returns a copy of the subsequence of SEQUENCE between START (inclusive) and
END (exclusive).
") ((:LAMBDA-LIST) SEQUENCE SI::START &OPTIONAL (SI::END (LENGTH SEQUENCE))))
SUBSETP
(((DOCUMENTATION . FUNCTION) . "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns T if every element of LIST1 is also an element of LIST2.  Returns NIL
otherwise.") ((:LAMBDA-LIST) SI::LIST1 SI::LIST2 &KEY SI::TEST SI::TEST-NOT SI::KEY) ((SI:LOCATION DEFUN SUBSETP) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 4026))
SUBST
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NEW OLD TREE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT)

Substitutes NEW for subtrees of TREE that match OLD and returns the result.
The original TREE is not destroyed.
") ((:LAMBDA-LIST) SI::NEW SI::OLD SI::TREE &KEY (SI::KEY '#'IDENTITY) (SI::TEST '#'EQL) SI::TEST-NOT))
SI::SUBST-GENSYMS-FOR-NIL
(((:LAMBDA-LIST) SI::TREE) ((SI:LOCATION DEFUN SI::SUBST-GENSYMS-FOR-NIL) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 38348))
SUBST-IF
(((DOCUMENTATION . FUNCTION) . "Substitutes NEW for subtrees of TREE that satisfy TEST and returns the result.
The original TREE is not destroyed.") ((:LAMBDA-LIST) SI::NEW SI::TEST SI::TREE &KEY SI::KEY) ((SI:LOCATION DEFUN SUBST-IF) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 5616))
SUBST-IF-NOT
(((DOCUMENTATION . FUNCTION) . "Substitutes NEW for subtrees of TREE that do not satisfy TEST and returns the
result.  The original TREE is not destroyed.") ((:LAMBDA-LIST) SI::NEW SI::TEST SI::TREE &KEY SI::KEY) ((SI:LOCATION DEFUN SUBST-IF-NOT) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 5827))
SUBSTITUTE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NEW OLD SEQUENCE &KEY (KEY '#'IDENTITY) (TEST '#'EQL) TEST-NOT (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Returns a copy of SEQUENCE with all elements that match OLD replaced by NEW.
The original SEQUENCE is not destroyed.
") ((:LAMBDA-LIST) SI::NEW SI::OLD SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::TEST '#'EQL) SI::TEST-NOT (SI::START 0) (SI::END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN SUBSTITUTE) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 14561))
SUBSTITUTE-IF
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NEW TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Returns a copy of SEQUENCE with all elements that satisfy TEST replaced by
NEW.  The original SEQUENCE is not destroyed.
") ((:LAMBDA-LIST) SI::NEW SI::TEST SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::START 0) (SI::END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN SUBSTITUTE-IF) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 14816))
SUBSTITUTE-IF-NOT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NEW TEST SEQUENCE &KEY (KEY '#'IDENTITY) (START 0) (END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (FROM-END NIL))

Returns a copy of SEQUENCE with all elements that do not satisfy TEST replaced
by NEW.  The original SEQUENCE is not destroyed.
") ((:LAMBDA-LIST) SI::NEW SI::TEST SEQUENCE &KEY (SI::KEY '#'IDENTITY) (SI::START 0) (SI::END (LENGTH SEQUENCE)) (COUNT MOST-POSITIVE-FIXNUM) (SI::FROM-END NIL)) ((SI:LOCATION DEFUN SUBSTITUTE-IF-NOT) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 15119))
SUBTYPEP
(((:LAMBDA-LIST) SI::T1 SI::T2 &OPTIONAL SI::ENV) ((SI:LOCATION DEFUN SUBTYPEP) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 48430))
SI::SUBTYPEP-CLEAR-CACHE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::SUBTYPEP-CLEAR-CACHE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 1101))
SVREF
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SIMPLE-VECTOR N)

Returns the N-th element of SIMPLE-VECTOR.
") ((:LAMBDA-LIST) SIMPLE-VECTOR SI::N))
SI::SWAP-ARGS
(((:LAMBDA-LIST) SI::F) ((SI:LOCATION DEFUN SI::SWAP-ARGS) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 3114))
SXHASH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (OBJECT)

Returns the hash code for OBJECT as an integer.
") ((:LAMBDA-LIST) SI::OBJECT))
SYMBOL
(((DOCUMENTATION . TYPE) . "
Symbol objects."))
SYMBOL-FUNCTION
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL)

Returns the global function definition named SYMBOL.
") ((:LAMBDA-LIST) SYMBOL))
C::SYMBOL-MACRO-DECLARATION-P
(((:LAMBDA-LIST) C::NAME TYPE) ((SI:LOCATION DEFUN C::SYMBOL-MACRO-DECLARATION-P) #P"SRC:CMP;CMPENV-DECLARE.LSP.NEWEST" . 6615))
SYMBOL-NAME
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL)

Returns the print name of SYMBOL.
") ((:LAMBDA-LIST) SYMBOL))
SYMBOL-PACKAGE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL)

Returns the home package of SYMBOL.  Returns NIL if SYMBOL is not interned.
") ((:LAMBDA-LIST) SYMBOL))
SYMBOL-PLIST
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL)

Returns the property list of SYMBOL.
") ((:LAMBDA-LIST) SYMBOL))
SYMBOL-VALUE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL)

Returns the value of the global variable named SYMBOL.
") ((:LAMBDA-LIST) SYMBOL))
SYMBOLP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a symbol; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
SI:SYSTEM
(((DOCUMENTATION . FUNCTION) . "Function in SI package:
Args: (STRING)

Executes a Shell command as if STRING is an input to the Shell.
") ((:LAMBDA-LIST) STRING))
C::SYSTEM-LD-FLAG
(((:LAMBDA-LIST) C::LIBRARY) ((SI:LOCATION DEFUN C::SYSTEM-LD-FLAG) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 10027))
T
(((DOCUMENTATION . VARIABLE) . "Constant in COMMON-LISP package:
The value of T is T.
") ((DOCUMENTATION . TYPE) . "
The type T is a supertype of every type.  Every object belongs to this type."))
C::T1/C1EXPR
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::T1/C1EXPR) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 2119))
C::T1DEFMACRO
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::T1DEFMACRO) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 18711))
C::T1EXPR
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::T1EXPR) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 569))
C::T1EXPR*
(((:LAMBDA-LIST) C::FORM &AUX (C::*CURRENT-TOPLEVEL-FORM* (LIST* C::FORM C::*CURRENT-TOPLEVEL-FORM*)) (C::*CURRENT-FORM* C::FORM) (C::*FIRST-ERROR* T) (C::*SETJMPS* 0)) ((SI:LOCATION DEFUN C::T1EXPR*) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 907))
C::T1ORDINARY
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::T1ORDINARY) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 17935))
C::T2COMPILER-LET
(((:LAMBDA-LIST) C::SYMBOLS VALUES C::BODY) ((SI:LOCATION DEFUN C::T2COMPILER-LET) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 9911))
C::T2EXPR
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::T2EXPR) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 2261))
C::T2INIT-FORM
(((:LAMBDA-LIST) C::VV-LOC C::FORM) ((SI:LOCATION DEFUN C::T2INIT-FORM) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 20124))
C::T2LOAD-TIME-VALUE
(((:LAMBDA-LIST) C::VV-LOC C::FORM) ((SI:LOCATION DEFUN C::T2LOAD-TIME-VALUE) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 19778))
C::T2MAKE-FORM
(((:LAMBDA-LIST) C::VV-LOC C::FORM) ((SI:LOCATION DEFUN C::T2MAKE-FORM) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 19954))
C::T2ORDINARY
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::T2ORDINARY) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 18218))
C::T2PROGN
(((:LAMBDA-LIST) C::ARGS) ((SI:LOCATION DEFUN C::T2PROGN) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 9996))
C::T3-DEFCALLBACK
(((:LAMBDA-LIST) C::LISP-NAME C::C-NAME C::C-NAME-CONSTANT C::RETURN-TYPE C::ARG-TYPES C::ARG-TYPE-CONSTANTS C::CALL-TYPE &AUX (C::RETURN-P T)) ((SI:LOCATION DEFUN C::T3-DEFCALLBACK) #P"SRC:CMP;CMPCBK.LSP.NEWEST" . 2874))
C::T3LOCAL-FUN
(((:LAMBDA-LIST) C::FUN &AUX (C::LAMBDA-EXPR (C::FUN-LAMBDA C::FUN)) (C::LEVEL (IF (EQ (C::FUN-CLOSURE C::FUN) 'C::LEXICAL) (C::FUN-LEVEL C::FUN) 0)) (C::CFUN (C::FUN-CFUN C::FUN)) (C::MINARG (C::FUN-MINARG C::FUN)) (C::MAXARG (C::FUN-MAXARG C::FUN)) (C::NARG (C::FUN-NEEDS-NARG C::FUN)) (C::NENVS C::LEVEL) (C::*VOLATILE* (C::C1FORM-VOLATILE* C::LAMBDA-EXPR)) (C::*TAIL-RECURSION-INFO* C::FUN) (C::LAMBDA-LIST (C::C1FORM-ARG 0 C::LAMBDA-EXPR)) (C::REQUIREDS (CAR C::LAMBDA-LIST)) (C::*CMP-ENV* (C::C1FORM-ENV C::LAMBDA-EXPR))) ((SI:LOCATION DEFUN C::T3LOCAL-FUN) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 23525))
SI::TAB
(((SI:LOCATION DEFCLASS SI::TAB) #P"SRC:LSP;PPRINT.LSP.NEWEST" . 13729))
C::TAG
(((SI:LOCATION DEFCLASS C::TAG) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 8376))
TAGBODY
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (tagbody {tag | statement}*)

Executes STATEMENTs in order and returns NIL after the execution of the last
STATEMENT.  But, if a GO form causes a jump to one of the TAGs, then execution
continues at the point right after the TAG.  Lists are regarded as STATEMENTs
and other objects are regarded as TAGs.
") ((:LAMBDA-LIST) . "(tagbody {tag | statement}*)"))
C::TAIL-RECURSION-POSSIBLE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::TAIL-RECURSION-POSSIBLE) #P"SRC:CMP;CMPEXIT.LSP.NEWEST" . 7043))
TAILP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X LIST)

Returns T if X is identical to one of the conses that constitute LIST.
Returns NIL otherwise.
") ((:LAMBDA-LIST) SI::X LIST))
TAN
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (RADIANS)

Returns the tangent of RADIANS.
") ((:LAMBDA-LIST) SI::RADIANS))
TANH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER)

Returns the hyperbolic tangent of NUMBER.
") ((:LAMBDA-LIST) NUMBER))
CLOS::TEMP-METHOD
(((SI:LOCATION DEFMETHOD CLOS::TEMP-METHOD (CLOS::C STANDARD-GENERIC-FUNCTION) FUNCTION) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 9924) ((SI:LOCATION DEFMETHOD CLOS::TEMP-METHOD (CLOS::GF STANDARD-GENERIC-FUNCTION) (METHOD STANDARD-METHOD)) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 7968))
TENTH
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to (CADR (CDDDDR (CDDDDR X))).
") ((:LAMBDA-LIST) SI::X))
SI:TERMINAL-INTERRUPT
(((:LAMBDA-LIST) &OPTIONAL (SI::CORRECTABLEP T)) ((SI:LOCATION DEFUN SI:TERMINAL-INTERRUPT) #P"SRC:LSP;TOP.LSP.NEWEST" . 18619))
TERPRI
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&OPTIONAL (STREAM *STANDARD-OUTPUT*))

Outputs a newline character.
") ((:LAMBDA-LIST) &OPTIONAL (STREAM *STANDARD-OUTPUT*)))
SI::TEST-ERROR
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::TEST-ERROR) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 1746))
THE
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (the type form)

Declares that FORM evaluates to a value of TYPE.  Evaluates FORM and checks if
the value belongs to TYPE.  If it does, returns the value.  Otherwise, signals
an error.
") ((:LAMBDA-LIST) . "(the type form)") ((SI:LOCATION DEFMACRO THE) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 11304))
THIRD
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Equivalent to CADDR.
") ((:LAMBDA-LIST) SI::X))
THROW
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (throw tag form)

Evaluates TAG and aborts the execution of the most recent CATCH form that
establishes a catcher with the same catch tag.  Returns all values of FORM as
the values of the CATCH form.
") ((:LAMBDA-LIST) . "(throw tag form)"))
TIME
(((DOCUMENTATION . FUNCTION) . "Syntax: (time form)
Evaluates FORM, outputs the realtime and runtime used for the evaluation to
*TRACE-OUTPUT*, and then returns all values of FORM.") ((:LAMBDA-LIST) SI::FORM) ((SI:LOCATION DEFMACRO TIME) #P"SRC:LSP;MISLIB.LSP.NEWEST" . 3487))
C::TMP-DESTINATION
(((:LAMBDA-LIST) C::LOC) ((SI:LOCATION DEFUN C::TMP-DESTINATION) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 2115))
C::TO-FIXNUM-FLOAT-TYPE
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN C::TO-FIXNUM-FLOAT-TYPE) #P"SRC:CMP;CMPC-INLINER.LSP.NEWEST" . 4411))
SI::TOKENIZE-CONTROL-STRING
(((:LAMBDA-LIST) STRING) ((SI:LOCATION DEFUN SI::TOKENIZE-CONTROL-STRING) #P"SRC:LSP;FORMAT.LSP.NEWEST" . 10689))
C::TOO-FEW-ARGS
(((:LAMBDA-LIST) C::NAME C::LOWER-BOUND C::N) ((SI:LOCATION DEFUN C::TOO-FEW-ARGS) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 9162))
C::TOO-MANY-ARGS
(((:LAMBDA-LIST) C::NAME C::UPPER-BOUND C::N &AUX (*PRINT-CASE* :UPCASE)) ((SI:LOCATION DEFUN C::TOO-MANY-ARGS) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 8949))
SI:TOP-LEVEL
(((DOCUMENTATION . FUNCTION) . "Args: ()
ECL specific.
The top-level loop of ECL. It is called by default when ECL is invoked.") ((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI:TOP-LEVEL) #P"SRC:LSP;TOP.LSP.NEWEST" . 15131))
SI::TPL
(((:LAMBDA-LIST) &KEY ((:COMMANDS SI::*TPL-COMMANDS*) SI::TPL-COMMANDS) ((:PROMPT-HOOK SI:*TPL-PROMPT-HOOK*) SI:*TPL-PROMPT-HOOK*) (SI::BROKEN-AT NIL) (SI::QUIET NIL)) ((SI:LOCATION DEFUN SI::TPL) #P"SRC:LSP;TOP.LSP.NEWEST" . 20009))
SI::TPL-APROPOS-COMMAND
(((:LAMBDA-LIST) &OPTIONAL STRING SI::PKG) ((SI:LOCATION DEFUN SI::TPL-APROPOS-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 43221))
SI::TPL-BACKTRACE
(((:LAMBDA-LIST) &OPTIONAL SI::N) ((SI:LOCATION DEFUN SI::TPL-BACKTRACE) #P"SRC:LSP;TOP.LSP.NEWEST" . 37567))
SI::TPL-BACKWARD-SEARCH
(((:LAMBDA-LIST) STRING) ((SI:LOCATION DEFUN SI::TPL-BACKWARD-SEARCH) #P"SRC:LSP;TOP.LSP.NEWEST" . 42538))
SI::TPL-BDS-COMMAND
(((:LAMBDA-LIST) &OPTIONAL SI::VAR) ((SI:LOCATION DEFUN SI::TPL-BDS-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 36796))
SI::TPL-COMMANDS
(((SI:LOCATION DEFCONSTANT SI::TPL-COMMANDS) #P"SRC:LSP;TOP.LSP.NEWEST" . 1700))
SI::TPL-COMPILE-COMMAND
(((:LAMBDA-LIST) &REST SI::FILES) ((SI:LOCATION DEFUN SI::TPL-COMPILE-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 43810))
SI::TPL-CONTINUE-COMMAND
(((:LAMBDA-LIST) &REST SI::ANY) ((SI:LOCATION DEFUN SI::TPL-CONTINUE-COMMAND) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 28198))
SI::TPL-DISASSEMBLE-COMMAND
(((:LAMBDA-LIST) &OPTIONAL SI::NO-VALUES) ((SI:LOCATION DEFUN SI::TPL-DISASSEMBLE-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 27104))
SI::TPL-DOCUMENT-COMMAND
(((:LAMBDA-LIST) &OPTIONAL SYMBOL) ((SI:LOCATION DEFUN SI::TPL-DOCUMENT-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 43310))
SI::TPL-FORWARD-SEARCH
(((:LAMBDA-LIST) STRING) ((SI:LOCATION DEFUN SI::TPL-FORWARD-SEARCH) #P"SRC:LSP;TOP.LSP.NEWEST" . 42811))
SI::TPL-FRS-COMMAND
(((:LAMBDA-LIST) &OPTIONAL SI::N) ((SI:LOCATION DEFUN SI::TPL-FRS-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 39081))
SI::TPL-GO
(((:LAMBDA-LIST) SI::IHS-INDEX) ((SI:LOCATION DEFUN SI::TPL-GO) #P"SRC:LSP;TOP.LSP.NEWEST" . 26797))
SI::TPL-HELP-COMMAND
(((:LAMBDA-LIST) &OPTIONAL SI::TOPIC) ((SI:LOCATION DEFUN SI::TPL-HELP-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 44005))
SI::TPL-HELP-STACK-COMMAND
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::TPL-HELP-STACK-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 44699))
SI::TPL-HIDE
(((:LAMBDA-LIST) SI::FNAME) ((SI:LOCATION DEFUN SI::TPL-HIDE) #P"SRC:LSP;TOP.LSP.NEWEST" . 40460))
SI::TPL-HIDE-PACKAGE
(((:LAMBDA-LIST) PACKAGE) ((SI:LOCATION DEFUN SI::TPL-HIDE-PACKAGE) #P"SRC:LSP;TOP.LSP.NEWEST" . 41054))
SI::TPL-INSPECT-COMMAND
(((:LAMBDA-LIST) SI::VAR-NAME) ((SI:LOCATION DEFUN SI::TPL-INSPECT-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 36323))
SI::TPL-LAMBDA-EXPRESSION-COMMAND
(((:LAMBDA-LIST) &OPTIONAL SI::NO-VALUES) ((SI:LOCATION DEFUN SI::TPL-LAMBDA-EXPRESSION-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 27437))
SI::TPL-LOAD-COMMAND
(((:LAMBDA-LIST) &REST SI::FILES) ((SI:LOCATION DEFUN SI::TPL-LOAD-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 43625))
SI::TPL-MAKE-COMMAND
(((:LAMBDA-LIST) SI::NAME SI::LINE &AUX (SI::C NIL)) ((SI:LOCATION DEFUN SI::TPL-MAKE-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 24300))
SI::TPL-NEXT
(((:LAMBDA-LIST) &OPTIONAL (SI::N 1)) ((SI:LOCATION DEFUN SI::TPL-NEXT) #P"SRC:LSP;TOP.LSP.NEWEST" . 26553))
SI::TPL-PARSE-FORMS
(((:LAMBDA-LIST) SI::LINE &OPTIONAL QUOTE) ((SI:LOCATION DEFUN SI::TPL-PARSE-FORMS) #P"SRC:LSP;TOP.LSP.NEWEST" . 24957))
SI::TPL-PARSE-STRINGS
(((:LAMBDA-LIST) SI::LINE) ((SI:LOCATION DEFUN SI::TPL-PARSE-STRINGS) #P"SRC:LSP;TOP.LSP.NEWEST" . 25202))
SI::TPL-POP-COMMAND
(((:LAMBDA-LIST) &REST SI::ANY) ((SI:LOCATION DEFUN SI::TPL-POP-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 26016))
SI::TPL-PREVIOUS
(((:LAMBDA-LIST) &OPTIONAL (SI::N 1)) ((SI:LOCATION DEFUN SI::TPL-PREVIOUS) #P"SRC:LSP;TOP.LSP.NEWEST" . 26304))
SI::TPL-PRINT
(((:LAMBDA-LIST) VALUES) ((SI:LOCATION DEFUN SI::TPL-PRINT) #P"SRC:LSP;TOP.LSP.NEWEST" . 25819))
SI::TPL-PRINT-CURRENT
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::TPL-PRINT-CURRENT) #P"SRC:LSP;TOP.LSP.NEWEST" . 39842))
SI::TPL-PRINT-MESSAGE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::TPL-PRINT-MESSAGE) #P"SRC:LSP;TOP.LSP.NEWEST" . 26997))
SI::TPL-PRINT-VARIABLES
(((:LAMBDA-LIST) SI::PREFIX SI::VARIABLES SI::NO-VALUES) ((SI:LOCATION DEFUN SI::TPL-PRINT-VARIABLES) #P"SRC:LSP;TOP.LSP.NEWEST" . 34938))
SI::TPL-PROMPT
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::TPL-PROMPT) #P"SRC:LSP;TOP.LSP.NEWEST" . 22502))
SI::TPL-QUIT-COMMAND
(((:LAMBDA-LIST) &OPTIONAL (SI::LEVEL 0)) ((SI:LOCATION DEFUN SI::TPL-QUIT-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 26108))
SI::TPL-READ
(((:LAMBDA-LIST) &AUX (*READ-SUPPRESS* NIL)) ((SI:LOCATION DEFUN SI::TPL-READ) #P"SRC:LSP;TOP.LSP.NEWEST" . 22830))
SI::TPL-STEP-COMMAND
(((:LAMBDA-LIST) &OPTIONAL SI::FORM) ((SI:LOCATION DEFUN SI::TPL-STEP-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 43389))
SI::TPL-TRACE-COMMAND
(((:LAMBDA-LIST) &REST SI::FUNCTIONS) ((SI:LOCATION DEFUN SI::TPL-TRACE-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 43459))
SI::TPL-UNHIDE
(((:LAMBDA-LIST) SI::FNAME) ((SI:LOCATION DEFUN SI::TPL-UNHIDE) #P"SRC:LSP;TOP.LSP.NEWEST" . 40666))
SI::TPL-UNHIDE-ALL
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN SI::TPL-UNHIDE-ALL) #P"SRC:LSP;TOP.LSP.NEWEST" . 40941))
SI::TPL-UNHIDE-PACKAGE
(((:LAMBDA-LIST) PACKAGE) ((SI:LOCATION DEFUN SI::TPL-UNHIDE-PACKAGE) #P"SRC:LSP;TOP.LSP.NEWEST" . 40791))
SI::TPL-UNKNOWN-COMMAND
(((:LAMBDA-LIST) SI::COMMAND) ((SI:LOCATION DEFUN SI::TPL-UNKNOWN-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 25911))
SI::TPL-UNTRACE-COMMAND
(((:LAMBDA-LIST) &REST SI::FUNCTIONS) ((SI:LOCATION DEFUN SI::TPL-UNTRACE-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 43525))
SI::TPL-VARIABLES-COMMAND
(((:LAMBDA-LIST) &OPTIONAL SI::NO-VALUES) ((SI:LOCATION DEFUN SI::TPL-VARIABLES-COMMAND) #P"SRC:LSP;TOP.LSP.NEWEST" . 35562))
TRACE
(((DOCUMENTATION . FUNCTION) . "Syntax: (trace ({function-name | ({function-name}+)} {keyword [form]}*)
Begins tracing the specified functions.  With no FUNCTION-NAMEs, returns a
list of functions currently being traced. The printed information consists of
the name of function followed at entry by its arguments and on exit by its
return values.
The keywords allow to control when and how tracing is performed.
The possible keywords are:

 :BREAK		a breakpoint is entered after printing the entry trace
		information, but before applying the traced function to its
		arguments, if form evaluates to non-nil
 :BREAK-AFTER 	like :BREAK but the breakpoint is entered after the function
		has been executed and the exit trace information has been
		printed and before control returns
 :COND-BEFORE	information is printed upon entry if form evaluates to non-nil
 :COND-AFTER	information is printed upon exit if form evaluates to non-nil
 :COND		specifies a single condition for both entry and exit
 :PRINT		prints the values of the forms in the list upon entry.
		They are preceeded by a backslash (\\)
 :PRINT-AFTER	prints the values of the forms in the list upon exit from the
		function. They are preceeded by a backslash (\\)
 :STEP		turns on the stepping facility

Forms can refer to the list of arguments of the function through the variable
SI::ARGS.") ((:LAMBDA-LIST) &REST SI::R) ((SI:LOCATION DEFMACRO TRACE) #P"SRC:LSP;TRACE.LSP.NEWEST" . 639))
SI::TRACE*
(((:LAMBDA-LIST) SI::R) ((SI:LOCATION DEFUN SI::TRACE*) #P"SRC:LSP;TRACE.LSP.NEWEST" . 2008))
SI::TRACE-ONE
(((:LAMBDA-LIST) SI::SPEC) ((SI:LOCATION DEFUN SI::TRACE-ONE) #P"SRC:LSP;TRACE.LSP.NEWEST" . 2368))
SI::TRACE-PRINT
(((:LAMBDA-LIST) SI::DIRECTION SI::FNAME SI::VALS &REST SI::EXTRAS) ((SI:LOCATION DEFUN SI::TRACE-PRINT) #P"SRC:LSP;TRACE.LSP.NEWEST" . 5500))
SI::TRACING-BODY
(((:LAMBDA-LIST) SI::FNAME &AUX (SI::FUN (FDEFINITION SI::FNAME))) ((SI:LOCATION DEFUN SI::TRACING-BODY) #P"SRC:LSP;TRACE.LSP.NEWEST" . 7027))
C::TRAVERSE-C1FORM-TREE
(((:LAMBDA-LIST) C::TREE FUNCTION) ((SI:LOCATION DEFUN C::TRAVERSE-C1FORM-TREE) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 7850))
TREE-EQUAL
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X Y &KEY (TEST '#'EQL) TEST-NOT)

Returns T if X and Y have the same tree structures and corresponding leaves
are all the same in the sense of TEST.  Returns NIL otherwise.
") ((:LAMBDA-LIST) SI::X SI::Y &KEY (SI::TEST '#'EQL) SI::TEST-NOT))
SI::TREE-SEARCH
(((:LAMBDA-LIST) SI::TREE SI::X) ((SI:LOCATION DEFUN SI::TREE-SEARCH) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/src/doc/help.lsp" . 1849))
TRUENAME
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (FILESPEC)

Returns the full pathname of the file specified by FILESPEC.  FILESPEC may be
a symbol, a string, a pathname, or a file stream.
") ((:LAMBDA-LIST) SI::FILESPEC))
TRUNCATE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER &OPTIONAL (DIVISOR 1))

Returns the integer obtained by truncating NUMBER/DIVISOR.  Returns the value
of (- NUMBER (* first-value DIVISOR)) as the second value.
") ((:LAMBDA-LIST) NUMBER &OPTIONAL (SI::DIVISOR 1)))
C::TRY-OPTIMIZE-SLOT-READER
(((:LAMBDA-LIST) C::READERS C::ARGS) ((SI:LOCATION DEFUN C::TRY-OPTIMIZE-SLOT-READER) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 3281))
C::TRY-OPTIMIZE-SLOT-WRITER
(((:LAMBDA-LIST) C::ORIG-WRITERS C::ARGS) ((SI:LOCATION DEFUN C::TRY-OPTIMIZE-SLOT-WRITER) #P"SRC:CMP;CMPCLOS.LSP.NEWEST" . 3871))
C::TYPE-AND
(((:LAMBDA-LIST) C::T1 C::T2) ((SI:LOCATION DEFUN C::TYPE-AND) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 2319))
C::TYPE-AND-EMPTY-CACHE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::TYPE-AND-EMPTY-CACHE) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 2319))
TYPE-ERROR
(((SI:LOCATION DEFCLASS TYPE-ERROR) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
C::TYPE-ERROR-CHECK
(((:LAMBDA-LIST) C::VALUE TYPE) ((SI:LOCATION DEFUN C::TYPE-ERROR-CHECK) #P"SRC:CMP;CMPTYPE.LSP.NEWEST" . 5811))
C::TYPE-FROM-ARRAY-ELT
(((:LAMBDA-LIST) ARRAY &AUX C::NAME) ((SI:LOCATION DEFUN C::TYPE-FROM-ARRAY-ELT) #P"SRC:CMP;CMPPROP.LSP.NEWEST" . 11151))
C::TYPE-NAME-P
(((:LAMBDA-LIST) C::NAME) ((SI:LOCATION DEFUN C::TYPE-NAME-P) #P"SRC:CMP;CMPENV-DECLARE.LSP.NEWEST" . 922))
TYPE-OF
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns a type specifier of the type to which X belongs.
") ((:LAMBDA-LIST) SI::X))
C::TYPE-OR
(((:LAMBDA-LIST) C::T1 C::T2) ((SI:LOCATION DEFUN C::TYPE-OR) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 9004))
C::TYPE-OR-EMPTY-CACHE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::TYPE-OR-EMPTY-CACHE) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 9004))
SI::TYPE=
(((:LAMBDA-LIST) SI::T1 SI::T2) ((SI:LOCATION DEFUN SI::TYPE=) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 49879))
C::TYPE>=
(((:LAMBDA-LIST) C::TYPE1 C::TYPE2) ((SI:LOCATION DEFUN C::TYPE>=) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 10049))
TYPECASE
(((DOCUMENTATION . FUNCTION) . "Syntax: (typecase keyform {(type {form}*)}*)
Evaluates KEYFORM and searches a TYPE to which the value of KEYFORM belongs.
If found, then evaluates FORMs that follow the TYPE and returns all values of
the last FORM.  If not, simply returns NIL.  The symbols T and OTHERWISE may
be used as a TYPE to specify the default case.") ((:LAMBDA-LIST) SI::KEYFORM &REST SI::CLAUSES) ((SI:LOCATION DEFMACRO TYPECASE) #P"SRC:LSP;ASSERT.LSP.NEWEST" . 5959))
TYPEP
(((SI:LOCATION DEFINE-COMPILER-MACRO TYPEP) #P"SRC:CMP;CMPOPT.LSP.NEWEST" . 5278) ((DOCUMENTATION . FUNCTION) . "Args: (object type)
Returns T if X belongs to TYPE; NIL otherwise.") ((:LAMBDA-LIST) SI::OBJECT TYPE &OPTIONAL SI::ENV &AUX SI::TP SI::I SI::C) ((SI:LOCATION DEFUN TYPEP) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 15120))
UNBOUND-SLOT
(((SI:LOCATION DEFCLASS UNBOUND-SLOT) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
CLOS::UNBOUND-SLOT-ERROR
(((:LAMBDA-LIST) CLOS::OBJECT CLOS::INDEX) ((SI:LOCATION DEFUN CLOS::UNBOUND-SLOT-ERROR) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 22360))
UNBOUND-VARIABLE
(((SI:LOCATION DEFCLASS UNBOUND-VARIABLE) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
C::UNBOXED
(((:LAMBDA-LIST) C::VAR) ((SI:LOCATION DEFUN C::UNBOXED) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 8147))
UNDEFINED-FUNCTION
(((SI:LOCATION DEFCLASS UNDEFINED-FUNCTION) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
C::UNDEFINED-VARIABLE
(((:LAMBDA-LIST) C::SYM) ((SI:LOCATION DEFUN C::UNDEFINED-VARIABLE) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 10510))
UNEXPORT
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL &OPTIONAL (PACKAGE *PACKAGE*))

Undoes the registration of SYMBOL as an external symbol of PACKAGE and makes
SYMBOL internal to PACKAGE.  SYMBOL may be a list of symbols.
") ((:LAMBDA-LIST) SYMBOL &OPTIONAL (PACKAGE *PACKAGE*)))
UNINTERN
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (SYMBOL &OPTIONAL (PACKAGE *PACKAGE*))

Removes SYMBOL from PACKAGE.  If PACKAGE is the home package of SYMBOL, then
makes SYMBOL uninterned.  Returns T if SYMBOL is actually registered in
PACKAGE; NIL otherwise.
") ((:LAMBDA-LIST) SYMBOL &OPTIONAL (PACKAGE *PACKAGE*)))
UNION
(((DOCUMENTATION . FUNCTION) . "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns, as a list, the union of elements in LIST1 and in LIST2.") ((:LAMBDA-LIST) SI::LIST1 SI::LIST2 &KEY SI::TEST SI::TEST-NOT SI::KEY) ((SI:LOCATION DEFUN UNION) #P"SRC:LSP;LISTLIB.LSP.NEWEST" . 529))
SI::UNIQUE-ID
(((DOCUMENTATION . FUNCTION) . "Generates a unique integer ID for its argument.") ((:LAMBDA-LIST) SI::OBJ) ((SI:LOCATION DEFMACRO SI::UNIQUE-ID) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 1012))
C::UNIQUE-INIT-NAME
(((:LAMBDA-LIST) C::FILE) ((SI:LOCATION DEFUN C::UNIQUE-INIT-NAME) #P"SRC:CMP;CMPNAME.LSP.NEWEST" . 1399))
SI:UNIVERSAL-ERROR-HANDLER
(((DOCUMENTATION . FUNCTION) . "Args: (error-name continuable-p function-name
       continue-format-string error-format-string
       &rest args)
ECL specific.
Starts the error handler of ECL.
When an error is detected, ECL calls this function with the specified
arguments.  To change the error handler of ECL, redefine this function.
ERROR-NAME is the name of the error.  CONTINUABLE-P is T for a continuable
error and NIL for a fatal error.  FUNCTION-NAME is the name of the function
that caused the error.  CONTINUE-FORMAT-STRING and ERROR-FORMAT-STRING are the
format strings of the error message.  ARGS are the arguments to the format
strings.") ((:LAMBDA-LIST) SI::CONTINUE-STRING SI::DATUM SI::ARGS) ((SI:LOCATION DEFUN SI:UNIVERSAL-ERROR-HANDLER) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 26290))
SI:UNIX-SIGNAL-RECEIVED
(((SI:LOCATION DEFCLASS SI:UNIX-SIGNAL-RECEIVED) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
C::UNKNOWN-LOCATION
(((:LAMBDA-LIST) C::WHERE C::LOC) ((SI:LOCATION DEFUN C::UNKNOWN-LOCATION) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 3687))
UNLESS
(((:LAMBDA-LIST) SI::PRED &REST SI::BODY) ((SI:LOCATION DEFMACRO UNLESS) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 533))
C::UNOPTIMIZED-FUNCALL
(((:LAMBDA-LIST) C::FUN C::ARGUMENTS) ((SI:LOCATION DEFUN C::UNOPTIMIZED-FUNCALL) #P"SRC:CMP;CMPCALL.LSP.NEWEST" . 787))
C::UNOPTIMIZED-LONG-CALL
(((:LAMBDA-LIST) C::FUN C::ARGUMENTS) ((SI:LOCATION DEFUN C::UNOPTIMIZED-LONG-CALL) #P"SRC:CMP;CMPCALL.LSP.NEWEST" . 562))
UNREAD-CHAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR &OPTIONAL (STREAM *STANDARD-INPUT*))

Puts CHAR back on the front of the input stream STREAM.
") ((:LAMBDA-LIST) CHAR &OPTIONAL (STREAM *STANDARD-INPUT*)))
SI::UNSAFE-FUNCALL1
(((:LAMBDA-LIST) SI::F SI::X) ((SI:LOCATION DEFUN SI::UNSAFE-FUNCALL1) #P"SRC:LSP;SEQLIB.LSP.NEWEST" . 1842))
UNSIGNED-BYTE
(((DOCUMENTATION . TYPE) . "As a type specifier, (UNSIGNED-BYTE n) specifies non-negative integers that
can be represented with N bits."))
SI:UNTIL
(((:LAMBDA-LIST) SI::TEST &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI:UNTIL) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 10000))
UNTRACE
(((DOCUMENTATION . FUNCTION) . "Syntax: (untrace {function-name}*)

Ends tracing the specified functions.  With no FUNCTION-NAMEs, ends tracing
all functions.") ((:LAMBDA-LIST) &REST SI::R) ((SI:LOCATION DEFMACRO UNTRACE) #P"SRC:LSP;TRACE.LSP.NEWEST" . 2086))
SI::UNTRACE*
(((:LAMBDA-LIST) SI::R) ((SI:LOCATION DEFUN SI::UNTRACE*) #P"SRC:LSP;TRACE.LSP.NEWEST" . 2265))
SI::UNTRACE-ONE
(((:LAMBDA-LIST) SI::FNAME) ((SI:LOCATION DEFUN SI::UNTRACE-ONE) #P"SRC:LSP;TRACE.LSP.NEWEST" . 6544))
UNUSE-PACKAGE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (PACKAGE-SPEC &OPTIONAL (PACKAGE *PACKAGE*))

Causes PACKAGE not to use packages specified by PACKAGE-SPEC.  PACKAGE-SPEC
may be a package object, a string, a symbol, or a list consisting of package
objects, strings, and, symbols.
") ((:LAMBDA-LIST) SI::PACKAGE-SPEC &OPTIONAL (PACKAGE *PACKAGE*)))
C::UNWIND-BDS
(((:LAMBDA-LIST) C::BDS-LCL C::BDS-BIND C::STACK-FRAME C::IHS-P) ((SI:LOCATION DEFUN C::UNWIND-BDS) #P"SRC:CMP;CMPEXIT.LSP.NEWEST" . 559))
C::UNWIND-EXIT
(((:LAMBDA-LIST) C::LOC &OPTIONAL (C::JUMP-P NIL) &AUX (C::BDS-LCL NIL) (C::BDS-BIND 0) (C::STACK-FRAME NIL) (C::IHS-P NIL)) ((SI:LOCATION DEFUN C::UNWIND-EXIT) #P"SRC:CMP;CMPEXIT.LSP.NEWEST" . 1171))
C::UNWIND-NO-EXIT
(((:LAMBDA-LIST) C::EXIT &AUX (C::BDS-LCL NIL) (C::BDS-BIND 0) (C::STACK-FRAME NIL) (C::IHS-P NIL)) ((SI:LOCATION DEFUN C::UNWIND-NO-EXIT) #P"SRC:CMP;CMPEXIT.LSP.NEWEST" . 5063))
UNWIND-PROTECT
(((DOCUMENTATION . FUNCTION) . "Special Form in COMMON-LISP package:
Syntax: (unwind-protect form {cleanup-form}*)

Evaluates FORM and returns all its values.  Before returning, evaluates
CLEANUP-FORMs in order, whether FORM returns normally or abnormally by a non-
local exit.
") ((:LAMBDA-LIST) . "(unwind-protect form {cleanup-form}*)"))
SI::UPDATE-DEBUG-COMMANDS
(((:LAMBDA-LIST) SI::RESTART-COMMANDS) ((SI:LOCATION DEFUN SI::UPDATE-DEBUG-COMMANDS) #P"SRC:LSP;TOP.LSP.NEWEST" . 46455))
CLOS::UPDATE-DEPENDENTS
(((SI:LOCATION DEFMETHOD CLOS::UPDATE-DEPENDENTS (CLOS::OBJECT GENERIC-FUNCTION) (CLOS::DEP CLOS::INITARGS-UPDATER) &REST CLOS::INITARGS) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 10625) ((:LAMBDA-LIST) CLOS::OBJECT CLOS::DEPENDENTS &REST CLOS::INITARGS) ((SI:LOCATION DEFGENERIC CLOS::UPDATE-DEPENDENTS) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 10359))
CLOS::UPDATE-INSTANCE
(((:LAMBDA-LIST) CLOS::INSTANCE) ((SI:LOCATION DEFUN CLOS::UPDATE-INSTANCE) #P"SRC:CLOS;CHANGE.LSP.NEWEST" . 5607))
UPDATE-INSTANCE-FOR-DIFFERENT-CLASS
(((SI:LOCATION DEFMETHOD UPDATE-INSTANCE-FOR-DIFFERENT-CLASS (CLOS::OLD-DATA STANDARD-OBJECT) (CLOS::NEW-DATA STANDARD-OBJECT) &REST CLOS::INITARGS) #P"SRC:CLOS;CHANGE.LSP.NEWEST" . 1299))
UPDATE-INSTANCE-FOR-REDEFINED-CLASS
(((SI:LOCATION DEFMETHOD UPDATE-INSTANCE-FOR-REDEFINED-CLASS (CLOS::INSTANCE STANDARD-OBJECT) CLOS::ADDED-SLOTS CLOS::DISCARDED-SLOTS CLOS::PROPERTY-LIST &REST CLOS::INITARGS) #P"SRC:CLOS;CHANGE.LSP.NEWEST" . 4951))
SI::UPDATE-TYPES
(((:LAMBDA-LIST) SI::TYPE-MASK SI::NEW-TAG) ((SI:LOCATION DEFUN SI::UPDATE-TYPES) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 26280))
C::UPDATE-VARIABLE-TYPE
(((:LAMBDA-LIST) C::VAR C::ORIG-TYPE) ((SI:LOCATION DEFUN C::UPDATE-VARIABLE-TYPE) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 1866))
UPGRADED-ARRAY-ELEMENT-TYPE
(((:LAMBDA-LIST) SI::ELEMENT-TYPE &OPTIONAL SI::ENV) ((SI:LOCATION DEFUN UPGRADED-ARRAY-ELEMENT-TYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 12762))
UPGRADED-COMPLEX-PART-TYPE
(((:LAMBDA-LIST) SI::REAL-TYPE &OPTIONAL SI::ENV) ((SI:LOCATION DEFUN UPGRADED-COMPLEX-PART-TYPE) #P"SRC:LSP;PREDLIB.LSP.NEWEST" . 13374))
UPPER-CASE-P
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR)

Returns T if CHAR is an upper-case character; NIL otherwise.
") ((:LAMBDA-LIST) CHAR))
USE-PACKAGE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (PACKAGE-SPEC &OPTIONAL (PACKAGE *PACKAGE*))

Causes PACKAGE to use packages specified by PACKAGE-SPEC, in addition to those
packages that PACKAGE already uses.  PACKAGE-SPEC may be a package object, a
string, a symbol, or a list consisting of package objects, strings, and
symbols.
") ((:LAMBDA-LIST) SI::PACKAGE-SPEC &OPTIONAL (PACKAGE *PACKAGE*)))
USE-VALUE
(((:LAMBDA-LIST) SI::VALUE &OPTIONAL SI::C) ((SI:LOCATION DEFUN USE-VALUE) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 24527))
USER-HOMEDIR-PATHNAME
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&OPTIONAL HOST)

Returns a pathname the represents the user's home directory.  HOST is simply
ignored in ECL.
") ((:LAMBDA-LIST) &OPTIONAL SI::HOST))
C::USES-VALUES
(((:LAMBDA-LIST) C::LOC) ((SI:LOCATION DEFUN C::USES-VALUES) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 2858))
C::VALID-ARRAY-INDEX-P
(((:LAMBDA-LIST) C::X) ((SI:LOCATION DEFUN C::VALID-ARRAY-INDEX-P) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 525))
CLOS::VALID-DECLARATION-P
(((:LAMBDA-LIST) CLOS::DECL) ((SI:LOCATION DEFUN CLOS::VALID-DECLARATION-P) #P"SRC:CLOS;GENERIC.LSP.NEWEST" . 3732))
CLOS::VALID-KEYWORDS-FROM-METHODS
(((:LAMBDA-LIST) &REST CLOS::METHOD-LISTS) ((SI:LOCATION DEFUN CLOS::VALID-KEYWORDS-FROM-METHODS) #P"SRC:CLOS;STANDARD.LSP.NEWEST" . 29538))
C::VALID-TYPE-SPECIFIER
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN C::VALID-TYPE-SPECIFIER) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 2109))
C::VALIDATE-ALIEN-DECLARATION
(((:LAMBDA-LIST) C::NAMES-LIST ERROR) ((SI:LOCATION DEFUN C::VALIDATE-ALIEN-DECLARATION) #P"SRC:CMP;CMPENV-DECLARE.LSP.NEWEST" . 1073))
VALUES
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (&REST ARGS)

Returns ARGs as multiple values, the N-th ARG being the N-th value.
") ((:LAMBDA-LIST) &REST SI::ARGS))
VALUES-LIST
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (LIST)

Returns all elements of LIST as multiple values, the N-th element of LIST
being the N-th value.
") ((:LAMBDA-LIST) LIST))
C::VALUES-LOC
(((:LAMBDA-LIST) C::N) ((SI:LOCATION DEFUN C::VALUES-LOC) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 5367))
C::VALUES-NUMBER-FROM-TYPE
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN C::VALUES-NUMBER-FROM-TYPE) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 3572))
C::VALUES-TYPE-AND
(((:LAMBDA-LIST) C::T1 C::T2) ((SI:LOCATION DEFUN C::VALUES-TYPE-AND) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 7469))
C::VALUES-TYPE-AND-EMPTY-CACHE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::VALUES-TYPE-AND-EMPTY-CACHE) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 7469))
C::VALUES-TYPE-OR
(((:LAMBDA-LIST) C::T1 C::T2) ((SI:LOCATION DEFUN C::VALUES-TYPE-OR) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 5780))
C::VALUES-TYPE-OR-EMPTY-CACHE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::VALUES-TYPE-OR-EMPTY-CACHE) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 5780))
C::VALUES-TYPE-PRIMARY-TYPE
(((:LAMBDA-LIST) TYPE) ((SI:LOCATION DEFUN C::VALUES-TYPE-PRIMARY-TYPE) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 3955))
C::VALUES-TYPE-PRIMARY-TYPE-EMPTY-CACHE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::VALUES-TYPE-PRIMARY-TYPE-EMPTY-CACHE) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 3955))
C::VALUES-TYPE-TO-N-TYPES
(((:LAMBDA-LIST) TYPE LENGTH) ((SI:LOCATION DEFUN C::VALUES-TYPE-TO-N-TYPES) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 4588))
C::VALUES-TYPE-TO-N-TYPES-EMPTY-CACHE
(((:LAMBDA-LIST)) ((SI:LOCATION DEFUN C::VALUES-TYPE-TO-N-TYPES-EMPTY-CACHE) #P"SRC:CMP;CMPTYPE-ARITH.LSP.NEWEST" . 4588))
C::VAR
(((SI:LOCATION DEFCLASS C::VAR) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 1460))
C::VAR-CHANGED-IN-FORM
(((:LAMBDA-LIST) C::VAR C::FORM) ((SI:LOCATION DEFUN C::VAR-CHANGED-IN-FORM) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 1596))
C::VAR-CHANGED-IN-FORM-LIST
(((:LAMBDA-LIST) C::VAR C::FORM-LIST) ((SI:LOCATION DEFUN C::VAR-CHANGED-IN-FORM-LIST) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 895))
C::VAR-READ-FORMS
(((:LAMBDA-LIST) C::VAR) ((SI:LOCATION DEFUN C::VAR-READ-FORMS) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 2532))
C::VAR-REFERENCED-IN-FORM
(((:LAMBDA-LIST) C::VAR C::FORM) ((SI:LOCATION DEFUN C::VAR-REFERENCED-IN-FORM) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 1435))
C::VAR-REFERENCED-IN-FORM-LIST
(((:LAMBDA-LIST) C::VAR C::FORM-LIST) ((SI:LOCATION DEFUN C::VAR-REFERENCED-IN-FORM-LIST) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 770))
C::VAR-REP-TYPE
(((:LAMBDA-LIST) C::VAR) ((SI:LOCATION DEFUN C::VAR-REP-TYPE) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 8853))
VECTOR
(((DOCUMENTATION . FUNCTION) . "Args: (&rest objects)
Creates and returns a simple-vector, with the N-th OBJECT being the N-th
element.") ((:LAMBDA-LIST) &REST SI::OBJECTS) ((SI:LOCATION DEFUN VECTOR) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 3897) ((DOCUMENTATION . TYPE) . "A vector is a one-dimensional array.  Strings and bit-vectors are kinds of
vectors.  Other vectors are called general vectors and are notated as
	#(elem ... elem)
Some vectors may be displaced to another array, may have a fill-pointer, or
may be adjustable.  Other vectors are called simple-vectors."))
VECTOR-POP
(((DOCUMENTATION . FUNCTION) . "Args: (vector)
Decrements the fill-pointer of VECTOR by one and returns the element pointed
to by the new fill-pointer.  Signals an error if the old value of the fill-
pointer is 0 already.") ((:LAMBDA-LIST) VECTOR) ((SI:LOCATION DEFUN VECTOR-POP) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 12901))
VECTOR-PUSH
(((SI:LOCATION DEFINE-COMPILER-MACRO VECTOR-PUSH) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 4897) ((DOCUMENTATION . FUNCTION) . "Args: (item vector)
Replaces ITEM for the element of VECTOR that is pointed to by the fill-pointer
of VECTOR and then increments the fill-pointer by one.  Returns NIL if the new
value of the fill-pointer becomes too large.  Otherwise, returns the new fill-
pointer as the value.") ((:LAMBDA-LIST) SI::NEW-ELEMENT VECTOR) ((SI:LOCATION DEFUN VECTOR-PUSH) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 11333))
VECTOR-PUSH-EXTEND
(((SI:LOCATION DEFINE-COMPILER-MACRO VECTOR-PUSH-EXTEND) #P"SRC:CMP;CMPARRAY.LSP.NEWEST" . 5014) ((DOCUMENTATION . FUNCTION) . "Args: (item vector &optional (n (length vector)))
Replaces ITEM for the element of VECTOR that is pointed to by the fill-pointer
of VECTOR and then increments the fill-pointer by one.  If the new value of
the fill-pointer becomes too large, extends VECTOR for N more elements.
Returns the new value of the fill-pointer.") ((:LAMBDA-LIST) SI::NEW-ELEMENT VECTOR &OPTIONAL (SI::EXTENSION 1)) ((SI:LOCATION DEFUN VECTOR-PUSH-EXTEND) #P"SRC:LSP;ARRAYLIB.LSP.NEWEST" . 11995))
VECTORP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (X)

Returns T if X is a vector; NIL otherwise.
") ((:LAMBDA-LIST) SI::X))
C::VV
(((SI:LOCATION DEFCLASS C::VV) #P"SRC:CMP;CMPTYPES.LSP.NEWEST" . 10201))
C::VV-TYPE
(((:LAMBDA-LIST) C::LOC) ((SI:LOCATION DEFUN C::VV-TYPE) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 11896))
CLOS::WALK-METHOD-LAMBDA
(((:LAMBDA-LIST) CLOS::METHOD-LAMBDA CLOS::REQUIRED-PARAMETERS CLOS::ENV) ((SI:LOCATION DEFUN CLOS::WALK-METHOD-LAMBDA) #P"SRC:CLOS;METHOD.LSP.NEWEST" . 5245))
WARN
(((DOCUMENTATION . FUNCTION) . "Args: (format-string &rest args)
Formats FORMAT-STRING and ARGs to *ERROR-OUTPUT* as a warning message.  Enters
a break level if the value of *BREAK-ON-WARNINGS* is non-NIL.  Otherwise,
returns with NIL.") ((:LAMBDA-LIST) SI::DATUM &REST SI::ARGUMENTS) ((SI:LOCATION DEFUN WARN) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 13974))
WARNING
(((SI:LOCATION DEFCLASS WARNING) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 21775))
WHEN
(((DOCUMENTATION . FUNCTION) . "Macro in COMMON-LISP package:
Syntax: (when test {form}*)

If TEST evaluates to non-NIL, then evaluates FORMs and returns all values of
the last FORM.  If not, simply returns NIL.
") ((:LAMBDA-LIST) . "(when test {form}*)"))
SI:WHILE
(((:LAMBDA-LIST) SI::TEST &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI:WHILE) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 9927))
SI::WHILE-UNTIL
(((:LAMBDA-LIST) SI::TEST SI::BODY SI::JMP-OP) ((SI:LOCATION DEFUN SI::WHILE-UNTIL) #P"SRC:LSP;EVALMACROS.LSP.NEWEST" . 9714))
WITH-ACCESSORS
(((:LAMBDA-LIST) CLOS::SLOT-ACCESSOR-PAIRS CLOS::INSTANCE-FORM &BODY CLOS::BODY) ((SI:LOCATION DEFMACRO WITH-ACCESSORS) #P"SRC:CLOS;METHOD.LSP.NEWEST" . 13876))
C::WITH-C1FORM-ENV
(((:LAMBDA-LIST) (C::FORM C::VALUE) &REST C::BODY) ((SI:LOCATION DEFMACRO C::WITH-C1FORM-ENV) #P"SRC:CMP;CMPFORM.LSP.NEWEST" . 9760))
FFI:WITH-CAST-POINTER
(((:LAMBDA-LIST) FFI::BIND &BODY FFI::BODY) ((SI:LOCATION DEFMACRO FFI:WITH-CAST-POINTER) #P"SRC:LSP;FFI.LSP.NEWEST" . 16092))
C::WITH-CLEAN-SYMBOLS
(((:LAMBDA-LIST) C::SYMBOLS &BODY C::BODY) ((SI:LOCATION DEFMACRO C::WITH-CLEAN-SYMBOLS) #P"SRC:CMP;CMPMAC.LSP.NEWEST" . 2986))
C::WITH-CMP-PROTECTION
(((:LAMBDA-LIST) C::MAIN-FORM C::ERROR-FORM) ((SI:LOCATION DEFMACRO C::WITH-CMP-PROTECTION) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 10814))
WITH-COMPILATION-UNIT
(((:LAMBDA-LIST) C::OPTIONS &REST C::BODY) ((SI:LOCATION DEFMACRO WITH-COMPILATION-UNIT) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 34073))
C::WITH-COMPILER-ENV
(((:LAMBDA-LIST) (C::COMPILER-CONDITIONS) &BODY C::BODY) ((SI:LOCATION DEFMACRO C::WITH-COMPILER-ENV) #P"SRC:CMP;CMPUTIL.LSP.NEWEST" . 6596))
WITH-CONDITION-RESTARTS
(((:LAMBDA-LIST) CONDITION SI::RESTARTS &BODY SI::FORMS) ((SI:LOCATION DEFMACRO WITH-CONDITION-RESTARTS) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 6688))
SI::WITH-COUNT
(((:LAMBDA-LIST) (COUNT &OPTIONAL (SI::VALUE COUNT) &KEY (SI::OUTPUT NIL SI::OUTPUT-P)) &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::WITH-COUNT) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/src/lsp/seqmacros.lsp" . 558))
FFI:WITH-CSTRING
(((:LAMBDA-LIST) (FFI::CSTRING STRING) &BODY FFI::BODY) ((SI:LOCATION DEFMACRO FFI:WITH-CSTRING) #P"SRC:LSP;FFI.LSP.NEWEST" . 13549))
FFI:WITH-CSTRINGS
(((:LAMBDA-LIST) FFI::BINDINGS &REST FFI::BODY) ((SI:LOCATION DEFMACRO FFI:WITH-CSTRINGS) #P"SRC:LSP;FFI.LSP.NEWEST" . 13662))
C::WITH-CURRENT-DIRECTORY
(((:LAMBDA-LIST) &BODY C::FORMS) ((SI:LOCATION DEFMACRO C::WITH-CURRENT-DIRECTORY) #P"SRC:CMP;CMPOS-RUN.LSP.NEWEST" . 1223))
SI:WITH-ECL-IO-SYNTAX
(((DOCUMENTATION . FUNCTION) . "Syntax: ({forms}*)
The forms of the body are executed in a print envirtoponment that corresponds to
the one used internally by ECL compiled files.") ((:LAMBDA-LIST) &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI:WITH-ECL-IO-SYNTAX) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 10709))
C::WITH-EXIT-LABEL
(((:LAMBDA-LIST) (C::LABEL) &BODY C::BODY) ((SI:LOCATION DEFMACRO C::WITH-EXIT-LABEL) #P"SRC:CMP;CMPIF.LSP.NEWEST" . 2627))
FFI:WITH-FOREIGN-OBJECT
(((:LAMBDA-LIST) (FFI::VAR TYPE) &BODY FFI::BODY) ((SI:LOCATION DEFMACRO FFI:WITH-FOREIGN-OBJECT) #P"SRC:LSP;FFI.LSP.NEWEST" . 15720))
FFI:WITH-FOREIGN-OBJECTS
(((:LAMBDA-LIST) FFI::BINDINGS &REST FFI::BODY) ((SI:LOCATION DEFMACRO FFI:WITH-FOREIGN-OBJECTS) #P"SRC:LSP;FFI.LSP.NEWEST" . 15898))
FFI:WITH-FOREIGN-STRING
(((:LAMBDA-LIST) (FFI::FOREIGN-STRING FFI::LISP-STRING) &REST FFI::BODY) ((SI:LOCATION DEFMACRO FFI:WITH-FOREIGN-STRING) #P"SRC:LSP;FFI.LSP.NEWEST" . 15160))
FFI:WITH-FOREIGN-STRINGS
(((:LAMBDA-LIST) FFI::BINDINGS &REST FFI::BODY) ((SI:LOCATION DEFMACRO FFI:WITH-FOREIGN-STRINGS) #P"SRC:LSP;FFI.LSP.NEWEST" . 15432))
SI::WITH-GRABBED-CONSOLE
(((:LAMBDA-LIST) &REST SI::BODY) ((SI:LOCATION DEFMACRO SI::WITH-GRABBED-CONSOLE) #P"SRC:LSP;TOP.LSP.NEWEST" . 17211))
WITH-HASH-TABLE-ITERATOR
(((DOCUMENTATION . FUNCTION) . "Syntax: (with-hash-table-iterator (iterator package) &body body)
Loop over the elements of a hash table. ITERATOR is a lexically bound function
that outputs three values
	(VALUES entry-p key value)
ENTRY-P is true only if KEY and VALUE denote a pair of key and value of the
hash table; otherwise it signals that we have reached the end of the hash table.") ((:LAMBDA-LIST) (SI::ITERATOR PACKAGE) &BODY SI::BODY) ((SI:LOCATION DEFMACRO WITH-HASH-TABLE-ITERATOR) #P"SRC:LSP;MISLIB.LSP.NEWEST" . 10118))
C::WITH-INLINED-LOC
(((:LAMBDA-LIST) (C::TEMP-LOC C::LOC) &REST C::BODY) ((SI:LOCATION DEFMACRO C::WITH-INLINED-LOC) #P"SRC:CMP;CMPINLINE.LSP.NEWEST" . 2036))
WITH-INPUT-FROM-STRING
(((DOCUMENTATION . FUNCTION) . "Syntax: (with-input-from-string (var string-form {keyword value}*)
           {decl}* {form}*)
Evaluates FORMs with VAR bound to a string input stream from the string that
is the value of STRING-FORM.  The stream is automatically closed on exit.
Possible keywords are :INDEX, :START, and :END.") ((:LAMBDA-LIST) (SI::VAR STRING &KEY SI::INDEX (SI::START 0) SI::END) &REST SI::BODY) ((SI:LOCATION DEFMACRO WITH-INPUT-FROM-STRING) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 955))
MP:WITH-INTERRUPTS
(((DOCUMENTATION . FUNCTION) . "Executes BODY with deferrable interrupts conditionally enabled. If there
are pending interrupts they take effect prior to executing BODY.

As interrupts are normally allowed WITH-INTERRUPTS only makes sense if there
is an outer WITHOUT-INTERRUPTS with a corresponding ALLOW-WITH-INTERRUPTS:
interrupts are not enabled if any outer WITHOUT-INTERRUPTS is not accompanied
by ALLOW-WITH-INTERRUPTS.") ((:LAMBDA-LIST) &BODY MP::BODY) ((SI:LOCATION DEFMACRO MP:WITH-INTERRUPTS) #P"SRC:LSP;MP.LSP.NEWEST" . 3764))
SI::WITH-KEY
(((:LAMBDA-LIST) (SI::AKEY) &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::WITH-KEY) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/src/lsp/seqmacros.lsp" . 1165))
MP:WITH-LOCK
(((:LAMBDA-LIST) (MP::LOCK-FORM &REST MP::OPTIONS) &BODY MP::BODY) ((SI:LOCATION DEFMACRO MP:WITH-LOCK) #P"SRC:LSP;MP.LSP.NEWEST" . 4752))
C::WITH-LOCK
(((:LAMBDA-LIST) (C::LOCK) &BODY C::BODY) ((SI:LOCATION DEFMACRO C::WITH-LOCK) #P"SRC:CMP;CMPMAIN.LSP.NEWEST" . 618))
SI::WITH-LOOP-LIST-COLLECTION-HEAD
(((:LAMBDA-LIST) (SI::HEAD-VAR SI::TAIL-VAR &OPTIONAL SI::USER-HEAD-VAR) &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::WITH-LOOP-LIST-COLLECTION-HEAD) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 9733))
SI::WITH-MINIMAX-VALUE
(((:LAMBDA-LIST) SI::LM &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::WITH-MINIMAX-VALUE) #P"SRC:LSP;LOOP2.LSP.NEWEST" . 16340))
WITH-OPEN-FILE
(((DOCUMENTATION . FUNCTION) . "Syntax: (with-open-file (var filespec-form {options}*) {decl}* {form}*)
Opens the specified file using OPTIONs, and evaluates FORMs with VAR bound to
a stream to/from the file.  The file is automatically closed on exit.  See
OPEN for the options.") ((:LAMBDA-LIST) (STREAM . SI::FILESPEC) &REST SI::BODY) ((SI:LOCATION DEFMACRO WITH-OPEN-FILE) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 4825))
WITH-OPEN-STREAM
(((DOCUMENTATION . FUNCTION) . "Syntax: (with-open-stream (var stream-form) {decl}* {form}*)
Evaluates FORMs with VAR bound to the value of STREAM-FORM.  The stream is
automatically closed on exit.") ((:LAMBDA-LIST) (SI::VAR STREAM) &REST SI::BODY) ((SI:LOCATION DEFMACRO WITH-OPEN-STREAM) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 561))
WITH-OUTPUT-TO-STRING
(((DOCUMENTATION . FUNCTION) . "Syntax: (with-output-to-string (var [string-form]) {decl}* {form}*)
Evaluates FORMs with VAR bound to a string output stream to the string that is
the value of STRING-FORM.  If STRING-FORM is not given, a new string is used.
The stream is automatically closed on exit and the string is returned.") ((:LAMBDA-LIST) (SI::VAR &OPTIONAL STRING &REST SI::R &KEY SI::ELEMENT-TYPE) &REST SI::BODY) ((SI:LOCATION DEFMACRO WITH-OUTPUT-TO-STRING) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 1745))
WITH-PACKAGE-ITERATOR
(((:LAMBDA-LIST) (SI::ITERATOR SI::PACKAGE-LIST &REST SI::CONDITIONS) &REST SI::BODY) ((SI:LOCATION DEFMACRO WITH-PACKAGE-ITERATOR) #P"SRC:LSP;PACKLIB.LSP.NEWEST" . 2807))
SI::WITH-PREDICATE
(((:LAMBDA-LIST) (SI::PREDICATE) &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::WITH-PREDICATE) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/src/lsp/seqmacros.lsp" . 864))
WITH-SIMPLE-RESTART
(((:LAMBDA-LIST) (RESTART-NAME SI::FORMAT-CONTROL &REST SI::FORMAT-ARGUMENTS) &BODY SI::FORMS) ((SI:LOCATION DEFMACRO WITH-SIMPLE-RESTART) #P"SRC:CLOS;CONDITIONS.LSP.NEWEST" . 6401))
WITH-SLOTS
(((:LAMBDA-LIST) CLOS::SLOT-ENTRIES CLOS::INSTANCE-FORM &BODY CLOS::BODY) ((SI:LOCATION DEFMACRO WITH-SLOTS) #P"SRC:CLOS;METHOD.LSP.NEWEST" . 13241))
WITH-STANDARD-IO-SYNTAX
(((DOCUMENTATION . FUNCTION) . "Syntax: ({forms}*)
The forms of the body are executed in a print envirtoponment that corresponds to
the one defined in the ANSI standard. *print-base* is 10, *print-array* is t,
*package* is \"CL-USER\", etc.") ((:LAMBDA-LIST) &BODY SI::BODY) ((SI:LOCATION DEFMACRO WITH-STANDARD-IO-SYNTAX) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 10360))
SI::WITH-START-END
(((:LAMBDA-LIST) (SI::START SI::END SI::SEQ &OPTIONAL (LENGTH (GENSYM))) &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::WITH-START-END) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/src/lsp/seqmacros.lsp" . 2114))
SI::WITH-TESTS
(((:LAMBDA-LIST) &WHOLE SI::WHOLE (SI::TEST SI::TEST-NOT &OPTIONAL SI::KEY) &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI::WITH-TESTS) #P"/home/linkfly/Downloads/lisp-dev-tools/sources/lisp-sources/ecl/ecl-11.1.1/src/lsp/seqmacros.lsp" . 1447))
SI:WITH-UNIQUE-NAMES
(((:LAMBDA-LIST) SI::SYMBOLS &BODY SI::BODY) ((SI:LOCATION DEFMACRO SI:WITH-UNIQUE-NAMES) #P"SRC:LSP;CMUUTIL.LSP.NEWEST" . 4960))
MP:WITHOUT-INTERRUPTS
(((DOCUMENTATION . FUNCTION) . "Executes BODY with all deferrable interrupts disabled. Deferrable
interrupts arriving during execution of the BODY take effect after BODY has
been executed.

Deferrable interrupts include most blockable POSIX signals, and
SB-THREAD:INTERRUPT-THREAD. Does not interfere with garbage collection, and
unlike in many traditional Lisps using userspace threads, in SBCL
WITHOUT-INTERRUPTS does not inhibit scheduling of other threads.

Binds ALLOW-WITH-INTERRUPTS, WITH-LOCAL-INTERRUPTS and WITH-RESTORED-INTERRUPTS
as a local macros.

WITH-RESTORED-INTERRUPTS executes the body with interrupts enabled if and only
if the WITHOUT-INTERRUPTS was in an environment in which interrupts were allowed.

ALLOW-WITH-INTERRUPTS allows the WITH-INTERRUPTS to take effect during the
dynamic scope of its body, unless there is an outer WITHOUT-INTERRUPTS without
a corresponding ALLOW-WITH-INTERRUPTS.

WITH-LOCAL-INTERRUPTS executes its body with interrupts enabled provided that
for there is an ALLOW-WITH-INTERRUPTS for every WITHOUT-INTERRUPTS surrounding
the current one. WITH-LOCAL-INTERRUPTS is equivalent to:

  (allow-with-interrupts (with-interrupts ...))

Care must be taken not to let either ALLOW-WITH-INTERRUPTS or
WITH-LOCAL-INTERRUPTS appear in a function that escapes from inside the
WITHOUT-INTERRUPTS in:

  (without-interrupts
    ;; The body of the lambda would be executed with WITH-INTERRUPTS allowed
    ;; regardless of the interrupt policy in effect when it is called.
    (lambda () (allow-with-interrupts ...)))

  (without-interrupts
    ;; The body of the lambda would be executed with interrupts enabled
    ;; regardless of the interrupt policy in effect when it is called.
    (lambda () (with-local-interrupts ...)))
") ((:LAMBDA-LIST) &BODY MP::BODY) ((SI:LOCATION DEFMACRO MP:WITHOUT-INTERRUPTS) #P"SRC:LSP;MP.LSP.NEWEST" . 596))
CLOS::WRAPPED-METHOD-FUNCTION
(((:LAMBDA-LIST) CLOS:METHOD-FUNCTION) ((SI:LOCATION DEFUN CLOS::WRAPPED-METHOD-FUNCTION) #P"SRC:CLOS;COMBIN.LSP.NEWEST" . 3115))
WRITE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (OBJECT &KEY (STREAM *STANDARD-OUTPUT*) (ESCAPE *PRINT-ESCAPE*) (RADIX *PRINT-RADIX*) (BASE *PRINT-BASE*) (CIRCLE *PRINT-CIRCLE*) (PRETTY *PRINT-PRETTY*) (LEVEL *PRINT-LEVEL*) (LENGTH *PRINT-LENGTH*) (CASE *PRINT-CASE*) (ARRAY *PRINT-ARRAY*) (GENSYM *PRINT-GENSYM*))

Prints OBJECT in the specified mode.  See the variable docs of *PRINT-...* for
the mode.
") ((:LAMBDA-LIST) SI::OBJECT &KEY (STREAM *STANDARD-OUTPUT*) (SI::ESCAPE *PRINT-ESCAPE*) (SI::RADIX *PRINT-RADIX*) (SI::BASE *PRINT-BASE*) (SI::CIRCLE *PRINT-CIRCLE*) (SI::PRETTY *PRINT-PRETTY*) (SI::LEVEL *PRINT-LEVEL*) (LENGTH *PRINT-LENGTH*) (CASE *PRINT-CASE*) (ARRAY *PRINT-ARRAY*) (GENSYM *PRINT-GENSYM*)))
WRITE-BYTE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (INTEGER STREAM)

Outputs INTEGER to the binary stream STREAM.  Returns INTEGER.
") ((:LAMBDA-LIST) INTEGER STREAM))
WRITE-CHAR
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (CHAR &OPTIONAL (STREAM *STANDARD-OUTPUT*))

Outputs CHAR to STREAM.  Returns CHAR.
") ((:LAMBDA-LIST) CHAR &OPTIONAL (STREAM *STANDARD-OUTPUT*)))
WRITE-LINE
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING &OPTIONAL (STREAM *STANDARD-OUTPUT*) &KEY (START 0) (END (LENGTH STRING)))

Outputs STRING and a newline character to STREAM.  Returns STRING.
") ((:LAMBDA-LIST) STRING &OPTIONAL (STREAM *STANDARD-OUTPUT*) &KEY (SI::START 0) (SI::END (LENGTH STRING))))
WRITE-STRING
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (STRING &OPTIONAL (STREAM *STANDARD-OUTPUT*) &KEY (START 0) (END (LENGTH STRING)))

Outputs STRING to STREAM.  Returns STRING.
") ((:LAMBDA-LIST) STRING &OPTIONAL (STREAM *STANDARD-OUTPUT*) &KEY (SI::START 0) (SI::END (LENGTH STRING))))
WRITE-TO-STRING
(((DOCUMENTATION . FUNCTION) . "Args: (object &key (escape *print-escape*) (radix *print-radix*)
                   (base *print-base*) (circle *print-circle*)
                   (pretty *print-pretty*) (level *print-level*)
                   (length *print-length*) (case *print-case*)
                   (array *print-array*) (gensym *print-gensym*))
Returns as a string the printed representation of OBJECT in the specified
mode.  See the variable docs of *PRINT-...* for the mode.") ((:LAMBDA-LIST) SI::OBJECT &REST REST &AUX (STREAM (MAKE-STRING-OUTPUT-STREAM))) ((SI:LOCATION DEFUN WRITE-TO-STRING) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 3603))
CLOS:WRITER-METHOD-CLASS
(((SI:LOCATION DEFMETHOD CLOS:WRITER-METHOD-CLASS (CLASS CLOS::STD-CLASS) (CLOS::DIRECT-SLOT CLOS:DIRECT-SLOT-DEFINITION) &REST CLOS::INITARGS) #P"SRC:CLOS;FIXUP.LSP.NEWEST" . 2709))
SI:WRONG-TYPE-ARGUMENT
(((:LAMBDA-LIST) SI::OBJECT TYPE &OPTIONAL SI::PLACE FUNCTION) ((SI:LOCATION DEFUN SI:WRONG-TYPE-ARGUMENT) #P"SRC:LSP;ASSERT.LSP.NEWEST" . 656))
C::WT
(((:LAMBDA-LIST) &REST C::FORMS) ((SI:LOCATION DEFUN C::WT) #P"SRC:CMP;CMPC-WT.LSP.NEWEST" . 983))
C::WT-C-INLINE-LOC
(((:LAMBDA-LIST) C::OUTPUT-REP-TYPE C::C-EXPRESSION C::COERCED-ARGUMENTS C::SIDE-EFFECTS C::OUTPUT-VARS) ((SI:LOCATION DEFUN C::WT-C-INLINE-LOC) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 21303))
C::WT-CADR
(((:LAMBDA-LIST) C::LOC) ((SI:LOCATION DEFUN C::WT-CADR) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 4649))
C::WT-CALL
(((:LAMBDA-LIST) C::FUN C::ARGS &OPTIONAL C::FNAME C::ENV) ((SI:LOCATION DEFUN C::WT-CALL) #P"SRC:CMP;CMPCALL.LSP.NEWEST" . 8272))
C::WT-CALL-INDIRECT
(((:LAMBDA-LIST) C::FUN-LOC C::ARGS C::FNAME C::FUNCTION-P) ((SI:LOCATION DEFUN C::WT-CALL-INDIRECT) #P"SRC:CMP;CMPCALL.LSP.NEWEST" . 8704))
C::WT-CALL-NORMAL
(((:LAMBDA-LIST) C::FUN C::ARGS) ((SI:LOCATION DEFUN C::WT-CALL-NORMAL) #P"SRC:CMP;CMPCALL.LSP.NEWEST" . 9042))
C::WT-CAR
(((:LAMBDA-LIST) C::LOC) ((SI:LOCATION DEFUN C::WT-CAR) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 4565))
C::WT-CDR
(((:LAMBDA-LIST) C::LOC) ((SI:LOCATION DEFUN C::WT-CDR) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 4607))
C::WT-CHARACTER
(((:LAMBDA-LIST) C::VALUE &OPTIONAL C::VV) ((SI:LOCATION DEFUN C::WT-CHARACTER) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 4956))
C::WT-COERCE-LOC
(((:LAMBDA-LIST) C::DEST-REP-TYPE C::LOC) ((SI:LOCATION DEFUN C::WT-COERCE-LOC) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 9572))
C::WT-COMMENT
(((:LAMBDA-LIST) C::MESSAGE &REST C::EXTRA) ((SI:LOCATION DEFUN C::WT-COMMENT) #P"SRC:CMP;CMPC-WT.LSP.NEWEST" . 2657))
C::WT-COMMENT-NL
(((:LAMBDA-LIST) C::MESSAGE &REST C::EXTRA) ((SI:LOCATION DEFUN C::WT-COMMENT-NL) #P"SRC:CMP;CMPC-WT.LSP.NEWEST" . 2735))
C::WT-DATA-BEGIN
(((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFUN C::WT-DATA-BEGIN) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 4329))
C::WT-DATA-END
(((:LAMBDA-LIST) STREAM) ((SI:LOCATION DEFUN C::WT-DATA-END) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 4367))
C::WT-ENV
(((:LAMBDA-LIST) C::CLV) ((SI:LOCATION DEFUN C::WT-ENV) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 9781))
C::WT-FDEFINITION
(((:LAMBDA-LIST) C::FUN-NAME) ((SI:LOCATION DEFUN C::WT-FDEFINITION) #P"SRC:CMP;CMPSPECIAL.LSP.NEWEST" . 4390))
C::WT-FILTERED-COMMENT
(((:LAMBDA-LIST) C::TEXT STREAM C::SINGLE-LINE) ((SI:LOCATION DEFUN C::WT-FILTERED-COMMENT) #P"SRC:CMP;CMPC-WT.LSP.NEWEST" . 1670))
C::WT-FILTERED-DATA
(((:LAMBDA-LIST) STRING STREAM &OPTIONAL C::ONE-LINER) ((SI:LOCATION DEFUN C::WT-FILTERED-DATA) #P"SRC:CMP;CMPC-WT.LSP.NEWEST" . 3111))
C::WT-FROM-OBJECT-CONVERSION
(((:LAMBDA-LIST) C::DEST-TYPE C::LOC-TYPE C::REP-TYPE C::LOC) ((SI:LOCATION DEFUN C::WT-FROM-OBJECT-CONVERSION) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 7101))
C::WT-FUNCTION-EPILOGUE
(((:LAMBDA-LIST) &OPTIONAL C::CLOSURE-TYPE) ((SI:LOCATION DEFUN C::WT-FUNCTION-EPILOGUE) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 14688))
C::WT-FUNCTION-PROLOG
(((:LAMBDA-LIST) &OPTIONAL C::SP C::LOCAL-ENTRY) ((SI:LOCATION DEFUN C::WT-FUNCTION-PROLOG) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 14406))
C::WT-GLOBAL-ENTRY
(((:LAMBDA-LIST) C::FNAME C::CFUN C::ARG-TYPES C::RETURN-TYPE) ((SI:LOCATION DEFUN C::WT-GLOBAL-ENTRY) #P"SRC:CMP;CMPTOP.LSP.NEWEST" . 16197))
C::WT-GO
(((:LAMBDA-LIST) C::LABEL) ((SI:LOCATION DEFUN C::WT-GO) #P"SRC:CMP;CMPC-WT.LSP.NEWEST" . 1405))
C::WT-H
(((:LAMBDA-LIST) &REST C::FORMS) ((SI:LOCATION DEFUN C::WT-H) #P"SRC:CMP;CMPC-WT.LSP.NEWEST" . 1030))
C::WT-H1
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::WT-H1) #P"SRC:CMP;CMPC-WT.LSP.NEWEST" . 896))
C::WT-KEYVARS
(((:LAMBDA-LIST) C::I) ((SI:LOCATION DEFUN C::WT-KEYVARS) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 5090))
C::WT-LABEL
(((:LAMBDA-LIST) C::LABEL) ((SI:LOCATION DEFUN C::WT-LABEL) #P"SRC:CMP;CMPC-WT.LSP.NEWEST" . 1514))
C::WT-LCL
(((:LAMBDA-LIST) C::LCL) ((SI:LOCATION DEFUN C::WT-LCL) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 4740))
C::WT-LCL-LOC
(((:LAMBDA-LIST) C::LCL &OPTIONAL TYPE) ((SI:LOCATION DEFUN C::WT-LCL-LOC) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 4807))
C::WT-LEX
(((:LAMBDA-LIST) C::LEX) ((SI:LOCATION DEFUN C::WT-LEX) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 9634))
C::WT-LOC
(((:LAMBDA-LIST) C::LOC &AUX C::FD) ((SI:LOCATION DEFUN C::WT-LOC) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 3832))
C::WT-MAKE-CLOSURE
(((:LAMBDA-LIST) C::FUN &AUX (C::CFUN (C::FUN-CFUN C::FUN))) ((SI:LOCATION DEFUN C::WT-MAKE-CLOSURE) #P"SRC:CMP;CMPSPECIAL.LSP.NEWEST" . 4948))
C::WT-NL
(((:LAMBDA-LIST) &REST C::FORMS) ((SI:LOCATION DEFUN C::WT-NL) #P"SRC:CMP;CMPC-WT.LSP.NEWEST" . 1223))
C::WT-NL-H
(((:LAMBDA-LIST) &REST C::FORMS) ((SI:LOCATION DEFUN C::WT-NL-H) #P"SRC:CMP;CMPC-WT.LSP.NEWEST" . 1081))
C::WT-NL1
(((:LAMBDA-LIST) &REST C::FORMS) ((SI:LOCATION DEFUN C::WT-NL1) #P"SRC:CMP;CMPC-WT.LSP.NEWEST" . 1305))
C::WT-NUMBER
(((:LAMBDA-LIST) C::VALUE &OPTIONAL C::VV) ((SI:LOCATION DEFUN C::WT-NUMBER) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 4903))
C::WT-STACK-POINTER
(((:LAMBDA-LIST) C::NARG) ((SI:LOCATION DEFUN C::WT-STACK-POINTER) #P"SRC:CMP;CMPCALL.LSP.NEWEST" . 8201))
C::WT-STRUCTURE-REF
(((:LAMBDA-LIST) C::LOC C::NAME-VV C::INDEX C::UNSAFE) ((SI:LOCATION DEFUN C::WT-STRUCTURE-REF) #P"SRC:CMP;CMPSTRUCTURES.LSP.NEWEST" . 3100))
C::WT-TEMP
(((:LAMBDA-LIST) C::TEMP) ((SI:LOCATION DEFUN C::WT-TEMP) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 4863))
C::WT-TO-OBJECT-CONVERSION
(((:LAMBDA-LIST) C::LOC-REP-TYPE C::LOC) ((SI:LOCATION DEFUN C::WT-TO-OBJECT-CONVERSION) #P"SRC:CMP;CMPFFI.LSP.NEWEST" . 6672))
C::WT-VALUE
(((:LAMBDA-LIST) C::I) ((SI:LOCATION DEFUN C::WT-VALUE) #P"SRC:CMP;CMPLOC.LSP.NEWEST" . 5034))
C::WT-VAR
(((:LAMBDA-LIST) C::VAR &AUX (C::VAR-LOC (C::VAR-LOC C::VAR))) ((SI:LOCATION DEFUN C::WT-VAR) #P"SRC:CMP;CMPVAR.LSP.NEWEST" . 8524))
C::WT-VV
(((:LAMBDA-LIST) C::VV-LOC) ((SI:LOCATION DEFUN C::WT-VV) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 11656))
C::WT-VV-INDEX
(((:LAMBDA-LIST) C::INDEX C::PERMANENT-P) ((SI:LOCATION DEFUN C::WT-VV-INDEX) #P"SRC:CMP;CMPWT.LSP.NEWEST" . 11325))
C::WT1
(((:LAMBDA-LIST) C::FORM) ((SI:LOCATION DEFUN C::WT1) #P"SRC:CMP;CMPC-WT.LSP.NEWEST" . 574))
Y-OR-N-P
(((DOCUMENTATION . FUNCTION) . "Args: (&optional format-string &rest args)
Asks the user a Y-or-N question.  Does FRESH-LINE, prints a message as if
FORMAT-STRING and ARGs were given to FORMAT, and then prints \"(Y or N)\" is
printed.  If FORMAT-STRING is NIL, however, no prompt will appear.") ((:LAMBDA-LIST) &OPTIONAL STRING &REST SI::ARGS) ((SI:LOCATION DEFUN Y-OR-N-P) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 5399))
YES-OR-NO-P
(((DOCUMENTATION . FUNCTION) . "Args: (&optional format-string &rest args)
Asks the user an YES-or-NO question.  Does FRESH-LINE, prints a message as if
FORMAT-STRING and ARGs were given to FORMAT, and then prints \"(Y or N)\" is
printed.  If FORMAT-STRING is NIL, however, no prompt will appear.") ((:LAMBDA-LIST) &OPTIONAL STRING &REST SI::ARGS) ((SI:LOCATION DEFUN YES-OR-NO-P) #P"SRC:LSP;IOLIB.LSP.NEWEST" . 6021))
ZEROP
(((DOCUMENTATION . FUNCTION) . "Function in COMMON-LISP package:
Args: (NUMBER)

Returns T if the arg is zero; NIL otherwise.
") ((:LAMBDA-LIST) NUMBER))
